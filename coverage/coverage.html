
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pbrown12303/activeCRL/core/BaseGraph.go (37.5%)</option>
				
				<option value="file1">github.com/pbrown12303/activeCRL/core/ChangeNotification.go (41.4%)</option>
				
				<option value="file2">github.com/pbrown12303/activeCRL/core/Core.go (100.0%)</option>
				
				<option value="file3">github.com/pbrown12303/activeCRL/core/CrlGraph.go (73.5%)</option>
				
				<option value="file4">github.com/pbrown12303/activeCRL/core/Element.go (83.4%)</option>
				
				<option value="file5">github.com/pbrown12303/activeCRL/core/FunctionCall.go (0.0%)</option>
				
				<option value="file6">github.com/pbrown12303/activeCRL/core/FunctionCallGraph.go (87.0%)</option>
				
				<option value="file7">github.com/pbrown12303/activeCRL/core/Literal.go (86.4%)</option>
				
				<option value="file8">github.com/pbrown12303/activeCRL/core/NotificationGraph.go (0.0%)</option>
				
				<option value="file9">github.com/pbrown12303/activeCRL/core/OneToNStringMap.go (92.7%)</option>
				
				<option value="file10">github.com/pbrown12303/activeCRL/core/Reference.go (72.4%)</option>
				
				<option value="file11">github.com/pbrown12303/activeCRL/core/Refinement.go (79.1%)</option>
				
				<option value="file12">github.com/pbrown12303/activeCRL/core/StringElementMap.go (69.0%)</option>
				
				<option value="file13">github.com/pbrown12303/activeCRL/core/StringStringMap.go (61.1%)</option>
				
				<option value="file14">github.com/pbrown12303/activeCRL/core/Trace.go (0.0%)</option>
				
				<option value="file15">github.com/pbrown12303/activeCRL/core/Transaction.go (89.1%)</option>
				
				<option value="file16">github.com/pbrown12303/activeCRL/core/UndoManager.go (81.9%)</option>
				
				<option value="file17">github.com/pbrown12303/activeCRL/core/UndoStack.go (66.7%)</option>
				
				<option value="file18">github.com/pbrown12303/activeCRL/core/UndoStackEntry.go (100.0%)</option>
				
				<option value="file19">github.com/pbrown12303/activeCRL/core/UniverseOfDiscourse.go (81.7%)</option>
				
				<option value="file20">github.com/pbrown12303/activeCRL/core/UofDManager.go (42.9%)</option>
				
				<option value="file21">github.com/pbrown12303/activeCRL/core/Utilities.go (68.7%)</option>
				
				<option value="file22">github.com/pbrown12303/activeCRL/core/VersionCounter.go (100.0%)</option>
				
				<option value="file23">github.com/pbrown12303/activeCRL/crldatastructuresdomain/CrlDataStructures.go (100.0%)</option>
				
				<option value="file24">github.com/pbrown12303/activeCRL/crldatastructuresdomain/Lists.go (77.2%)</option>
				
				<option value="file25">github.com/pbrown12303/activeCRL/crldatastructuresdomain/Sets.go (98.1%)</option>
				
				<option value="file26">github.com/pbrown12303/activeCRL/crldatastructuresdomain/StringLists.go (78.9%)</option>
				
				<option value="file27">github.com/pbrown12303/activeCRL/crldatatypesdomain/Boolean.go (100.0%)</option>
				
				<option value="file28">github.com/pbrown12303/activeCRL/crldatatypesdomain/CrlDataTypes.go (100.0%)</option>
				
				<option value="file29">github.com/pbrown12303/activeCRL/crldiagramdomain/Diagram.go (77.4%)</option>
				
				<option value="file30">github.com/pbrown12303/activeCRL/crleditor/CrlEditor.go (49.6%)</option>
				
				<option value="file31">github.com/pbrown12303/activeCRL/crleditor/CrlWorkspaceManager.go (11.1%)</option>
				
				<option value="file32">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/BrowserGUI.go (52.8%)</option>
				
				<option value="file33">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/BrowserGUIDiagramElementManager.go (84.4%)</option>
				
				<option value="file34">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/BrowsweGUIDiagramManager.go (44.1%)</option>
				
				<option value="file35">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/ClientNotificationManager.go (66.7%)</option>
				
				<option value="file36">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/PropertyManager.go (72.7%)</option>
				
				<option value="file37">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/Server.go (40.3%)</option>
				
				<option value="file38">github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui/TreeManager.go (52.6%)</option>
				
				<option value="file39">github.com/pbrown12303/activeCRL/crleditorbrowsergui/main.go (0.0%)</option>
				
				<option value="file40">github.com/pbrown12303/activeCRL/crleditordomain/EditorDomain.go (91.7%)</option>
				
				<option value="file41">github.com/pbrown12303/activeCRL/crleditorfynegui/fynegui/FyneGUI.go (0.0%)</option>
				
				<option value="file42">github.com/pbrown12303/activeCRL/crleditorfynegui/fynegui/TreeManager.go (0.0%)</option>
				
				<option value="file43">github.com/pbrown12303/activeCRL/crleditorfynegui/main.go (0.0%)</option>
				
				<option value="file44">github.com/pbrown12303/activeCRL/crlmapsdomain/CrlMaps.go (62.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

import (
        "log"
        "reflect"
        "strconv"

        "github.com/awalterschulze/gographviz"
)

type baseGraph struct {
        graph             *gographviz.Graph
        callAnnotation    map[string]string
        nodeElementLabels map[string]string
        nodeElementTypes  map[string]string
        // rootNodeIDs maps a parent graph to the ID of its root node. Each graph or subgraph has a root node.
        rootNodeIDs map[string]string
        // parentGraphNodePrefix maps each parentGraph to the prefix used for its nodes
        parentGraphNodePrefix map[string]string
        // parentGraphCallSequence keeps track of the call sequence for each graph
        parentGraphCallSequence map[string]int
        // nodeToGraphName keeps track of the graph (or subgraph) name in whieh the node resides
        nodeToGraphName map[string]string
}

func (bgPtr *baseGraph) initializeBaseGraph(graphName string) <span class="cov8" title="1">{
        bgPtr.graph = gographviz.NewGraph()
        bgPtr.graph.SetDir(true)
        bgPtr.graph.SetStrict(true)
        bgPtr.graph.SetName(graphName)
        bgPtr.callAnnotation = make(map[string]string)
        bgPtr.nodeElementLabels = make(map[string]string)
        bgPtr.nodeElementTypes = make(map[string]string)
        bgPtr.rootNodeIDs = make(map[string]string)
        bgPtr.parentGraphNodePrefix = make(map[string]string)
        bgPtr.parentGraphCallSequence = make(map[string]int)
        bgPtr.nodeToGraphName = make(map[string]string)
}</span>

// addNotification adds a notification to a graph (its parent graph). The reporting element is added to the graph if not already present.
// If this is the root notification, the ID of the reporting element becomes the rootNodeID for the parentGraph.
// If the reporting element does not exist as a node, a node is created and an annotation is added to indicate the type of notification
// and the position in the notification hierarcy. If the reporting element already exists then a new annotation is just added
func (bgPtr *baseGraph) addNotification(notification *ChangeNotification, parentGraph string) string <span class="cov8" title="1">{
        reportingElement := notification.uOfD.GetElement(notification.GetReportingElementID()) // this will return nil after an element deletion
        reportingElementNodeID := bgPtr.makeNode(notification.GetReportingElementID(), notification.GetReportingElementType(), notification.GetReportingElementLabel(), parentGraph, false, "")
        // By definition, the root notification's changed object is the root node
        if bgPtr.rootNodeIDs[parentGraph] == "" </span><span class="cov8" title="1">{
                bgPtr.rootNodeIDs[parentGraph] = reportingElementNodeID
        }</span>
        <span class="cov8" title="1">bgPtr.nodeElementLabels[reportingElementNodeID] = notification.GetReportingElementLabel()
        bgPtr.nodeElementTypes[reportingElementNodeID] = notification.GetReportingElementType()

        bgPtr.callAnnotation[reportingElementNodeID] = bgPtr.callAnnotation[reportingElementNodeID] + "&lt;TR&gt;&lt;TD&gt;" + strconv.Itoa(bgPtr.parentGraphCallSequence[parentGraph]) + ":" + notification.GetChangedConceptID() + notification.natureOfChange.String() + "&lt;/TD&gt;&lt;/TR&gt;"
        bgPtr.parentGraphCallSequence[parentGraph]--

        bgPtr.graphParentsRecursively(reportingElement, parentGraph)

        switch typedReportingElement := reportingElement.(type) </span>{
        case Reference:<span class="cov0" title="0">
                indicatedElement := typedReportingElement.getReferencedConceptNoLock()
                if indicatedElement != nil </span><span class="cov0" title="0">{
                        indicatedElementID := makeGraphID(indicatedElement.getConceptIDNoLock(), bgPtr.parentGraphNodePrefix[parentGraph])
                        bgPtr.nodeElementLabels[indicatedElementID] = indicatedElement.getLabelNoLock()
                        bgPtr.nodeElementTypes[indicatedElementID] = reflect.TypeOf(indicatedElement).String()
                        bgPtr.makeNode(indicatedElement.getConceptIDNoLock(), GetConceptTypeString(indicatedElement), notification.GetChangedConceptLabel(), parentGraph, false, "")
                        bgPtr.makeIndicatedElementEdge(reportingElementNodeID, indicatedElementID)
                        bgPtr.graphParentsRecursively(indicatedElement, parentGraph)
                }</span>
        case Refinement:<span class="cov0" title="0">
                abstractConcept := typedReportingElement.getAbstractConceptNoLock()
                if abstractConcept != nil </span><span class="cov0" title="0">{
                        abstractConceptID := makeGraphID(abstractConcept.getConceptIDNoLock(), bgPtr.parentGraphNodePrefix[parentGraph])
                        bgPtr.nodeElementLabels[abstractConceptID] = abstractConcept.getLabelNoLock()
                        bgPtr.nodeElementTypes[abstractConceptID] = reflect.TypeOf(abstractConcept).String()
                        bgPtr.makeNode(abstractConcept.getConceptIDNoLock(), GetConceptTypeString(abstractConcept), notification.GetChangedConceptLabel(), parentGraph, false, "")
                        bgPtr.makeAbstractConceptEdge(reportingElementNodeID, abstractConceptID)
                        bgPtr.graphParentsRecursively(abstractConcept, parentGraph)
                }</span>
                <span class="cov0" title="0">refinedConcept := typedReportingElement.getAbstractConceptNoLock()
                if refinedConcept != nil </span><span class="cov0" title="0">{
                        refinedConceptID := makeGraphID(refinedConcept.getConceptIDNoLock(), bgPtr.parentGraphNodePrefix[parentGraph])
                        bgPtr.nodeElementLabels[refinedConceptID] = refinedConcept.getLabelNoLock()
                        bgPtr.nodeElementTypes[refinedConceptID] = reflect.TypeOf(refinedConcept).String()
                        bgPtr.makeNode(refinedConcept.getConceptIDNoLock(), GetConceptTypeString(refinedConcept), notification.GetChangedConceptLabel(), parentGraph, false, "")
                        bgPtr.makeRefinedConceptEdge(reportingElementNodeID, refinedConceptID)
                        bgPtr.graphParentsRecursively(refinedConcept, parentGraph)
                }</span>
        }

        <span class="cov8" title="1">if notification.underlyingChange != nil </span><span class="cov0" title="0">{
                underlyingNotificationID := bgPtr.addNotification(notification.underlyingChange, parentGraph)
                bgPtr.makeNotificationEdge(underlyingNotificationID, reportingElementNodeID)
        }</span>
        <span class="cov8" title="1">return reportingElementNodeID</span>
}

// func (bgPtr *baseGraph) getRootNodeID(parentGraph string) string {
//         return bgPtr.rootNodeIDs[parentGraph]
// }

func (bgPtr *baseGraph) graphParentsRecursively(child Element, parentGraph string) <span class="cov8" title="1">{
        if child == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">parent := child.getOwningConceptNoLock()
        if parent != nil </span><span class="cov0" title="0">{
                childObjectID := makeGraphID(child.getConceptIDNoLock(), bgPtr.parentGraphNodePrefix[parentGraph])
                parentGraphID := makeGraphID(parent.getConceptIDNoLock(), bgPtr.parentGraphNodePrefix[parentGraph])
                bgPtr.nodeElementLabels[parentGraphID] = parent.getLabelNoLock()
                bgPtr.nodeElementTypes[parentGraphID] = reflect.TypeOf(parent).String()
                bgPtr.makeNode(parent.getConceptIDNoLock(), GetConceptTypeString(parent), parent.getLabelNoLock(), parentGraph, false, "")
                bgPtr.makeOwnerEdge(parentGraphID, childObjectID)
                bgPtr.graphParentsRecursively(parent, parentGraph)
        }</span>
}

// GetGraph returns the grqaphviz.Graph
func (bgPtr *baseGraph) GetGraph() *gographviz.Graph <span class="cov8" title="1">{
        return bgPtr.graph
}</span>

func makeGraphID(conceptID string, prefix string) string <span class="cov8" title="1">{
        var graphID = prefix + "\"" + conceptID + "\""
        return graphID
}</span>

func (bgPtr *baseGraph) makeAbstractConceptEdge(sourceID string, targetID string) <span class="cov0" title="0">{
        abstractEdgeAttrs := make(map[string]string)
        abstractEdgeAttrs["arrowhead"] = "invempty"
        abstractEdgeAttrs["arrowtail"] = "none"
        abstractEdgeAttrs["dir"] = "both"
        err := bgPtr.graph.AddEdge(sourceID, targetID, true, abstractEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in BaseGraph.makeAbstractConceptEdge")
                log.Print(err.Error())
        }</span>
}
func (bgPtr *baseGraph) makeRefinedConceptEdge(sourceID string, targetID string) <span class="cov0" title="0">{
        refinedEdgeAttrs := make(map[string]string)
        refinedEdgeAttrs["arrowhead"] = "none"
        refinedEdgeAttrs["arrowtail"] = "inv"
        refinedEdgeAttrs["dir"] = "both"
        err := bgPtr.graph.AddEdge(sourceID, targetID, true, refinedEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in BaseGraph.makeRefinedConceptEdge")
                log.Print(err.Error())
        }</span>
}
func (bgPtr *baseGraph) makeIndicatedElementEdge(sourceID string, targetID string) <span class="cov0" title="0">{
        referenceEdgeAttrs := make(map[string]string)
        referenceEdgeAttrs["arrowhead"] = "normal"
        referenceEdgeAttrs["arrowtail"] = "none"
        referenceEdgeAttrs["dir"] = "both"
        err := bgPtr.graph.AddEdge(sourceID, targetID, true, referenceEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in BaseGraph.makeIndicatedElementEdge")
                log.Print(err.Error())
        }</span>
}

func (bgPtr *baseGraph) makeNotificationEdge(sourceID string, targetID string) <span class="cov0" title="0">{
        notificationEdgeAttrs := make(map[string]string)
        notificationEdgeAttrs["arrowhead"] = "open"
        notificationEdgeAttrs["arrowtail"] = "none"
        notificationEdgeAttrs["dir"] = "both"
        err := bgPtr.graph.AddEdge(sourceID, targetID, true, notificationEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in BaseGraph.makeNotificationEdge")
                log.Print(err.Error())
        }</span>
}

func (bgPtr *baseGraph) makeNode(conceptID string, typeString string, label string, parentGraph string, root bool, functionName string) string <span class="cov8" title="1">{
        if conceptID == "" || typeString == "" </span><span class="cov0" title="0">{
                log.Print("baseGraph.makeNode called will empty strings")
        }</span>
        <span class="cov8" title="1">id := makeGraphID(conceptID, bgPtr.parentGraphNodePrefix[parentGraph])
        if !bgPtr.graph.IsNode(id) </span><span class="cov8" title="1">{
                nodeAttrs := make(map[string]string)
                if root </span><span class="cov8" title="1">{
                        nodeAttrs["shape"] = "none"
                        nodeAttrs["fillcolor"] = "yellow"
                }</span> else<span class="cov0" title="0"> {
                        nodeAttrs["shape"] = "none"
                }</span>
                // typeString := reflect.TypeOf(el).String()
                <span class="cov8" title="1">if root </span><span class="cov8" title="1">{
                        // nodeAttrs["label"] = "&lt;&lt;TABLE HEIGHT='0' WIDTH='0'&gt;&lt;TR&gt;&lt;TD&gt;" + functionName + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + typeString + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + label + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + id + "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;"
                        nodeAttrs["label"] = "&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt; functionName &lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + typeString + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + id + "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;"
                }</span> else<span class="cov0" title="0"> {
                        nodeAttrs["label"] = "&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt;" + typeString + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + label + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + id + "&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&gt;"
                }</span>
                <span class="cov8" title="1">err := bgPtr.graph.AddNode(parentGraph, id, nodeAttrs)
                if err != nil </span><span class="cov0" title="0">{
                        log.Print("Error in BaseGraph.makeNode")
                        log.Print(err.Error())
                }</span>
                <span class="cov8" title="1">bgPtr.nodeToGraphName[id] = parentGraph</span>
        }
        <span class="cov8" title="1">return id</span>
}

func (bgPtr *baseGraph) makeLabel(graphID string, parentGraph string, functionID string) string <span class="cov8" title="1">{
        elLabel := bgPtr.nodeElementLabels[graphID]
        elType := bgPtr.nodeElementTypes[graphID]
        var label string
        if functionID == "" </span><span class="cov0" title="0">{
                label = "&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt;" + elType + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + elLabel + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + graphID + "&lt;/TD&gt;&lt;/TR&gt;" + bgPtr.callAnnotation[graphID] + "&lt;/TABLE&gt;&gt;"
        }</span> else<span class="cov8" title="1"> {
                label = "&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD BGCOLOR='yellow'&gt;" + functionID + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + elType + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + elLabel + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + graphID + "&lt;/TD&gt;&lt;/TR&gt;" + bgPtr.callAnnotation[graphID] + "&lt;/TABLE&gt;&gt;"
        }</span>
        <span class="cov8" title="1">return label</span>
}

func (bgPtr *baseGraph) makeOwnerEdge(parentID string, childID string) <span class="cov0" title="0">{
        ownerEdgeAttrs := make(map[string]string)
        ownerEdgeAttrs["arrowhead"] = "none"
        ownerEdgeAttrs["arrowtail"] = "diamond"
        ownerEdgeAttrs["dir"] = "both"
        err := bgPtr.graph.AddEdge(parentID, childID, true, ownerEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in BaseGraph.makeOwnerEdge")
                log.Print(err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can el found in the LICENSE file.

package core

import (
        "encoding/json"
        "log"
        "reflect"
        "strconv"

        "github.com/pkg/errors"
)

// NatureOfChange indicates the type of base element change:
type NatureOfChange int

// ConceptChanged indicates that an attribute of the concept that is NOT an element reference has changed
// OwningConceptChanged indicates that the ownership of the concept has changed
// ReferencedConceptChanged indicates that a different Element is being referenced
// AbstractConceptChanged indicates that a different Element is now the abstract concept
// RefinedConceptChanged indicates that a different Element is now the refined concept
const (
        ConceptAdded             = NatureOfChange(1)
        ConceptChanged           = NatureOfChange(2)
        ConceptRemoved           = NatureOfChange(3)
        OwningConceptChanged     = NatureOfChange(4)
        ReferencedConceptChanged = NatureOfChange(5)
        AbstractConceptChanged   = NatureOfChange(6)
        RefinedConceptChanged    = NatureOfChange(7)
        OwnedConceptChanged      = NatureOfChange(8)
        IndicatedConceptChanged  = NatureOfChange(9)
)

func (noc NatureOfChange) String() string <span class="cov8" title="1">{
        switch noc </span>{
        case ConceptAdded:<span class="cov0" title="0">
                return "ConceptAdded"</span>
        case ConceptChanged:<span class="cov8" title="1">
                return "ConceptChanged"</span>
        case ConceptRemoved:<span class="cov0" title="0">
                return "ConceptRemoved"</span>
        case OwningConceptChanged:<span class="cov0" title="0">
                return "OwningConceptChanged"</span>
        case ReferencedConceptChanged:<span class="cov0" title="0">
                return "ReferencedConceptChanged"</span>
        case AbstractConceptChanged:<span class="cov0" title="0">
                return "AbstractConceptChanged"</span>
        case RefinedConceptChanged:<span class="cov0" title="0">
                return "RefinedConceptChanged"</span>
        case OwnedConceptChanged:<span class="cov0" title="0">
                return "OwnedConceptChanged"</span>
        case IndicatedConceptChanged:<span class="cov0" title="0">
                return "IndicatedConceptChanged"</span>
        }
        <span class="cov0" title="0">return "Undefined"</span>
}

// ConceptState is a flattened representation of all concept types. It is used to capture the current state of a concept
type ConceptState struct {
        // Element fields
        ConceptID       string
        ConceptType     string
        OwningConceptID string
        Label           string
        Definition      string
        URI             string
        Version         string
        IsCore          string
        ReadOnly        string
        // Literal fields
        LiteralValue string
        // Reference fields
        ReferencedConceptID      string
        ReferencedAttributeName  string
        ReferencedConceptVersion string
        // Refinement Fields
        AbstractConceptID      string
        AbstractConceptVersion string
        RefinedConceptID       string
        RefinedConceptVersion  string
}

// NewConceptState copies the state of an Element into a ConceptState struct
func NewConceptState(el Element) (*ConceptState, error) <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return nil, errors.New("NewConceptState called with nil element")
        }</span>
        <span class="cov8" title="1">mJSON, err := el.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "NewConceptState failed")
        }</span>
        <span class="cov8" title="1">var newConceptState ConceptState
        err = json.Unmarshal([]byte(mJSON), &amp;newConceptState)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "NewConceptState failed")
        }</span>
        <span class="cov8" title="1">newConceptState.ConceptType = reflect.TypeOf(el).String()
        return &amp;newConceptState, nil</span>
}

// ChangeNotification records the data and metadata regarding a change to a Element. It provides
// the nature of the change, the old and new values, and the reporting Element.
// It also provides the underlying change that triggered this one (if any)
type ChangeNotification struct {
        natureOfChange        NatureOfChange
        reportingElementState *ConceptState
        beforeConceptState    *ConceptState
        afterConceptState     *ConceptState
        underlyingChange      *ChangeNotification
        uOfD                  *UniverseOfDiscourse
}

// GetAfterConceptState returns the state of the Element after the change
func (cnPtr *ChangeNotification) GetAfterConceptState() *ConceptState <span class="cov8" title="1">{
        return cnPtr.afterConceptState
}</span>

// GetBeforeConceptState returns the state of the Element before the change
func (cnPtr *ChangeNotification) GetBeforeConceptState() *ConceptState <span class="cov8" title="1">{
        return cnPtr.beforeConceptState
}</span>

// GetChangedConceptID returns the ID of the Element impacted by the change
func (cnPtr *ChangeNotification) GetChangedConceptID() string <span class="cov8" title="1">{
        if cnPtr.afterConceptState != nil </span><span class="cov8" title="1">{
                return cnPtr.afterConceptState.ConceptID
        }</span> else<span class="cov8" title="1"> if cnPtr.beforeConceptState != nil </span><span class="cov0" title="0">{
                return cnPtr.beforeConceptState.ConceptID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetChangedConceptLabel returns the label of the Element impacted by the change
func (cnPtr *ChangeNotification) GetChangedConceptLabel() string <span class="cov0" title="0">{
        if cnPtr.afterConceptState != nil </span><span class="cov0" title="0">{
                return cnPtr.afterConceptState.Label
        }</span> else<span class="cov0" title="0"> if cnPtr.beforeConceptState != nil </span><span class="cov0" title="0">{
                return cnPtr.beforeConceptState.Label
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetChangedConceptType returns the typeString of the Element impacted by the change
func (cnPtr *ChangeNotification) GetChangedConceptType() string <span class="cov0" title="0">{
        if cnPtr.afterConceptState != nil </span><span class="cov0" title="0">{
                return cnPtr.afterConceptState.ConceptType
        }</span> else<span class="cov0" title="0"> if cnPtr.beforeConceptState != nil </span><span class="cov0" title="0">{
                return cnPtr.beforeConceptState.ConceptType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetDepth returns the depth of the nested notifications within the current notification
func (cnPtr *ChangeNotification) GetDepth() int <span class="cov0" title="0">{
        return cnPtr.getDepth(0)
}</span>

func (cnPtr *ChangeNotification) getDepth(currentDepth int) int <span class="cov0" title="0">{
        newDepth := currentDepth + 1
        if cnPtr.underlyingChange != nil </span><span class="cov0" title="0">{
                return cnPtr.underlyingChange.getDepth(newDepth)
        }</span>
        <span class="cov0" title="0">return newDepth</span>
}

// GetNatureOfChange returns the NatureOFChange
func (cnPtr *ChangeNotification) GetNatureOfChange() NatureOfChange <span class="cov8" title="1">{
        return cnPtr.natureOfChange
}</span>

// GetReportingElementID returns the ID of the element sending the notification
func (cnPtr *ChangeNotification) GetReportingElementID() string <span class="cov8" title="1">{
        return cnPtr.reportingElementState.ConceptID
}</span>

// GetReportingElementLabel returns the Label of the element sending the notification
func (cnPtr *ChangeNotification) GetReportingElementLabel() string <span class="cov8" title="1">{
        return cnPtr.reportingElementState.Label
}</span>

// GetReportingElementState returns the State of the element sending the notification
// If this is nil, the report is coming from the uOfD
func (cnPtr *ChangeNotification) GetReportingElementState() *ConceptState <span class="cov8" title="1">{
        return cnPtr.reportingElementState
}</span>

// GetReportingElementType returns the Type of the element sending the notification
func (cnPtr *ChangeNotification) GetReportingElementType() string <span class="cov8" title="1">{
        return cnPtr.reportingElementState.ConceptType
}</span>

// GetUnderlyingChange returns the change notification that triggered the change being
// reported in this ChangeNotification
func (cnPtr *ChangeNotification) GetUnderlyingChange() *ChangeNotification <span class="cov8" title="1">{
        return cnPtr.underlyingChange
}</span>

func (cnPtr *ChangeNotification) IsReferenced(el Element) bool <span class="cov8" title="1">{
        elID := el.getConceptIDNoLock()
        if cnPtr.GetChangedConceptID() == elID || cnPtr.GetReportingElementID() == elID </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if cnPtr.underlyingChange != nil </span><span class="cov8" title="1">{
                return cnPtr.underlyingChange.IsReferenced(el)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Print prints the change notification for diagnostic purposes to the log
func (cnPtr *ChangeNotification) Print(prefix string, hl *Transaction) <span class="cov8" title="1">{
        if EnableNotificationPrint </span><span class="cov0" title="0">{
                startCount := 0
                cnPtr.printRecursively(prefix, hl, startCount)
        }</span>
}

// printRecursively prints the change notification for diagnostic purposes to the log. The startCount
// indicates the depth of nesting of the print so that the printout can be indented appropriately.
func (cnPtr *ChangeNotification) printRecursively(prefix string, hl *Transaction, startCount int) <span class="cov0" title="0">{
        notificationType := "+++ " + cnPtr.natureOfChange.String()
        log.Printf("%s%s: \n", prefix, "### Notification Level: "+strconv.Itoa(startCount)+" Type: "+notificationType)
        if cnPtr.reportingElementState != nil </span><span class="cov0" title="0">{
                log.Printf(prefix+"  ReportingElementState: %+v", cnPtr.reportingElementState)
        }</span>
        <span class="cov0" title="0">if cnPtr.afterConceptState != nil </span><span class="cov0" title="0">{
                log.Printf(prefix+"  AfterState: %+v", cnPtr.afterConceptState)
        }</span>
        <span class="cov0" title="0">if cnPtr.beforeConceptState != nil </span><span class="cov0" title="0">{
                log.Printf(prefix+"  BeforeState: %s", cnPtr.beforeConceptState)
        }</span>
        <span class="cov0" title="0">if cnPtr.underlyingChange != nil </span><span class="cov0" title="0">{
                cnPtr.underlyingChange.printRecursively(prefix+"      ", hl, startCount-1)
        }</span>
        <span class="cov0" title="0">log.Printf(prefix + "End of notification")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

//        "time"

// Copyright 2017, 2018 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// CorePrefix is a string that prefixes all URIs for the core concepts
var CorePrefix = "http://activeCrl.com/core/"

// CoreDomainURI is the URI for the core concept space
var CoreDomainURI = CorePrefix + "CoreDomain"

// ElementURI is the URI for the Element core concept
var ElementURI = CorePrefix + "Element"

// LiteralURI is the URI for the Literal core concept
var LiteralURI = CorePrefix + "Literal"

// ReferenceURI is the URI for the Reference core concept
var ReferenceURI = CorePrefix + "Reference"

// RefinementURI is the URI for the Refinement core concept
var RefinementURI = CorePrefix + "Refinement"

// UniverseOfDiscourseURI is the URI for the UniverseOfDiscourse core concept
var UniverseOfDiscourseURI = CorePrefix + "UniverseOfDiscourse"

// AdHocTrace is a global variable used in troubleshooting. Generally debugging logic is wrapped in a
// conditional expression contingent on the value of this variable
var AdHocTrace = false

// initCore is the core initialization, but it is made explicit so that it can be called for testing purposes
func init() <span class="cov8" title="1">{
        TraceChange = false
        notificationsLimit = 0
        // notificationsCount = 0
}</span>

func buildCoreDomain(uOfD *UniverseOfDiscourse, hl *Transaction) Element <span class="cov8" title="1">{
        coreElement, _ := uOfD.NewElement(hl, CoreDomainURI)
        coreElementID := coreElement.getConceptIDNoLock()
        coreElement.SetLabel("CoreDomain", hl)

        // Element
        element, _ := uOfD.NewElement(hl, ElementURI)
        element.SetOwningConceptID(coreElementID, hl)
        element.SetLabel("Element", hl)

        // Literal
        literal, _ := uOfD.NewLiteral(hl, LiteralURI)
        literal.SetOwningConceptID(coreElementID, hl)
        literal.SetLabel("Literal", hl)

        // Reference
        reference, _ := uOfD.NewReference(hl, ReferenceURI)
        reference.SetOwningConceptID(coreElementID, hl)
        reference.SetLabel("Reference", hl)

        // Refinement
        refinement, _ := uOfD.NewRefinement(hl, RefinementURI)
        refinement.SetOwningConceptID(coreElementID, hl)
        refinement.SetLabel("Refinement", hl)

        coreElement.SetIsCoreRecursively(hl)
        return coreElement
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "os"
        "reflect"

        "github.com/awalterschulze/gographviz"
        "github.com/pkg/errors"
)

// CrlGraph is a graphviz representation of a specified set of CRL data structures.
// At present, Refinements cannot be the referencedConcept of a Reference.
type CrlGraph struct {
        gvgraph *gographviz.Graph
}

// NewCrlGraph returns an initialized CrlGraph
func NewCrlGraph(graphName string) *CrlGraph <span class="cov8" title="1">{
        graph := &amp;CrlGraph{}
        graph.gvgraph = gographviz.NewGraph()
        graph.gvgraph.SetDir(true)
        graph.gvgraph.SetStrict(true)
        graph.gvgraph.SetName(graphName)
        return graph
}</span>

// AddConceptRecursively will add the given concept and all its child descendants to the graph.
// it will also add any referenced concepts, but not recursively. Existing concepts will not be duplicated.
func (graphPtr *CrlGraph) AddConceptRecursively(concept Element, hl *Transaction) error <span class="cov8" title="1">{
        err := graphPtr.addConcept(concept, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.AddConceptRecursively failed")
        }</span>
        <span class="cov8" title="1">ownedConcepts := concept.GetOwnedConcepts(hl)
        for _, el := range ownedConcepts </span><span class="cov8" title="1">{
                switch typedEl := el.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        ref := typedEl
                        abstractConcept := ref.GetAbstractConcept(hl)
                        refinedConcept := ref.GetRefinedConcept(hl)
                        if abstractConcept != nil &amp;&amp; refinedConcept != nil </span><span class="cov8" title="1">{
                                abstractConceptID := abstractConcept.GetConceptID(hl)
                                if !graphPtr.gvgraph.IsNode(abstractConceptID) </span><span class="cov8" title="1">{
                                        err := graphPtr.addConcept(abstractConcept, hl)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                                        }</span>
                                }
                                <span class="cov8" title="1">refinedConceptID := refinedConcept.GetConceptID(hl)
                                if !graphPtr.gvgraph.IsNode(refinedConceptID) </span><span class="cov8" title="1">{
                                        err := graphPtr.addConcept(refinedConcept, hl)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                                        }</span>
                                }
                                <span class="cov8" title="1">err := graphPtr.addRefinementEdge(abstractConcept, refinedConcept, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlGraph.addConcept failed")
                                }</span>
                        }
                case Element, Literal, Reference:<span class="cov8" title="1">
                        err := graphPtr.AddConceptRecursively(el, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlGraph.AddConceptRecursively failed")
                        }</span>
                        <span class="cov8" title="1">err = graphPtr.addOwnerEdge(concept, el, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlGraph.AddConceptRecursively failed")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (graphPtr *CrlGraph) addConcept(concept Element, hl *Transaction) error <span class="cov8" title="1">{
        switch typedConcept := concept.(type) </span>{
        case Refinement:<span class="cov0" title="0">
                abstractConcept := typedConcept.GetAbstractConcept(hl)
                refinedConcept := typedConcept.GetRefinedConcept(hl)
                if abstractConcept != nil &amp;&amp; refinedConcept != nil </span><span class="cov0" title="0">{
                        abstractConceptID := abstractConcept.GetConceptID(hl)
                        if !graphPtr.gvgraph.IsNode(abstractConceptID) </span><span class="cov0" title="0">{
                                err := graphPtr.addConcept(abstractConcept, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlGraph.addConcept failed")
                                }</span>
                        }
                        <span class="cov0" title="0">refinedConceptID := refinedConcept.GetConceptID(hl)
                        if !graphPtr.gvgraph.IsNode(refinedConceptID) </span><span class="cov0" title="0">{
                                err := graphPtr.addConcept(refinedConcept, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlGraph.addConcept failed")
                                }</span>
                        }
                        <span class="cov0" title="0">err := graphPtr.addRefinementEdge(abstractConcept, refinedConcept, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                        }</span>
                }
        case Element, Literal, Reference:<span class="cov8" title="1">
                id := "\"" + concept.GetConceptID(hl) + "\""
                label := concept.GetLabel(hl)
                typeName := reflect.TypeOf(concept).String()
                if !graphPtr.gvgraph.IsNode(id) </span><span class="cov8" title="1">{
                        nodeAttrs := make(map[string]string)
                        nodeAttrs["shape"] = "none"
                        referencedAttributeNameExt := ""
                        switch possibleReference := typedConcept.(type) </span>{
                        case Reference:<span class="cov8" title="1">
                                referencedAttributeNameExt = "&lt;TR&gt;&lt;TD&gt;" + possibleReference.GetReferencedAttributeName(hl).String() + "&lt;/TD&gt;&lt;/TR&gt;"</span>
                        }
                        <span class="cov8" title="1">nodeAttrs["label"] = "&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt;" + typeName + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + label + "&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;" + id + "&lt;/TD&gt;&lt;/TR&gt;" + referencedAttributeNameExt + " &lt;/TABLE&gt;&gt;"
                        err := graphPtr.gvgraph.AddNode("", id, nodeAttrs)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                        }</span>
                        // Make sure the owner is displayed
                        <span class="cov8" title="1">owner := concept.GetOwningConcept(hl)
                        if owner != nil </span><span class="cov8" title="1">{
                                ownerID := owner.GetConceptID(hl)
                                if !graphPtr.gvgraph.IsNode(ownerID) </span><span class="cov8" title="1">{
                                        err := graphPtr.addConcept(owner, hl)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                                        }</span>
                                        <span class="cov8" title="1">err = graphPtr.addOwnerEdge(owner, concept, hl)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">switch typedConcept := concept.(type) </span>{
                        case Reference:<span class="cov8" title="1">
                                referencedConceptID := typedConcept.GetReferencedConceptID(hl)
                                if referencedConceptID != "" </span><span class="cov8" title="1">{
                                        referencedConcept := typedConcept.GetReferencedConcept(hl)
                                        if !graphPtr.gvgraph.IsNode(referencedConceptID) </span><span class="cov8" title="1">{
                                                err := graphPtr.addConcept(referencedConcept, hl)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return errors.Wrap(err, "CrlGraph.addConcept failed")
                                                }</span>
                                        }
                                        <span class="cov8" title="1">err := graphPtr.addReferencedElementEdge(typedConcept, referencedConcept, hl)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "CrlGraph.addConcept failed")
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (graphPtr *CrlGraph) addOwnerEdge(parent Element, child Element, hl *Transaction) error <span class="cov8" title="1">{
        parentID := "\"" + parent.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(parentID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addOwnerEdge called with parent node not present")
        }</span>
        <span class="cov8" title="1">childID := "\"" + child.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(childID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addOwnerEdge called with child node not present")
        }</span>
        <span class="cov8" title="1">ownerEdgeAttrs := make(map[string]string)
        ownerEdgeAttrs["arrowhead"] = "none"
        ownerEdgeAttrs["arrowtail"] = "diamond"
        ownerEdgeAttrs["dir"] = "both"
        // ownerEdgeAttrs["weight"] = "100"
        err := graphPtr.gvgraph.AddEdge(parentID, childID, true, ownerEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.addOwnerEdge failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (graphPtr *CrlGraph) addReferencedElementEdge(reference Element, referencedElement Element, hl *Transaction) error <span class="cov8" title="1">{
        referenceID := "\"" + reference.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(referenceID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addReferencedElementEdge called with reference node not present")
        }</span>
        <span class="cov8" title="1">referencedElementID := "\"" + referencedElement.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(referencedElementID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addReferencedElementEdge called with referencedElement node not present")
        }</span>
        <span class="cov8" title="1">refEdgeAttrs := make(map[string]string)
        refEdgeAttrs["arrowhead"] = "open"
        refEdgeAttrs["arrowtail"] = "none"
        refEdgeAttrs["dir"] = "both"
        // refEdgeAttrs["weight"] = "10"
        refEdgeAttrs["constraint"] = "false"
        refEdgeAttrs["color"] = "red"
        err := graphPtr.gvgraph.AddEdge(referenceID, referencedElementID, true, refEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.addReferencedElementEdge failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (graphPtr *CrlGraph) addRefinementEdge(abstractConcept Element, refinedConcept Element, hl *Transaction) error <span class="cov8" title="1">{
        abstractConceptID := "\"" + abstractConcept.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(abstractConceptID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addRefinementEdge called with abstractConcept node not present")
        }</span>
        <span class="cov8" title="1">refinedConceptID := "\"" + refinedConcept.GetConceptID(hl) + "\""
        if !graphPtr.gvgraph.IsNode(refinedConceptID) </span><span class="cov0" title="0">{
                return errors.New("CrlGraph.addRefinementEdge called with refinedConcept node not present")
        }</span>
        <span class="cov8" title="1">refEdgeAttrs := make(map[string]string)
        refEdgeAttrs["arrowhead"] = "none"
        refEdgeAttrs["arrowtail"] = "onormal"
        refEdgeAttrs["dir"] = "both"
        // refEdgeAttrs["weight"] = "1"
        refEdgeAttrs["constraint"] = "false"
        refEdgeAttrs["color"] = "turquoise"
        err := graphPtr.gvgraph.AddEdge(abstractConceptID, refinedConceptID, true, refEdgeAttrs)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.addRefinementEdge failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ExportDOT writes a file containing the DOT representation of the graph
func (graphPtr *CrlGraph) ExportDOT(pathname string, filename string) error <span class="cov8" title="1">{
        file, err := graphPtr.newFile(pathname, filename)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.ExportDOT failed")
        }</span>
        <span class="cov8" title="1">graphString := graphPtr.gvgraph.String()
        graphBytes := []byte(graphString)
        _, err2 := file.Write(graphBytes)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.ExportDOT failed")
        }</span>
        <span class="cov8" title="1">err = file.Close()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlGraph.ExportDOT failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// newFile creates a file with the name being the ConceptID of the supplied Element and returns the workspaceFile struct
func (graphPtr *CrlGraph) newFile(path string, filename string) (*os.File, error) <span class="cov8" title="1">{
        fullPath := path + "/" + filename + ".dot"
        file, err := os.OpenFile(fullPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "CrlGraph.newFile failed")
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "reflect"
        "strconv"
        "sync"

        "github.com/pkg/errors"

        mapset "github.com/deckarep/golang-set"
)

// element is the root representation of a concept
type element struct {
        sync.RWMutex
        ConceptID       string
        Definition      string
        Label           string
        IsCore          bool
        OwningConceptID string
        ReadOnly        bool
        Version         *versionCounter
        uOfD            *UniverseOfDiscourse
        URI             string
        observers       mapset.Set
}

// addOwnedConcept adds the indicated Element as a child (owned) concept.
// This is purely an internal housekeeping method. Note that
// no checking of whether the Element is read-only is performed here. This check
// is performed by the child
func (ePtr *element) addOwnedConcept(ownedConceptID string, hl *Transaction) <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if !ePtr.uOfD.ownedIDsMap.ContainsMappedValue(ePtr.ConceptID, ownedConceptID) </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                ePtr.incrementVersion(hl)
                ePtr.uOfD.ownedIDsMap.AddMappedValue(ePtr.GetConceptID(hl), ownedConceptID)
        }</span>
}

// addRecoveredOwnedConcept adds the indicated Element as a child (owned) concept without incrementing
// the version.
// This is purely an internal housekeeping method. Note that
// no checking of whether the Element is read-only is performed here. This check
// is performed by the child
func (ePtr *element) addRecoveredOwnedConcept(ownedConceptID string, hl *Transaction) <span class="cov0" title="0">{
        hl.ReadLockElement(ePtr)
        if !ePtr.uOfD.ownedIDsMap.ContainsMappedValue(ePtr.ConceptID, ownedConceptID) </span><span class="cov0" title="0">{
                ePtr.uOfD.preChange(ePtr, hl)
                ePtr.uOfD.ownedIDsMap.AddMappedValue(ePtr.ConceptID, ownedConceptID)
        }</span>
}

// addListener adds the indicated Element as a listening concept.
// This is an internal housekeeping method.
func (ePtr *element) addListener(listeningConceptID string, hl *Transaction) <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if !ePtr.uOfD.listenersMap.ContainsMappedValue(ePtr.ConceptID, listeningConceptID) </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                ePtr.uOfD.listenersMap.AddMappedValue(ePtr.ConceptID, listeningConceptID)
        }</span>
}

// clone is an internal function that makes a copy of the given element - including its
// identifier. This is done only to support undo/redo: the clone should NEVER be added to the
// universe of discourse
func (ePtr *element) clone(hl *Transaction) *element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        // The newly made clone never gets locked
        var cl element
        cl.initializeElement("", "")
        cl.cloneAttributes(ePtr, hl)
        return &amp;cl
}</span>

// cloneAttributes is a supporting function for clone
func (ePtr *element) cloneAttributes(source *element, hl *Transaction) <span class="cov8" title="1">{
        ePtr.ConceptID = source.ConceptID
        ePtr.Definition = source.Definition
        ePtr.Label = source.Label
        ePtr.IsCore = source.IsCore
        ePtr.OwningConceptID = source.OwningConceptID
        ePtr.ReadOnly = source.ReadOnly
        ePtr.Version.counter = source.Version.counter
        ePtr.uOfD = source.uOfD
        ePtr.URI = source.URI
}</span>

// // editableError checks to see if the element cannot be edited because it
// // is either a core element or has been marked readOnly.
// func (ePtr *element) editableError(hl *HeldLocks) error {
//         if ePtr.GetIsCore(hl) {
//                 return errors.New("Element.SetOwningConceptID called on core Element")
//         }
//         if ePtr.ReadOnly {
//                 return errors.New("Element.SetOwningConcept called on read-only Element")
//         }
//         return nil
// }

// GetConceptID returns the conceptID
func (ePtr *element) GetConceptID(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.ConceptID
}</span>

// getConceptIDNoLock returns the conceptID without locking the Element.
// it is intended to support infrastructure functions only. Since the
// conceptID is never edited, this ought to be a safe operation. Even in
// cloning, in which the ConceptID is explicitly set, no other thread is
// even aware of the existence of the clone at the time the ID is set, so this
// ought to be safe.
func (ePtr *element) getConceptIDNoLock() string <span class="cov8" title="1">{
        return ePtr.ConceptID
}</span>

// GetDefinition returns the definition if one exists
func (ePtr *element) GetDefinition(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.Definition
}</span>

// GetFirstOwnedConceptRefinedFrom returns the first child that has the indicated abstraction as
// one of its abstractions. Note that there is no ordering of children so in the event that
// there is more than one child with the given abstraction the result is nondeterministic.
func (ePtr *element) GetFirstOwnedConceptRefinedFrom(abstraction Element, hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                        it.Stop()
                        return element
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFirstOwnedConceptRefinedFromURI returns the first child that has the abstraction indicated
// by the URI as one of its abstractions. Note that there is no ordering of children so in the event that
// there is more than one child with the given abstraction the result is nondeterministic.
func (ePtr *element) GetFirstOwnedConceptRefinedFromURI(abstractionURI string, hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                return ePtr.GetFirstOwnedConceptRefinedFrom(abstraction, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFirstOwnedLiteralRefinementOf returns the first child literal that has the indicated
// abstraction as one of its abstractions.
func (ePtr *element) GetFirstOwnedLiteralRefinementOf(abstraction Element, hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Literal:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFirstOwnedLiteralRefinementOfURI returns the first child literal that has the abstraction indicated
// by the URI as one of its abstractions. Note that there is no ordering of children so in the event that
// there is more than one child with the given abstraction the result is nondeterministic.
func (ePtr *element) GetFirstOwnedLiteralRefinementOfURI(abstractionURI string, hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                return ePtr.GetFirstOwnedLiteralRefinementOf(abstraction, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFirstOwnedReferenceRefinedFrom returns the first child reference that has the indicated
// abstraction as one of its abstractions.
func (ePtr *element) GetFirstOwnedReferenceRefinedFrom(abstraction Element, hl *Transaction) Reference <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        ownedIDs := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID)
        it := ownedIDs.Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Reference:<span class="cov8" title="1">
                        if element.(Reference).IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// GetFirstOwnedReferenceRefinedFromURI returns the first child reference that has the abstraction indicated
// by the URI as one of its abstractions. Note that there is no ordering of children so in the event that
// there is more than one child with the given abstraction the result is nondeterministic.
func (ePtr *element) GetFirstOwnedReferenceRefinedFromURI(abstractionURI string, hl *Transaction) Reference <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        uOfD := ePtr.uOfD
        if uOfD == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">abstraction := uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                return ePtr.GetFirstOwnedReferenceRefinedFrom(abstraction, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFirstOwnedRefinementRefinedFrom returns the first child refinement that has the indicated
// abstraction as one of its abstractions.
func (ePtr *element) GetFirstOwnedRefinementRefinedFrom(abstraction Element, hl *Transaction) Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstOwnedRefinementRefinedFromURI returns the first child refinement that has the abstraction indicated
// by the URI as one of its abstractions. Note that there is no ordering of children so in the event that
// there is more than one child with the given abstraction the result is nondeterministic.
func (ePtr *element) GetFirstOwnedRefinementRefinedFromURI(abstractionURI string, hl *Transaction) Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                return ePtr.GetFirstOwnedRefinementRefinedFrom(abstraction, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetFirstOwnedConceptWithURI
func (ePtr *element) GetFirstOwnedConceptWithURI(uri string, hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                if element.GetURI(hl) == uri </span><span class="cov8" title="1">{
                        it.Stop()
                        return element
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ePtr *element) GetFirstOwnedLiteralRefinedFrom(abstraction Element, hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Literal:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ePtr *element) GetFirstOwnedLiteralRefinedFromURI(uri string, hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        abstraction := ePtr.uOfD.GetElementWithURI(uri)
        if abstraction != nil </span><span class="cov8" title="1">{
                return ePtr.GetFirstOwnedLiteralRefinedFrom(abstraction, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ePtr *element) GetFirstOwnedLiteralWithURI(uri string, hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case *literal:<span class="cov8" title="1">
                        if element.GetURI(hl) == uri </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ePtr *element) GetFirstOwnedReferenceWithURI(uri string, hl *Transaction) Reference <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case *reference:<span class="cov8" title="1">
                        if element.GetURI(hl) == uri </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ePtr *element) GetFirstOwnedRefinementWithURI(uri string, hl *Transaction) Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case *refinement:<span class="cov8" title="1">
                        if element.GetURI(hl) == uri </span><span class="cov8" title="1">{
                                it.Stop()
                                return typedElement
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Deregister removes the registration of an Observer
func (ePtr *element) Deregister(observer Observer) error <span class="cov0" title="0">{
        ePtr.observers.Remove(observer)
        return nil
}</span>

// FindAbstractions adds all found abstractions to supplied map
func (ePtr *element) FindAbstractions(abstractions map[string]Element, hl *Transaction) <span class="cov8" title="1">{
        it := ePtr.uOfD.listenersMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                listener := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := listener.(type) </span>{
                case *refinement:<span class="cov8" title="1">
                        abstraction := typedElement.GetAbstractConcept(hl)
                        if abstraction != nil &amp;&amp; abstraction.getConceptIDNoLock() != ePtr.getConceptIDNoLock() </span><span class="cov8" title="1">{
                                abstractions[abstraction.GetConceptID(hl)] = abstraction
                                abstraction.FindAbstractions(abstractions, hl)
                        }</span>
                }
        }
}

// FindImmediateAbstractions adds all immediate abstractions to supplied map
func (ePtr *element) FindImmediateAbstractions(abstractions map[string]Element, hl *Transaction) <span class="cov8" title="1">{
        // There are no abstractions without the uOfD context
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">it := ePtr.uOfD.listenersMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                listener := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := listener.(type) </span>{
                case *refinement:<span class="cov8" title="1">
                        abstraction := typedElement.GetAbstractConcept(hl)
                        if abstraction != nil &amp;&amp; abstraction.getConceptIDNoLock() != ePtr.getConceptIDNoLock() </span><span class="cov8" title="1">{
                                abstractions[abstraction.GetConceptID(hl)] = abstraction
                        }</span>
                }
        }
}

// GetIsCore returns true if the element is one of the core elements of CRL. The purpose of this
// function is to prevent SetReadOnly(true) on concepts that are built-in to CRL. Locking is
// not necessary as this value is set when the object is created and never expected to change
func (ePtr *element) GetIsCore(hl *Transaction) bool <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.IsCore
}</span>

// GetGetLabel returns the label if one exists
func (ePtr *element) GetLabel(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.Label
}</span>

func (ePtr *element) getLabelNoLock() string <span class="cov8" title="1">{
        return ePtr.Label
}</span>

// GetOwningConceptID returns the ID of the concept that owns this one (if any)
func (ePtr *element) GetOwningConceptID(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.OwningConceptID
}</span>

// GetOwnedConceptIDs returns the set of IDs owned by this concept. Note that if this Element is not
// presently in a uOfD it returns the empty set
func (ePtr *element) GetOwnedConceptIDs(hl *Transaction) mapset.Set <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return mapset.NewSet()
        }</span>
        <span class="cov8" title="1">return ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID)</span>
}

// GetOwnedConcepts returns the element's owned concepts if
func (ePtr *element) GetOwnedConcepts(hl *Transaction) map[string]Element <span class="cov8" title="1">{
        ownedConcepts := make(map[string]Element)
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return ownedConcepts
        }</span>
        <span class="cov8" title="1">it := ePtr.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                if element != nil </span><span class="cov8" title="1">{
                        ownedConcepts[id.(string)] = element
                }</span>
        }
        <span class="cov8" title="1">return ownedConcepts</span>
}

// GetOwnedConceptsRefinedFrom returns the owned concepts with the indicated abstraction as
// one of their abstractions.
func (ePtr *element) GetOwnedConceptsRefinedFrom(abstraction Element, hl *Transaction) map[string]Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Element{}
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                        matches[element.GetConceptID(hl)] = element
                }</span>
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedConceptsRefinedFromURI returns the owned concepts that have the abstraction indicated
// by the URI as one of their abstractions.
func (ePtr *element) GetOwnedConceptsRefinedFromURI(abstractionURI string, hl *Transaction) map[string]Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Element{}
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = element
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedDescendantsRefinedFrom returns the owned concepts with the indicated abstraction as
// one of their abstractions.
func (ePtr *element) GetOwnedDescendantsRefinedFrom(abstraction Element, hl *Transaction) map[string]Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Element{}
        if abstraction != nil </span><span class="cov8" title="1">{
                // it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                descendantIDs := mapset.NewSet()
                ePtr.uOfD.GetConceptsOwnedConceptIDsRecursively(ePtr.ConceptID, descendantIDs, hl)
                it := descendantIDs.Iterator()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = element
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedDescendantsRefinedFromURI returns the descendant concepts that have the indicated abstraction
// by the URI as one of their abstractions.
func (ePtr *element) GetOwnedDescendantsRefinedFromURI(abstractionURI string, hl *Transaction) map[string]Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Element{}
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                // it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                descendantIDs := mapset.NewSet()
                ePtr.uOfD.GetConceptsOwnedConceptIDsRecursively(ePtr.ConceptID, descendantIDs, hl)
                it := descendantIDs.Iterator()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = element
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedLiteralsRefinedFrom returns the owned literals that have the indicated
// abstraction as one of their abstractions.
func (ePtr *element) GetOwnedLiteralsRefinedFrom(abstraction Element, hl *Transaction) map[string]Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Literal{}
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Literal:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = typedElement
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedLiteralsRefinedFromURI returns the child literals that have the abstraction indicated
// by the URI as one of their abstractions.
func (ePtr *element) GetOwnedLiteralsRefinedFromURI(abstractionURI string, hl *Transaction) map[string]Literal <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Literal{}
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        switch typedElement := element.(type) </span>{
                        case Literal:<span class="cov8" title="1">
                                if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                        matches[element.GetConceptID(hl)] = typedElement
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedReferencesRefinedFrom returns the owned references that have the indicated
// abstraction as one of their abstractions.
func (ePtr *element) GetOwnedReferencesRefinedFrom(abstraction Element, hl *Transaction) map[string]Reference <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Reference{}
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Reference:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = typedElement
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedReferencesRefinedFromURI returns the owned references that have the abstraction indicated
// by the URI as one of their abstractions.
func (ePtr *element) GetOwnedReferencesRefinedFromURI(abstractionURI string, hl *Transaction) map[string]Reference <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Reference{}
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                defer it.Stop()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        switch typedElement := element.(type) </span>{
                        case Reference:<span class="cov8" title="1">
                                if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                        matches[element.GetConceptID(hl)] = typedElement
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedRefinementsRefinedFrom returns the owned refinements that have the indicated
// abstraction as one of their abstractions.
func (ePtr *element) GetOwnedRefinementsRefinedFrom(abstraction Element, hl *Transaction) map[string]Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Refinement{}
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        defer it.Stop()
        for id := range it.C </span><span class="cov8" title="1">{
                element := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := element.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                matches[element.GetConceptID(hl)] = typedElement
                        }</span>
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwnedRefinementsRefinedFromURI returns the owned refinements that have the abstraction indicated
// by the URI as one of its abstractions.
func (ePtr *element) GetOwnedRefinementsRefinedFromURI(abstractionURI string, hl *Transaction) map[string]Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        matches := map[string]Refinement{}
        abstraction := ePtr.uOfD.GetElementWithURI(abstractionURI)
        if abstraction != nil </span><span class="cov8" title="1">{
                it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
                defer it.Stop()
                for id := range it.C </span><span class="cov8" title="1">{
                        element := ePtr.uOfD.GetElement(id.(string))
                        switch typedElement := element.(type) </span>{
                        case Refinement:<span class="cov8" title="1">
                                if element.IsRefinementOf(abstraction, hl) </span><span class="cov8" title="1">{
                                        matches[element.GetConceptID(hl)] = typedElement
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return matches</span>
}

// GetOwningConcept returns the Element representing the concept that owns this one (if any)
func (ePtr *element) GetOwningConcept(hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if ePtr.uOfD != nil </span><span class="cov8" title="1">{
                return ePtr.uOfD.GetElement(ePtr.OwningConceptID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getOwningConceptNoLock returns the Element representing the concept that owns this one (if any)
func (ePtr *element) getOwningConceptNoLock() Element <span class="cov8" title="1">{
        if ePtr.uOfD != nil </span><span class="cov8" title="1">{
                return ePtr.uOfD.GetElement(ePtr.OwningConceptID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetUniverseOfDiscourse returns the UniverseOfDiscourse in which the element instance resides
func (ePtr *element) GetUniverseOfDiscourse(hl *Transaction) *UniverseOfDiscourse <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.uOfD
}</span>

// getUniverseOfDiscourseNoLock returns the UniverseOfDiscourse in which the element instance resides
func (ePtr *element) getUniverseOfDiscourseNoLock() *UniverseOfDiscourse <span class="cov0" title="0">{
        return ePtr.uOfD
}</span>

// GetURI returns the URI string associated with the element if there is one
func (ePtr *element) GetURI(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.URI
}</span>

// GetVersion returns the version of the element
func (ePtr *element) GetVersion(hl *Transaction) int <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.Version.getVersion()
}</span>

// IsRefinementOf returns true if the given abstraction is contained in the abstractions set
// of this element. No locking is required since the StringIntMap does its own locking
func (ePtr *element) IsRefinementOf(abstraction Element, hl *Transaction) bool <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        // Get the actual element so that we can get the correct type
        fullElement := hl.uOfD.GetElement(ePtr.ConceptID)
        // Check to see whether the abstraction is one of the core classes
        abstractionURI := abstraction.GetURI(hl)
        switch abstractionURI </span>{
        case ElementURI:<span class="cov8" title="1">
                return true</span>
        case LiteralURI:<span class="cov8" title="1">
                switch fullElement.(type) </span>{
                case Literal:<span class="cov8" title="1">
                        return true</span>
                }
        case ReferenceURI:<span class="cov8" title="1">
                switch fullElement.(type) </span>{
                case Reference:<span class="cov8" title="1">
                        return true</span>
                }
        case RefinementURI:<span class="cov8" title="1">
                switch fullElement.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        return true</span>
                }
        }
        <span class="cov8" title="1">it := hl.uOfD.listenersMap.GetMappedValues(ePtr.ConceptID).Iterator()
        defer it.Stop()
        for id := range it.C </span><span class="cov8" title="1">{
                listener := ePtr.uOfD.GetElement(id.(string))
                switch typedElement := listener.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        foundAbstraction := typedElement.GetAbstractConcept(hl)
                        if foundAbstraction == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if foundAbstraction.getConceptIDNoLock() == ePtr.ConceptID </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if foundAbstraction == abstraction </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">if foundAbstraction != nil </span><span class="cov8" title="1">{
                                foundRecursively := foundAbstraction.IsRefinementOf(abstraction, hl)
                                if foundRecursively </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (ePtr *element) IsRefinementOfURI(uri string, hl *Transaction) bool <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">abstraction := ePtr.uOfD.GetElementWithURI(uri)
        if abstraction == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return ePtr.IsRefinementOf(abstraction, hl)</span>
}

func (ePtr *element) incrementVersion(hl *Transaction) <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if ePtr.uOfD != nil </span><span class="cov8" title="1">{
                // UofD may be nil during the deletion of this element
                ePtr.uOfD.preChange(ePtr, hl)
                ePtr.Version.incrementVersion()
                if ePtr.OwningConceptID != "" </span><span class="cov8" title="1">{
                        owningConcept := ePtr.uOfD.GetElement(ePtr.OwningConceptID)
                        // the owning concept may also be in the process of deletion
                        if owningConcept != nil </span><span class="cov8" title="1">{
                                owningConcept.incrementVersion(hl)
                        }</span>
                }
        }
}

// initializeElement creates the identifier (using the uri if supplied) and
// creates the abstractions, ownedConcepts, and referrencingConcpsts maps.
// Note that initialization is not considered a change, so the version counter is not incremented
// nor are monitors of this element notified of changes.
func (ePtr *element) initializeElement(identifier string, uri string) <span class="cov8" title="1">{
        ePtr.ConceptID = identifier
        ePtr.Version = newVersionCounter()
        ePtr.URI = uri
        ePtr.observers = mapset.NewSet()
}</span>

// IsReadOnly returns a boolean indicating whether the concept can be modified.
func (ePtr *element) IsReadOnly(hl *Transaction) bool <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        return ePtr.ReadOnly
}</span>

// isEditable checks to see if the element cannot be edited because it
// is either a core element or has been marked readOnly.
func (ePtr *element) isEditable(hl *Transaction) bool <span class="cov8" title="1">{
        if ePtr.GetIsCore(hl) || ePtr.IsReadOnly(hl) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// isEquivalent only checks the element attributes. It ignores the uOfD.
func (ePtr *element) isEquivalent(hl1 *Transaction, el *element, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">hl1.ReadLockElement(ePtr)
        hl2.ReadLockElement(el)
        if ePtr.ConceptID != el.ConceptID </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, ConceptIDs do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.Definition != el.Definition </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, Definitions do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.IsCore != el.IsCore </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, IsCore do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.Label != el.Label </span><span class="cov8" title="1">{
                if print </span><span class="cov8" title="1">{
                        log.Printf("In element.isEquivalent, Labels do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.OwningConceptID != el.OwningConceptID </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, OwningConceptIDs do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.ReadOnly != el.ReadOnly </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, ReadOnly does not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.Version.getVersion() != el.Version.getVersion() </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, Versions do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if ePtr.URI != el.URI </span><span class="cov0" title="0">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In element.isEquivalent, URIs do not match")
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsOwnedConcept returns true if the supplied element is an owned concept. Note that
// there is an interval of time during editing in which the child's owner will be set but the child
// has not yet been added to the element's OwnedConcepts list. Similarly, there is an interval of time
// during editing during which the child's owner has been changed but the original owner's OwnedConcept
// list has not yet been updated.
func (ePtr *element) IsOwnedConcept(el Element, hl *Transaction) bool <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        defer it.Stop()
        for id := range it.C </span><span class="cov8" title="1">{
                child := ePtr.uOfD.GetElement(id.(string))
                if el.GetConceptID(hl) == child.GetConceptID(hl) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// MarshalJSON produces a byte string JSON representation of the Element
func (ePtr *element) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        buffer := bytes.NewBufferString("{")
        typeName := reflect.TypeOf(ePtr).String()
        buffer.WriteString(fmt.Sprintf("\"Type\":\"%s\",", typeName))
        err := ePtr.marshalElementFields(buffer)
        buffer.WriteString("}")
        return buffer.Bytes(), err
}</span>

func (ePtr *element) marshalElementFields(buffer *bytes.Buffer) error <span class="cov8" title="1">{
        buffer.WriteString(fmt.Sprintf("\"ConceptID\":\"%s\",", ePtr.ConceptID))
        buffer.WriteString(fmt.Sprintf("\"OwningConceptID\":\"%s\",", ePtr.OwningConceptID))
        buffer.WriteString(fmt.Sprintf("\"Label\":\"%s\",", ePtr.Label))
        buffer.WriteString(fmt.Sprintf("\"Definition\":\"%s\",", ePtr.Definition))
        buffer.WriteString(fmt.Sprintf("\"URI\":\"%s\",", ePtr.URI))
        buffer.WriteString(fmt.Sprintf("\"Version\":\"%d\",", ePtr.Version.getVersion()))
        buffer.WriteString(fmt.Sprintf("\"IsCore\":\"%t\",", ePtr.IsCore))
        buffer.WriteString(fmt.Sprintf("\"ReadOnly\":\"%t\"", ePtr.ReadOnly))
        return nil
}</span>

// notifyObservers passes the notification to all registered Observers
func (ePtr *element) notifyObservers(notification *ChangeNotification, hl *Transaction) error <span class="cov8" title="1">{
        // it := ePtr.observers.Iterator()
        // defer it.Stop()
        for _, observer := range ePtr.observers.ToSlice() </span><span class="cov8" title="1">{
                err := observer.(Observer).Update(notification, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.notifyObservers failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ePtr *element) notifyPointerOwners(notification *ChangeNotification, hl *Transaction) error <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if ePtr.uOfD != nil </span><span class="cov8" title="1">{
                indicatedConceptChangeNotification, err := ePtr.uOfD.NewForwardingChangeNotification(ePtr, IndicatedConceptChanged, notification, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.notifyPointerOwners failed")
                }</span>
                <span class="cov8" title="1">it := ePtr.uOfD.listenersMap.GetMappedValues(ePtr.ConceptID).Iterator()
                for id := range it.C </span><span class="cov8" title="1">{
                        listener := ePtr.uOfD.GetElement(id.(string))
                        if listener != nil </span><span class="cov8" title="1">{
                                err = ePtr.uOfD.callAssociatedFunctions(listener, indicatedConceptChangeNotification, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        it.Stop()
                                        return errors.Wrap(err, "element.notifyPointerOwners failed")
                                }</span>
                                <span class="cov8" title="1">err = listener.notifyOwner(indicatedConceptChangeNotification, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        it.Stop()
                                        return errors.Wrap(err, "element.notifyPointerOwners failed")
                                }</span>
                                <span class="cov8" title="1">err = listener.notifyObservers(indicatedConceptChangeNotification, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        it.Stop()
                                        return errors.Wrap(err, "element.notifyPointerOwners failed")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// notifyOwner informs the owner that the concept has changed state
func (ePtr *element) notifyOwner(stateChangeNotification *ChangeNotification, trans *Transaction) error <span class="cov8" title="1">{
        trans.ReadLockElement(ePtr)
        switch stateChangeNotification.natureOfChange </span>{
        case OwningConceptChanged:<span class="cov8" title="1">
                oldOwnerId := stateChangeNotification.beforeConceptState.OwningConceptID
                newOwnerId := stateChangeNotification.afterConceptState.OwningConceptID
                if oldOwnerId != "" </span><span class="cov8" title="1">{
                        oldOwner := ePtr.uOfD.GetElement(oldOwnerId)
                        if oldOwner != nil </span><span class="cov8" title="1">{
                                ownedConceptChangeNotification, err := ePtr.uOfD.NewForwardingChangeNotification(oldOwner, OwnedConceptChanged, stateChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                                <span class="cov8" title="1">err = ePtr.uOfD.callAssociatedFunctions(oldOwner, ownedConceptChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                                <span class="cov8" title="1">err = oldOwner.notifyObservers(ownedConceptChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                        }
                }
                <span class="cov8" title="1">if newOwnerId != "" </span><span class="cov8" title="1">{
                        newOwner := ePtr.uOfD.GetElement(newOwnerId)
                        if newOwner != nil </span><span class="cov8" title="1">{
                                ownedConceptChangeNotification, err := ePtr.uOfD.NewForwardingChangeNotification(newOwner, OwnedConceptChanged, stateChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                                <span class="cov8" title="1">err = ePtr.uOfD.callAssociatedFunctions(newOwner, ownedConceptChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                                <span class="cov8" title="1">err = newOwner.notifyObservers(ownedConceptChangeNotification, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "element.notifyOwner failed")
                                }</span>
                        }
                }
        case ConceptChanged, ReferencedConceptChanged, AbstractConceptChanged, RefinedConceptChanged, IndicatedConceptChanged:<span class="cov8" title="1">
                owner := ePtr.GetOwningConcept(trans)
                if owner != nil </span><span class="cov8" title="1">{
                        ownedConceptChangeNotification, err := ePtr.uOfD.NewForwardingChangeNotification(owner, OwnedConceptChanged, stateChangeNotification, trans)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "element.notifyOwner failed")
                        }</span>
                        <span class="cov8" title="1">err = ePtr.uOfD.callAssociatedFunctions(owner, ownedConceptChangeNotification, trans)
                        if err != nil </span><span class="cov8" title="1">{
                                return errors.Wrap(err, "element.notifyOwner failed")
                        }</span>
                        <span class="cov8" title="1">err = owner.notifyObservers(ownedConceptChangeNotification, trans)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "element.notifyOwner failed")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// propagateChange() distributes the change notification to relevant parties
func (ePtr *element) propagateChange(stateChangeNotification *ChangeNotification, trans *Transaction) error <span class="cov8" title="1">{
        var err error = nil
        switch stateChangeNotification.natureOfChange </span>{
        case ConceptChanged, OwningConceptChanged, ReferencedConceptChanged, AbstractConceptChanged, RefinedConceptChanged:<span class="cov8" title="1">
                err = stateChangeNotification.uOfD.callAssociatedFunctions(ePtr, stateChangeNotification, trans)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.notifyPointerOwners(stateChangeNotification, trans)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.notifyOwner(stateChangeNotification, trans)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.notifyObservers(stateChangeNotification, trans)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
                <span class="cov8" title="1">ePtr.uOfD.NotifyUofDObservers(stateChangeNotification, trans)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
        case ConceptAdded, ConceptRemoved:<span class="cov0" title="0">
                ePtr.uOfD.NotifyUofDObservers(stateChangeNotification, trans)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.propagateChange failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// recoverElementFields() is used when de-serializing an element. The activities in restoring the
// element are not considered changes so the version counter is not incremented and the monitors of this
// element are not notified of chaanges.
func (ePtr *element) recoverElementFields(unmarshaledData *map[string]json.RawMessage, hl *Transaction) error <span class="cov8" title="1">{
        // ConceptID
        var recoveredConceptID string
        err := json.Unmarshal((*unmarshaledData)["ConceptID"], &amp;recoveredConceptID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.ConceptID as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.ConceptID = recoveredConceptID
        // Definition
        var recoveredDefinition string
        err = json.Unmarshal((*unmarshaledData)["Definition"], &amp;recoveredDefinition)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.Definition as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.Definition = recoveredDefinition
        // Label
        var recoveredLabel string
        err = json.Unmarshal((*unmarshaledData)["Label"], &amp;recoveredLabel)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.Label as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.Label = recoveredLabel
        // IsCore
        var recoveredIsCore string
        err = json.Unmarshal((*unmarshaledData)["IsCore"], &amp;recoveredIsCore)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.IsCore as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.IsCore, err = strconv.ParseBool(recoveredIsCore)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of IsCOre from string to bool failed")
                return err
        }</span>
        // OwningConceptID
        <span class="cov8" title="1">var recoveredOwningConceptID string
        err = json.Unmarshal((*unmarshaledData)["OwningConceptID"], &amp;recoveredOwningConceptID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.OwningConceptID as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.OwningConceptID = recoveredOwningConceptID
        // ReadOnly
        var recoveredReadOnly string
        err = json.Unmarshal((*unmarshaledData)["ReadOnly"], &amp;recoveredReadOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.ReadOnly as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.ReadOnly, err = strconv.ParseBool(recoveredReadOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of ReadOnly from string to bool failed")
                return err
        }</span>
        // Version
        <span class="cov8" title="1">var recoveredVersion string
        err = json.Unmarshal((*unmarshaledData)["Version"], &amp;recoveredVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of BaseElement.version failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.Version.counter, err = strconv.Atoi(recoveredVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of Element.version to integer failed\n")
                return err
        }</span>
        // URI
        <span class="cov8" title="1">var recoveredURI string
        err = json.Unmarshal((*unmarshaledData)["URI"], &amp;recoveredURI)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.URI as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">ePtr.URI = recoveredURI
        return nil</span>
}

// removeListener removes the indicated Element as a listening concept.
func (ePtr *element) removeListener(listeningConceptID string, hl *Transaction) <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        ePtr.uOfD.preChange(ePtr, hl)
        ePtr.uOfD.listenersMap.RemoveMappedValue(ePtr.ConceptID, listeningConceptID)
}</span>

// Register adds the registration of an Observer
func (ePtr *element) Register(observer Observer) error <span class="cov8" title="1">{
        ePtr.observers.Add(observer)
        return nil
}</span>

// removeOwnedConcept removes the indicated Element as a child (owned) concept.
func (ePtr *element) removeOwnedConcept(ownedConceptID string, hl *Transaction) error <span class="cov8" title="1">{
        hl.ReadLockElement(ePtr)
        if ePtr.IsReadOnly(hl) </span><span class="cov0" title="0">{
                return errors.New("Element.removedOwnedConcept called on read-only Element")
        }</span>
        <span class="cov8" title="1">ePtr.uOfD.preChange(ePtr, hl)
        ePtr.incrementVersion(hl)
        ePtr.uOfD.ownedIDsMap.RemoveMappedValue(ePtr.ConceptID, ownedConceptID)
        return nil</span>
}

// SetDefinition sets the definition of the Element
func (ePtr *element) SetDefinition(def string, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetDefinition failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if !ePtr.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("element.SetDefinition failed because the element is not editable")
        }</span>
        <span class="cov8" title="1">if ePtr.Definition != def </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetDefinition failed")
                }</span>
                <span class="cov8" title="1">ePtr.incrementVersion(hl)
                ePtr.Definition = def
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetDefinition failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendConceptChangeNotification(ePtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetDefinition failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetIsCore sets the flag indicating that the element is a Core concept and cannot be edited. Once set, this flag cannot be cleared.
func (ePtr *element) SetIsCore(hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetIsCore failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if !ePtr.IsCore </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetIsCore failed")
                }</span>
                <span class="cov8" title="1">ePtr.incrementVersion(hl)
                ePtr.IsCore = true
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetIsCore failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendConceptChangeNotification(ePtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetIsCore failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetIsCoreRecursively recursively sets the flag indicating that the element is a Core concept and cannot be edited. Once set, this flag cannot be cleared.
func (ePtr *element) SetIsCoreRecursively(hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetIsCoreRecursively failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        err := ePtr.SetIsCore(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Element.SetIsCoreRecursively failed")
        }</span>
        <span class="cov8" title="1">it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                el := ePtr.uOfD.GetElement(id.(string))
                err = el.SetIsCoreRecursively(hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.Wrap(err, "Element.SetIsCoreRecursively failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetLabel sets the label of the Element
func (ePtr *element) SetLabel(label string, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetLabel failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if !ePtr.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("element.SetLabel failed because the element is not editable")
        }</span>
        <span class="cov8" title="1">if ePtr.Label != label </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetLabel failed")
                }</span>
                <span class="cov8" title="1">ePtr.incrementVersion(hl)
                ePtr.Label = label
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetLabel failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendConceptChangeNotification(ePtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetLabel failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetOwningConcept takes the ID of the supplied concept and call SetOwningConceptID. It first checks to
// determine whether the new owner is editable and will throw an error if it is not
func (ePtr *element) SetOwningConcept(el Element, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetOwningConcept failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        id := ""
        if el != nil </span><span class="cov8" title="1">{
                if !el.isEditable(hl) </span><span class="cov0" title="0">{
                        return errors.New("element.SetOwningConcept called with an owner that is not editable")
                }</span>
                <span class="cov8" title="1">id = el.getConceptIDNoLock()</span>
        }
        <span class="cov8" title="1">err := ePtr.SetOwningConceptID(id, hl)
        if err != nil </span><span class="cov0" title="0">{
                errors.Wrap(err, "element.SetOwningConcept failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetOwningConceptID sets the ID of the owning concept for the element
// Design Note: the argument is the identifier rather than the Element to ensure
// the correct type of the owning concept is recorded.
func (ePtr *element) SetOwningConceptID(ocID string, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetOwningConceptID failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if !ePtr.isEditable(hl) </span><span class="cov8" title="1">{
                return errors.New("element.SetOwningConceptID failed because the element is not editable")
        }</span>
        <span class="cov8" title="1">if ocID == ePtr.ConceptID </span><span class="cov0" title="0">{
                return errors.New("element.SetOwningConceptID called with itself as owner")
        }</span>
        <span class="cov8" title="1">newOwner := ePtr.uOfD.GetElement(ocID)
        if newOwner != nil &amp;&amp; !newOwner.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("element.SetOwningConceptID called with new owner not editable")
        }</span>
        <span class="cov8" title="1">oldOwner := ePtr.GetOwningConcept(hl)
        if oldOwner != nil &amp;&amp; !oldOwner.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("element.SetOwningConceptID called with old owner not editable")
        }</span>
        // Do nothing if there is no change
        <span class="cov8" title="1">if ePtr.OwningConceptID != ocID </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetOwningConceptID failed")
                }</span>
                <span class="cov8" title="1">if oldOwner != nil </span><span class="cov8" title="1">{
                        oldOwner.removeOwnedConcept(ePtr.ConceptID, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "element.SetOwningConceptID failed")
                        }</span>
                }
                <span class="cov8" title="1">ePtr.incrementVersion(hl)
                if newOwner != nil </span><span class="cov8" title="1">{
                        newOwner.addOwnedConcept(ePtr.ConceptID, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "element.SetOwningConceptID failed")
                        }</span>
                }
                <span class="cov8" title="1">ePtr.OwningConceptID = ocID
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetOwningConceptID failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendPointerChangeNotification(ePtr, OwningConceptChanged, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetOwningConceptID failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetReadOnly provides a mechanism for preventing modifications to concepts. It will throw an error
// if the concept is one of the CRL core concepts, as these can never be made writable. It will also
// throw an error if its owner is read only and this call tries to set read only false.
func (ePtr *element) SetReadOnly(value bool, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetReadOnly failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if ePtr.GetIsCore(hl) </span><span class="cov8" title="1">{
                return errors.New("element.SetReadOnly failed because element is a core element")
        }</span>
        <span class="cov8" title="1">if ePtr.GetOwningConcept(hl) != nil </span><span class="cov8" title="1">{
                if ePtr.GetOwningConcept(hl).IsReadOnly(hl) &amp;&amp; !value </span><span class="cov8" title="1">{
                        return errors.New("element.SetReadOnly failed because the owner is read only")
                }</span>
        }
        <span class="cov8" title="1">if ePtr.ReadOnly != value </span><span class="cov8" title="1">{
                ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetReadOnly failed")
                }</span>
                <span class="cov8" title="1">ePtr.incrementVersion(hl)
                ePtr.ReadOnly = value
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetDeSetReadOnlyfinition failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendConceptChangeNotification(ePtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetDeSetReadOnlyfinition failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ePtr *element) SetReadOnlyRecursively(value bool, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetReadOnlyRecursively failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">err := ePtr.SetReadOnly(value, hl)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "Element.SetReadOnlyRecursively failed")
        }</span>
        <span class="cov8" title="1">it := ePtr.uOfD.ownedIDsMap.GetMappedValues(ePtr.ConceptID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                el := ePtr.uOfD.GetElement(id.(string))
                err = el.SetReadOnlyRecursively(value, hl)
                if err != nil </span><span class="cov8" title="1">{
                        it.Stop()
                        return errors.Wrap(err, "Element.SetReadOnlyRecursively failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// setUniverseOfDiscourse is intended to be called only by the UniverseOfDiscourse
func (ePtr *element) setUniverseOfDiscourse(uOfD *UniverseOfDiscourse, hl *Transaction) <span class="cov8" title="1">{
        hl.WriteLockElement(ePtr)
        ePtr.uOfD = uOfD
}</span>

// SetURI sets the URI of the Element
func (ePtr *element) SetURI(uri string, hl *Transaction) error <span class="cov8" title="1">{
        if ePtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("element.SetURI failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(ePtr)
        if !ePtr.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("element.SetURI failed because the elementis not editable")
        }</span>
        <span class="cov8" title="1">if ePtr.URI != uri </span><span class="cov8" title="1">{
                foundElement := ePtr.uOfD.GetElementWithURI(uri)
                if foundElement != nil &amp;&amp; foundElement.GetConceptID(hl) != ePtr.ConceptID </span><span class="cov0" title="0">{
                        return errors.New("Element already exists with URI " + uri)
                }</span>
                <span class="cov8" title="1">ePtr.uOfD.preChange(ePtr, hl)
                beforeState, err := NewConceptState(ePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetURI failed")
                }</span>
                <span class="cov8" title="1">ePtr.uOfD.changeURIForElement(ePtr, ePtr.URI, uri)
                ePtr.incrementVersion(hl)
                ePtr.URI = uri
                afterState, err2 := NewConceptState(ePtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "element.SetURI failed")
                }</span>
                <span class="cov8" title="1">err = ePtr.uOfD.SendConceptChangeNotification(ePtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "element.SetURI failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ePtr *element) TraceableReadLock(hl *Transaction) <span class="cov8" title="1">{
        if TraceLocks </span><span class="cov0" title="0">{
                log.Printf("HL %p about to read lock Element %p %s\n", hl, ePtr, ePtr.Label)
        }</span>
        <span class="cov8" title="1">ePtr.RLock()</span>
}

func (ePtr *element) TraceableWriteLock(hl *Transaction) <span class="cov8" title="1">{
        if TraceLocks </span><span class="cov0" title="0">{
                log.Printf("HL %p about to write lock Element %p %s\n", hl, ePtr, ePtr.Label)
        }</span>
        <span class="cov8" title="1">ePtr.Lock()</span>
}

func (ePtr *element) TraceableReadUnlock(hl *Transaction) <span class="cov8" title="1">{
        if TraceLocks </span><span class="cov0" title="0">{
                log.Printf("HL %p about to read unlock Element %p %s\n", hl, ePtr, ePtr.Label)
        }</span>
        <span class="cov8" title="1">ePtr.RUnlock()</span>
}

func (ePtr *element) TraceableWriteUnlock(hl *Transaction) <span class="cov8" title="1">{
        if TraceLocks </span><span class="cov0" title="0">{
                log.Printf("HL %p about to write unlock Element %p %s\n", hl, ePtr, ePtr.Label)
        }</span>
        <span class="cov8" title="1">ePtr.Unlock()</span>
}

// Element is the representation of a concept
type Element interface {
        Subject
        addListener(string, *Transaction)
        addOwnedConcept(string, *Transaction)
        addRecoveredOwnedConcept(string, *Transaction)
        // editableError(*HeldLocks) error
        FindAbstractions(map[string]Element, *Transaction)
        FindImmediateAbstractions(map[string]Element, *Transaction)
        GetConceptID(*Transaction) string
        getConceptIDNoLock() string
        GetDefinition(*Transaction) string
        GetFirstOwnedConceptRefinedFrom(Element, *Transaction) Element
        GetFirstOwnedConceptRefinedFromURI(string, *Transaction) Element
        GetFirstOwnedLiteralRefinementOf(Element, *Transaction) Literal
        GetFirstOwnedLiteralRefinementOfURI(string, *Transaction) Literal
        GetFirstOwnedReferenceRefinedFrom(Element, *Transaction) Reference
        GetFirstOwnedReferenceRefinedFromURI(string, *Transaction) Reference
        GetFirstOwnedRefinementRefinedFrom(Element, *Transaction) Refinement
        GetFirstOwnedRefinementRefinedFromURI(string, *Transaction) Refinement
        GetFirstOwnedConceptWithURI(string, *Transaction) Element
        GetFirstOwnedLiteralRefinedFrom(Element, *Transaction) Literal
        GetFirstOwnedLiteralRefinedFromURI(string, *Transaction) Literal
        GetFirstOwnedLiteralWithURI(string, *Transaction) Literal
        GetFirstOwnedReferenceWithURI(string, *Transaction) Reference
        GetFirstOwnedRefinementWithURI(string, *Transaction) Refinement
        GetIsCore(*Transaction) bool
        GetLabel(*Transaction) string
        getLabelNoLock() string
        // getListeners(*HeldLocks) (mapset.Set, error)
        // GetOwnedConcepts(*HeldLocks) mapset.Set
        // GetOwnedConceptsRecursively(mapset.Set, *HeldLocks)
        GetOwnedConcepts(hl *Transaction) map[string]Element
        GetOwnedConceptIDs(hl *Transaction) mapset.Set
        GetOwnedConceptsRefinedFrom(Element, *Transaction) map[string]Element
        GetOwnedConceptsRefinedFromURI(string, *Transaction) map[string]Element
        GetOwnedDescendantsRefinedFrom(Element, *Transaction) map[string]Element
        GetOwnedDescendantsRefinedFromURI(string, *Transaction) map[string]Element
        GetOwnedLiteralsRefinedFrom(Element, *Transaction) map[string]Literal
        GetOwnedLiteralsRefinedFromURI(string, *Transaction) map[string]Literal
        GetOwnedReferencesRefinedFrom(Element, *Transaction) map[string]Reference
        GetOwnedReferencesRefinedFromURI(string, *Transaction) map[string]Reference
        GetOwnedRefinementsRefinedFrom(Element, *Transaction) map[string]Refinement
        GetOwnedRefinementsRefinedFromURI(string, *Transaction) map[string]Refinement
        GetOwningConceptID(*Transaction) string
        GetOwningConcept(*Transaction) Element
        getOwningConceptNoLock() Element
        GetUniverseOfDiscourse(*Transaction) *UniverseOfDiscourse
        getUniverseOfDiscourseNoLock() *UniverseOfDiscourse
        GetURI(*Transaction) string
        GetVersion(*Transaction) int
        isEditable(*Transaction) bool
        IsRefinementOf(Element, *Transaction) bool
        IsRefinementOfURI(string, *Transaction) bool
        incrementVersion(*Transaction)
        IsOwnedConcept(Element, *Transaction) bool
        IsReadOnly(*Transaction) bool
        MarshalJSON() ([]byte, error)
        notifyPointerOwners(*ChangeNotification, *Transaction) error
        notifyOwner(*ChangeNotification, *Transaction) error
        propagateChange(*ChangeNotification, *Transaction) error
        removeListener(string, *Transaction)
        removeOwnedConcept(string, *Transaction) error
        SetDefinition(string, *Transaction) error
        SetIsCore(*Transaction) error
        SetIsCoreRecursively(*Transaction) error
        SetLabel(string, *Transaction) error
        SetOwningConcept(Element, *Transaction) error
        SetOwningConceptID(string, *Transaction) error
        SetReadOnly(bool, *Transaction) error
        SetReadOnlyRecursively(bool, *Transaction) error
        setUniverseOfDiscourse(*UniverseOfDiscourse, *Transaction)
        SetURI(string, *Transaction) error
        TraceableReadLock(*Transaction)
        TraceableWriteLock(*Transaction)
        TraceableReadUnlock(*Transaction)
        TraceableWriteUnlock(*Transaction)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2017, 2018 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import (
        "github.com/pkg/errors"
)

// The crlExecutionFunction is the standard signature of a function that gets called when an element (including
// its children) experience a change. Its arguments are the element that changed, the array of ChangeNotifications, and
// a pointer to a WaitGroup that is used to determine (on a larger scale) when the execution of the triggered functions
// has completed.
type crlExecutionFunction func(Element, *ChangeNotification, *Transaction) error

type functionCallRecord struct {
        function     crlExecutionFunction
        functionID   string
        target       Element
        notification *ChangeNotification
}

func newFunctionCallRecord(functionID string, function crlExecutionFunction, target Element, notification *ChangeNotification) (*functionCallRecord, error) <span class="cov0" title="0">{
        if target == nil </span><span class="cov0" title="0">{
                return nil, errors.New("FunctionCallManager.go newPendingFunctionCall invoked with nil target")
        }</span>
        <span class="cov0" title="0">var functionCall functionCallRecord
        functionCall.function = function
        functionCall.functionID = functionID
        functionCall.target = target
        functionCall.notification = notification
        return &amp;functionCall, nil</span>
}

// The functions type maps core Element identifiers to the array of crlExecutionFunctions associated with the identfier.
type functions map[string][]crlExecutionFunction

// isDiagramRelatedFunction returns true if the functionID matches one of the diagram related functions
func isDiagramRelatedFunction(functionID string) bool <span class="cov0" title="0">{
        if functionID == "http://activeCrl.com/corediagram/CoreDiagram/CrlDiagram" ||
                functionID == "http://activeCrl.com/corediagram/CoreDiagram/CrlDiagramElement" ||
                functionID == "http://activeCrl.com/corediagram/CoreDiagram/OwnerPointer" ||
                functionID == "http://activeCrl.com/crlEditor/EditorDomain/DiagramViewMonitor" ||
                functionID == "http://activeCrl.com/crlEditor/EditorDomain/TreeViews/TreeNodeManager" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package core

import (
        "log"
        "reflect"
)

// FunctionCallGraph is a graphical representation of the function calls made when HeldLocks.ReleaseLocks is called
type FunctionCallGraph struct {
        baseGraph
        functionName     string
        executingElement Element
}

// NewFunctionCallGraph creates a function call graph for the indicated function, executing element, and notifications
func NewFunctionCallGraph(functionID string, executingElement Element, notification *ChangeNotification, hl *Transaction) *FunctionCallGraph <span class="cov8" title="1">{
        var fcGraph FunctionCallGraph
        graphName := "FunctionCallGraph"
        fcGraph.initializeBaseGraph(graphName)
        fcGraph.parentGraphNodePrefix[graphName] = ""
        fcGraph.functionName = functionID
        fcGraph.executingElement = executingElement
        executingElementID := executingElement.getConceptIDNoLock()
        executingElementType := reflect.TypeOf(executingElement).String()
        executingElementLabel := executingElement.getLabelNoLock()
        executingElementNodeID := fcGraph.makeNode(executingElementID, GetConceptTypeString(executingElement), executingElement.getLabelNoLock(), graphName, true, functionID)
        fcGraph.nodeElementLabels[executingElementNodeID] = executingElementLabel
        fcGraph.nodeElementLabels[executingElementNodeID] = executingElementType
        fcGraph.graphParentsRecursively(executingElement, "")
        fcGraph.addNotification(notification, graphName)
        err := fcGraph.graph.AddEdge(executingElementNodeID, fcGraph.rootNodeIDs[graphName], true, map[string]string{})
        if err != nil </span><span class="cov0" title="0">{
                log.Print("Error in FunctionCallGraph.NewFunctionCallGraph adding an edge from executing element to the subgraph root node")
                log.Print(err.Error())
        }</span>
        <span class="cov8" title="1">for _, node := range fcGraph.graph.Nodes.Nodes </span><span class="cov8" title="1">{
                if node.Name == executingElementNodeID </span><span class="cov8" title="1">{
                        node.Attrs["label"] = fcGraph.makeLabel(node.Name, fcGraph.nodeToGraphName[node.Name], functionID)
                }</span> else<span class="cov0" title="0"> {
                        node.Attrs["label"] = fcGraph.makeLabel(node.Name, fcGraph.nodeToGraphName[node.Name], "")
                }</span>
        }
        <span class="cov8" title="1">return &amp;fcGraph</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "reflect"

        "github.com/pkg/errors"
)

type literal struct {
        element
        LiteralValue string
}

func (lPtr *literal) clone(hl *Transaction) Literal <span class="cov8" title="1">{
        hl.ReadLockElement(lPtr)
        var clonedLiteral literal
        clonedLiteral.initializeLiteral("", "")
        clonedLiteral.cloneAttributes(lPtr, hl)
        return &amp;clonedLiteral
}</span>

func (lPtr *literal) cloneAttributes(source *literal, hl *Transaction) <span class="cov8" title="1">{
        lPtr.element.cloneAttributes(&amp;source.element, hl)
        lPtr.LiteralValue = source.LiteralValue
        lPtr.element.cloneAttributes(&amp;source.element, hl)
}</span>

func (lPtr *literal) GetLiteralValue(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(lPtr)
        return lPtr.LiteralValue
}</span>

func (lPtr *literal) initializeLiteral(conceptID string, uri string) <span class="cov8" title="1">{
        lPtr.initializeElement(conceptID, uri)
}</span>

func (lPtr *literal) isEquivalent(hl1 *Transaction, ref *literal, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">hl1.ReadLockElement(lPtr)
        hl2.ReadLockElement(ref)
        if ref.LiteralValue != lPtr.LiteralValue </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In literal.isEquivalent, LiteralValues do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return lPtr.element.isEquivalent(hl1, &amp;ref.element, hl2, print)</span>
}

func (lPtr *literal) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        buffer := bytes.NewBufferString("{")
        typeName := reflect.TypeOf(lPtr).String()
        buffer.WriteString(fmt.Sprintf("\"Type\":\"%s\",", typeName))
        err := lPtr.marshalLiteralFields(buffer)
        buffer.WriteString("}")
        return buffer.Bytes(), err
}</span>

func (lPtr *literal) marshalLiteralFields(buffer *bytes.Buffer) error <span class="cov8" title="1">{
        buffer.WriteString(fmt.Sprintf("\"LiteralValue\":\"%s\",", lPtr.LiteralValue))
        lPtr.element.marshalElementFields(buffer)
        return nil
}</span>

// recoverLiteralFields() is used when de-serializing an element. The activities in restoring the
// literal are not considered changes so the version counter is not incremented and the monitors of this
// element are not notified of chaanges.
func (lPtr *literal) recoverLiteralFields(unmarshaledData *map[string]json.RawMessage, hl *Transaction) error <span class="cov8" title="1">{
        err := lPtr.recoverElementFields(unmarshaledData, hl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // LiteralValue
        <span class="cov8" title="1">var recoveredLiteralValue string
        err = json.Unmarshal((*unmarshaledData)["LiteralValue"], &amp;recoveredLiteralValue)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Element.LiteralValue as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">lPtr.LiteralValue = recoveredLiteralValue
        return nil</span>
}

func (lPtr *literal) SetLiteralValue(value string, hl *Transaction) error <span class="cov8" title="1">{
        if lPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("literal.SetLiteralValue failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(lPtr)
        if !lPtr.isEditable(hl) </span><span class="cov8" title="1">{
                return errors.New("literal.SetLiteralValue failed because the literal is not editable")
        }</span>
        <span class="cov8" title="1">if lPtr.LiteralValue != value </span><span class="cov8" title="1">{
                lPtr.uOfD.preChange(lPtr, hl)
                beforeState, err := NewConceptState(lPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "literal.SetLiteralValue failed")
                }</span>
                <span class="cov8" title="1">lPtr.incrementVersion(hl)
                lPtr.LiteralValue = value
                afterState, err2 := NewConceptState(lPtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "literal.SetLiteralValue failed")
                }</span>
                <span class="cov8" title="1">err = lPtr.uOfD.SendConceptChangeNotification(lPtr, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "literal.SetLiteralValue failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Literal is a concept that is, literally, a literal
type Literal interface {
        Element
        GetLiteralValue(*Transaction) string
        SetLiteralValue(string, *Transaction) error
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

// NotificationGraph is a graphviz graphical representation of the structure of a ChangeNotification
type NotificationGraph struct {
        baseGraph
}

// NewNotificationGraph creates a graphviz graph of the information in the ChangeNotification
// The prefix parameter provides the opportunity for the caller to insert a string prefix into the
// node identifier.
func NewNotificationGraph(notification *ChangeNotification, hl *Transaction) *NotificationGraph <span class="cov0" title="0">{
        var nGraph NotificationGraph
        graphName := "NotificationGraph"
        nGraph.initializeBaseGraph(graphName)
        nGraph.addNotification(notification, graphName)
        for _, node := range nGraph.graph.Nodes.Nodes </span><span class="cov0" title="0">{
                node.Attrs["label"] = nGraph.makeLabel(node.Name, nGraph.nodeToGraphName[node.Name], "")
        }</span>
        <span class="cov0" title="0">return &amp;nGraph</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import (
        //        "github.com/satori/go.uuid"

        "sync"

        mapset "github.com/deckarep/golang-set"
)

// OneToNStringMap is a map from a string (a string) to a set of strings. In most usages the string is a UUID
type OneToNStringMap struct {
        sync.Mutex
        oneToNStringMap map[string]mapset.Set
}

// NewOneToNStringMap creates and initializes a stringElementMap
func NewOneToNStringMap() *OneToNStringMap <span class="cov8" title="1">{
        var newMap OneToNStringMap
        newMap.oneToNStringMap = make(map[string]mapset.Set)
        return &amp;newMap
}</span>

// Clear clears the map
func (onMap *OneToNStringMap) Clear() <span class="cov0" title="0">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        onMap.oneToNStringMap = make(map[string]mapset.Set)
}</span>

// CopyMap returns a copy of the map
func (onMap *OneToNStringMap) CopyMap() map[string]mapset.Set <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        copy := make(map[string]mapset.Set)
        for key, childSet := range onMap.oneToNStringMap </span><span class="cov8" title="1">{
                copy[key] = childSet.Clone()
        }</span>
        <span class="cov8" title="1">return copy</span>
}

// DeleteKey removes the map entry for the indicated UUID
func (onMap *OneToNStringMap) DeleteKey(key string) <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        delete(onMap.oneToNStringMap, key)
}</span>

// GetMappedValues returns the set of strings corresponding to the key
func (onMap *OneToNStringMap) GetMappedValues(key string) mapset.Set <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        return onMap.getMappedValuesNoLock(key)
}</span>

// getMappedValuesNoLock returns the Element corresponding to the UUID
func (onMap *OneToNStringMap) getMappedValuesNoLock(key string) mapset.Set <span class="cov8" title="1">{
        if onMap.oneToNStringMap[key] == nil </span><span class="cov8" title="1">{
                onMap.oneToNStringMap[key] = mapset.NewSet()
        }</span>
        <span class="cov8" title="1">return onMap.oneToNStringMap[key].Clone()</span>
}

// IsEquivalent returns true if the map contains the same number of elements
// and each has the same set of keys. No comparison is performed on the elements
// themselves
func (onMap *OneToNStringMap) IsEquivalent(sem *OneToNStringMap) bool <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        sem.TraceableLock()
        defer sem.TraceableUnlock()
        for k := range onMap.oneToNStringMap </span><span class="cov8" title="1">{
                if !sem.getMappedValuesNoLock(k).Equal(onMap.oneToNStringMap[k]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return len(onMap.oneToNStringMap) == len(sem.oneToNStringMap)</span>
}

// AddMappedValue adds the Element UUID as a child of the owner UUID
func (onMap *OneToNStringMap) AddMappedValue(key string, value string) <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        if onMap.oneToNStringMap[key] == nil </span><span class="cov8" title="1">{
                onMap.oneToNStringMap[key] = mapset.NewSet()
        }</span>
        <span class="cov8" title="1">onMap.oneToNStringMap[key].Add(value)</span>
}

// ContainsMappedValue adds the Element UUID as a child of the owner UUID
func (onMap *OneToNStringMap) ContainsMappedValue(key string, value string) bool <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        if onMap.oneToNStringMap[key] == nil </span><span class="cov8" title="1">{
                onMap.oneToNStringMap[key] = mapset.NewSet()
        }</span>
        <span class="cov8" title="1">return onMap.oneToNStringMap[key].Contains(value)</span>
}

// RemoveMappedValue removes the Element UUID as a child of the owner UUID
func (onMap *OneToNStringMap) RemoveMappedValue(key string, value string) <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        if onMap.oneToNStringMap[key] == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">onMap.oneToNStringMap[key].Remove(value)</span>
}

// SetMappedValues sets the mapped values for the given key
func (onMap *OneToNStringMap) SetMappedValues(key string, newValues mapset.Set) <span class="cov8" title="1">{
        onMap.TraceableLock()
        defer onMap.TraceableUnlock()
        if onMap.oneToNStringMap[key] == nil </span><span class="cov8" title="1">{
                onMap.oneToNStringMap[key] = mapset.NewSet()
        }</span>
        <span class="cov8" title="1">selectedMap := onMap.oneToNStringMap[key]
        selectedMap.Clear()
        newValuesIterator := newValues.Iterator()
        for value := range newValuesIterator.C </span><span class="cov8" title="1">{
                selectedMap.Add(value)
        }</span>
}

// TraceableLock locks the map. If TraceLocks is true in logs the acquisition of the lock
func (onMap *OneToNStringMap) TraceableLock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to lock stringElementMap %p\n", onMap)
        // }
        onMap.Lock()
}</span>

// TraceableUnlock unlocks the map. If TraceLocks is true it logs the release of the lock
func (onMap *OneToNStringMap) TraceableUnlock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to unlock stringElementMap %p\n", onMap)
        // }
        onMap.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "reflect"
        "strconv"

        "github.com/pkg/errors"
)

// AttributeName indicates the attribute being referenced (if any):
type AttributeName int

// NoAttribute indicates that no attribute is being referenced
// OwningConceptID     indicates that the OwningConceptID is being referenced
// ReferencedConceptID indicates that the ReferencedConceptID is being referenced
// AbstractConceptID   indicates that the AbstractConceptID is being referenced
// RefinedConceptID    indicates that the RefinedConceptID is being referenced
// LiteralValue       indicates that the LiteralValue is being referenced
const (
        NoAttribute         = AttributeName(0)
        OwningConceptID     = AttributeName(1)
        ReferencedConceptID = AttributeName(2)
        AbstractConceptID   = AttributeName(3)
        RefinedConceptID    = AttributeName(4)
        LiteralValue        = AttributeName(5)
        Label               = AttributeName(6)
        Definition          = AttributeName(7)
)

func (an AttributeName) String() string <span class="cov8" title="1">{
        switch an </span>{
        case NoAttribute:<span class="cov8" title="1">
                return "NoAttribute"</span>
        case OwningConceptID:<span class="cov8" title="1">
                return "OwningConceptID"</span>
        case ReferencedConceptID:<span class="cov8" title="1">
                return "ReferencedConceptID"</span>
        case AbstractConceptID:<span class="cov8" title="1">
                return "AbstractConceptID"</span>
        case RefinedConceptID:<span class="cov8" title="1">
                return "RefinedConceptID"</span>
        case LiteralValue:<span class="cov0" title="0">
                return "LiteralValue"</span>
        case Label:<span class="cov0" title="0">
                return "Label"</span>
        case Definition:<span class="cov0" title="0">
                return "Definition"</span>
        }
        <span class="cov0" title="0">return "Undefined"</span>
}

// FindAttributeName takes a string version of the name and returns the corresponding AttributeName enumeration value
func FindAttributeName(stringName string) (AttributeName, error) <span class="cov8" title="1">{
        switch stringName </span>{
        case "NoAttribute":<span class="cov8" title="1">
                return NoAttribute, nil</span>
        case "OwningConceptID":<span class="cov8" title="1">
                return OwningConceptID, nil</span>
        case "ReferencedConceptID":<span class="cov8" title="1">
                return ReferencedConceptID, nil</span>
        case "AbstractConceptID":<span class="cov8" title="1">
                return AbstractConceptID, nil</span>
        case "RefinedConceptID":<span class="cov8" title="1">
                return RefinedConceptID, nil</span>
        case "LiteralValue":<span class="cov0" title="0">
                return LiteralValue, nil</span>
        }
        <span class="cov8" title="1">return NoAttribute, errors.New("NewAttribute value not found for stringName: " + stringName)</span>
}

type reference struct {
        element
        ReferencedConceptID string
        // referencedConcept is a cache for convenience
        ReferencedAttributeName  AttributeName
        ReferencedConceptVersion int
}

func (rPtr *reference) clone(hl *Transaction) Reference <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        var ref reference
        ref.initializeReference("", "")
        ref.cloneAttributes(rPtr, hl)
        return &amp;ref
}</span>

func (rPtr *reference) cloneAttributes(source *reference, hl *Transaction) <span class="cov8" title="1">{
        rPtr.element.cloneAttributes(&amp;source.element, hl)
        rPtr.ReferencedConceptID = source.ReferencedConceptID
        rPtr.ReferencedConceptVersion = source.ReferencedConceptVersion
}</span>

// GetReferencedConcept returns the element representing  the concept being referenced
// Note that this is a cached value
func (rPtr *reference) GetReferencedConcept(hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.getReferencedConceptNoLock()
}</span>

func (rPtr *reference) getReferencedConceptNoLock() Element <span class="cov8" title="1">{
        return rPtr.uOfD.GetElement(rPtr.ReferencedConceptID)
}</span>

// GetReferencedConceptID returns the identifier of the concept being referenced
func (rPtr *reference) GetReferencedConceptID(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.ReferencedConceptID
}</span>

// GetReferencedAttributeName returns an indicator of which attribute is being referenced (if any)
func (rPtr *reference) GetReferencedAttributeName(hl *Transaction) AttributeName <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.ReferencedAttributeName
}</span>

// GetReferencedAttributeValue returns the string value of the referenced attribute (if any)
func (rPtr *reference) GetReferencedAttributeValue(hl *Transaction) string <span class="cov0" title="0">{
        hl.ReadLockElement(rPtr)
        if rPtr.ReferencedConceptID != "" </span><span class="cov0" title="0">{
                referencedConcept := rPtr.GetReferencedConcept(hl)
                if referencedConcept != nil </span><span class="cov0" title="0">{
                        if rPtr.ReferencedAttributeName == OwningConceptID </span><span class="cov0" title="0">{
                                return referencedConcept.GetOwningConceptID(hl)
                        }</span>
                        <span class="cov0" title="0">switch typedReferencedConcept := referencedConcept.(type) </span>{
                        case Reference:<span class="cov0" title="0">
                                if rPtr.ReferencedAttributeName == ReferencedConceptID </span><span class="cov0" title="0">{
                                        return typedReferencedConcept.GetReferencedConceptID(hl)
                                }</span>
                        case Refinement:<span class="cov0" title="0">
                                if rPtr.ReferencedAttributeName == AbstractConceptID </span><span class="cov0" title="0">{
                                        return typedReferencedConcept.GetAbstractConceptID(hl)
                                }</span>
                                <span class="cov0" title="0">if rPtr.ReferencedAttributeName == RefinedConceptID </span><span class="cov0" title="0">{
                                        return typedReferencedConcept.GetRefinedConceptID(hl)
                                }</span>
                        case Literal:<span class="cov0" title="0">
                                if rPtr.ReferencedAttributeName == LiteralValue </span><span class="cov0" title="0">{
                                        return typedReferencedConcept.GetLiteralValue(hl)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// GetReferencedConceptVersion returns the last known version of the referenced concept
func (rPtr *reference) GetReferencedConceptVersion(hl *Transaction) int <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.ReferencedConceptVersion
}</span>

func (rPtr *reference) initializeReference(conceptID string, uri string) <span class="cov8" title="1">{
        rPtr.initializeElement(conceptID, uri)
}</span>

func (rPtr *reference) isEquivalent(hl1 *Transaction, el *reference, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">hl1.ReadLockElement(rPtr)
        hl2.ReadLockElement(el)
        if rPtr.ReferencedConceptID != el.ReferencedConceptID </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In reference.IsEquivalent, ReferencedConceptIDs do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if rPtr.ReferencedAttributeName != el.ReferencedAttributeName </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In reference.IsEquivalent, ReferencedAttributeNames do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if rPtr.ReferencedConceptVersion != el.ReferencedConceptVersion </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In reference.IsEquivalent, ReferencedConceptVersions do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return rPtr.element.isEquivalent(hl1, &amp;el.element, hl2, print)</span>
}

// MarshalJSON produces a byte string JSON representation of the Element
func (rPtr *reference) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        buffer := bytes.NewBufferString("{")
        typeName := reflect.TypeOf(rPtr).String()
        buffer.WriteString(fmt.Sprintf("\"Type\":\"%s\",", typeName))
        err := rPtr.marshalReferenceFields(buffer)
        buffer.WriteString("}")
        return buffer.Bytes(), err
}</span>

func (rPtr *reference) marshalReferenceFields(buffer *bytes.Buffer) error <span class="cov8" title="1">{
        buffer.WriteString(fmt.Sprintf("\"ReferencedConceptID\":\"%s\",", rPtr.ReferencedConceptID))
        buffer.WriteString(fmt.Sprintf("\"ReferencedAttributeName\":\"%s\",", rPtr.ReferencedAttributeName.String()))
        buffer.WriteString(fmt.Sprintf("\"ReferencedConceptVersion\":\"%d\",", rPtr.ReferencedConceptVersion))
        rPtr.element.marshalElementFields(buffer)
        return nil
}</span>

// recoverReferenceFields() is used when de-serializing an element. The activities in restoring the
// element are not considered changes so the version counter is not incremented and the monitors of this
// element are not notified of chaanges.
func (rPtr *reference) recoverReferenceFields(unmarshaledData *map[string]json.RawMessage, hl *Transaction) error <span class="cov8" title="1">{
        err := rPtr.recoverElementFields(unmarshaledData, hl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // ReferencedConceptID
        <span class="cov8" title="1">var recoveredReferencedConceptID string
        err = json.Unmarshal((*unmarshaledData)["ReferencedConceptID"], &amp;recoveredReferencedConceptID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Reference.ReferencedConceptID as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.ReferencedConceptID = recoveredReferencedConceptID
        // ReferencedAttributeName
        var recoveredReferencedConceptAttributeName string
        err = json.Unmarshal((*unmarshaledData)["ReferencedAttributeName"], &amp;recoveredReferencedConceptAttributeName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Reference.ReferencedAttributeName as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">var attributeName AttributeName
        attributeName, err = FindAttributeName(recoveredReferencedConceptAttributeName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of Reference.ReferencedAttributeName to AttributeName failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.ReferencedAttributeName = attributeName
        // ReferencedConceptVersion
        var recoveredReferencedConceptVersion string
        err = json.Unmarshal((*unmarshaledData)["ReferencedConceptVersion"], &amp;recoveredReferencedConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Reference.ReferencedConceptVersion failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.ReferencedConceptVersion, err = strconv.Atoi(recoveredReferencedConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of Reference.ReferencedConceptVersion to integer failed\n")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetReferencedConcept sets the referenced concept by calling SetReferencedConceptID using the ID of the
// supplied Element
func (rPtr *reference) SetReferencedConcept(el Element, attributeName AttributeName, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("reference.SetReferencedConcept failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        id := ""
        if el != nil </span><span class="cov8" title="1">{
                id = el.getConceptIDNoLock()
        }</span>
        <span class="cov8" title="1">return rPtr.SetReferencedConceptID(id, attributeName, hl)</span>
}

// SetReferencedConceptID sets the referenced concept using the supplied ID.
func (rPtr *reference) SetReferencedConceptID(rcID string, attributeName AttributeName, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("reference.SetReferencedConceptID failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        if !rPtr.isEditable(hl) </span><span class="cov8" title="1">{
                return errors.New("reference.SetReferencedConceptID failed because the reference is not editable")
        }</span>
        <span class="cov8" title="1">var newReferencedConcept Element
        var oldReferencedConcept Element
        if rPtr.ReferencedConceptID != rcID || rPtr.ReferencedAttributeName != attributeName </span><span class="cov8" title="1">{
                if rcID != "" </span><span class="cov8" title="1">{
                        newReferencedConcept = rPtr.uOfD.GetElement(rcID)
                        switch rPtr.GetReferencedAttributeName(hl) </span>{
                        case ReferencedConceptID:<span class="cov8" title="1">
                                switch newReferencedConcept.(type) </span>{
                                case Reference:<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0">
                                        return errors.New("In reference.SetReferencedConceptID, the ReferencedAttributeName was ReferencedConceptID, but the referenced concept is not a Reference")</span>
                                }
                        case AbstractConceptID, RefinedConceptID:<span class="cov0" title="0">
                                switch newReferencedConcept.(type) </span>{
                                case Refinement:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        return errors.New("In reference.SetReferencedConceptID, the ReferencedAttributeName was AbstractConceptID or RefinedConceptID, but the referenced concept is not a Refinement")</span>
                                }
                        }
                        <span class="cov8" title="1">if newReferencedConcept != nil </span><span class="cov8" title="1">{
                                newReferencedConcept.addListener(rPtr.ConceptID, hl)
                        }</span>
                }
                <span class="cov8" title="1">beforeState, err := NewConceptState(rPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "reference.SetReferencedConceptID failed")
                }</span>
                <span class="cov8" title="1">rPtr.uOfD.preChange(rPtr, hl)
                rPtr.incrementVersion(hl)
                if rPtr.ReferencedConceptID != "" </span><span class="cov8" title="1">{
                        oldReferencedConcept = rPtr.uOfD.GetElement(rPtr.ReferencedConceptID)
                        if oldReferencedConcept != nil </span><span class="cov8" title="1">{
                                oldReferencedConcept.removeListener(rPtr.ConceptID, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "reference.SetReferencedConceptID failed")
                                }</span>
                        }
                }
                <span class="cov8" title="1">if rcID != "" </span><span class="cov8" title="1">{
                        if newReferencedConcept != nil </span><span class="cov8" title="1">{
                                newReferencedConcept.addListener(rPtr.ConceptID, hl)
                        }</span>
                }
                <span class="cov8" title="1">rPtr.ReferencedConceptID = rcID
                rPtr.ReferencedAttributeName = attributeName
                if newReferencedConcept == nil </span><span class="cov8" title="1">{
                        rPtr.ReferencedConceptVersion = 0
                }</span> else<span class="cov8" title="1"> {
                        rPtr.ReferencedConceptVersion = newReferencedConcept.GetVersion(hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "reference.SetReferencedConceptID failed")
                        }</span>
                }
                <span class="cov8" title="1">afterState, err2 := NewConceptState(rPtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "reference.SetReferencedConceptID failed")
                }</span>
                <span class="cov8" title="1">err = rPtr.uOfD.SendPointerChangeNotification(rPtr, ReferencedConceptChanged, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "reference.SetReferencedConceptID failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// // SetReferencedConceptAttribute sets the value indicating whether a specific attribute of the referenced concept is being
// // referenced
// func (rPtr *reference) SetReferencedAttributeName(attributeName AttributeName, hl *HeldLocks) error {
//         hl.WriteLockElement(rPtr)
//         if rPtr.isEditable(hl) == false {
//                 return errors.New("reference.SetReferencedAttributeName failed because reference is not editable")
//         }
//         if rPtr.ReferencedAttributeName != attributeName {
//                 var referencedConcept Element
//                 if rPtr.ReferencedConceptID != "" {
//                         referencedConcept = rPtr.uOfD.GetElement(rPtr.ReferencedConceptID)
//                         if referencedConcept != nil {
//                         }
//                         switch rPtr.GetReferencedAttributeName(hl) {
//                         case ReferencedConceptID:
//                                 switch referencedConcept.(type) {
//                                 case Reference:
//                                 default:
//                                         return errors.New("In reference.SetReferencedConceptID, the ReferencedAttributeName was ReferencedConceptID, but the referenced concept is not a Reference")
//                                 }
//                         case AbstractConceptID, RefinedConceptID:
//                                 switch referencedConcept.(type) {
//                                 case Refinement:
//                                 default:
//                                         return errors.New("In reference.SetReferencedConceptID, the ReferencedAttributeName was AbstractConceptID or RefinedConceptID, but the referenced concept is not a Refinement")
//                                 }
//                         }
//                 }
//                 rPtr.uOfD.preChange(rPtr, hl)
//                 beforeState, err := NewConceptState(rPtr)
//                 if err != nil {
//                         return errors.Wrap(err, "reference.SetReferencedAttributeName failed")
//                 }
//                 rPtr.incrementVersion(hl)
//                 rPtr.ReferencedAttributeName = attributeName
//                 afterState, err2 := NewConceptState(rPtr)
//                 if err2 != nil {
//                         return errors.Wrap(err2, "reference.SetReferencedAttributeName failed")
//                 }
//                 err = rPtr.uOfD.SendConceptChangeNotification(rPtr, beforeState, afterState, hl)
//                 if err != nil {
//                         return errors.Wrap(err, "reference.SetReferencedAttributeName failed")
//                 }
//         }
//         return nil
// }

// Reference represents a concept that is a pointer to another concept
type Reference interface {
        Element
        GetReferencedConcept(*Transaction) Element
        GetReferencedConceptID(*Transaction) string
        GetReferencedAttributeName(*Transaction) AttributeName
        GetReferencedAttributeValue(*Transaction) string
        GetReferencedConceptVersion(*Transaction) int
        getReferencedConceptNoLock() Element
        SetReferencedConcept(Element, AttributeName, *Transaction) error
        // SetReferencedAttributeName(attributeName AttributeName, hl *HeldLocks) error
        SetReferencedConceptID(string, AttributeName, *Transaction) error
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package core

import (
        "bytes"
        "encoding/json"
        "fmt"
        "log"
        "reflect"
        "strconv"

        "github.com/pkg/errors"
)

type refinement struct {
        element
        AbstractConceptID      string
        AbstractConceptVersion int
        RefinedConceptID       string
        RefinedConceptVersion  int
}

func (rPtr *refinement) clone(hl *Transaction) Refinement <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        var ref refinement
        ref.initializeRefinement("", "")
        ref.cloneAttributes(rPtr, hl)
        return &amp;ref
}</span>

func (rPtr *refinement) cloneAttributes(source *refinement, hl *Transaction) <span class="cov8" title="1">{
        rPtr.element.cloneAttributes(&amp;source.element, hl)
        rPtr.AbstractConceptID = source.AbstractConceptID
        //        rPtr.abstractConcept = newCachedPointer(rPtr.getConceptIDNoLock(), false)
        rPtr.AbstractConceptVersion = source.AbstractConceptVersion
        rPtr.RefinedConceptID = source.RefinedConceptID
        //        rPtr.refinedConcept = newCachedPointer(rPtr.getConceptIDNoLock(), false)
        rPtr.RefinedConceptVersion = source.RefinedConceptVersion
}</span>

func (rPtr *refinement) GetAbstractConcept(hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.uOfD.GetElement(rPtr.AbstractConceptID)
}</span>

func (rPtr *refinement) getAbstractConceptNoLock() Element <span class="cov0" title="0">{
        return rPtr.uOfD.GetElement(rPtr.AbstractConceptID)
}</span>

func (rPtr *refinement) GetAbstractConceptID(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.AbstractConceptID
}</span>

func (rPtr *refinement) getAbstractConceptIDNoLock() string <span class="cov0" title="0">{
        return rPtr.AbstractConceptID
}</span>

func (rPtr *refinement) GetAbstractConceptVersion(hl *Transaction) int <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.AbstractConceptVersion
}</span>

func (rPtr *refinement) GetRefinedConcept(hl *Transaction) Element <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.uOfD.GetElement(rPtr.RefinedConceptID)
}</span>

func (rPtr *refinement) getRefinedConceptNoLock() Element <span class="cov0" title="0">{
        return rPtr.uOfD.GetElement(rPtr.RefinedConceptID)
}</span>

func (rPtr *refinement) GetRefinedConceptID(hl *Transaction) string <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.RefinedConceptID
}</span>

func (rPtr *refinement) getRefinedConceptIDNoLock() string <span class="cov0" title="0">{
        return rPtr.RefinedConceptID
}</span>

func (rPtr *refinement) GetRefinedConceptVersion(hl *Transaction) int <span class="cov8" title="1">{
        hl.ReadLockElement(rPtr)
        return rPtr.RefinedConceptVersion
}</span>

func (rPtr *refinement) initializeRefinement(conceptID string, uri string) <span class="cov8" title="1">{
        rPtr.initializeElement(conceptID, uri)
}</span>

func (rPtr *refinement) isEquivalent(hl1 *Transaction, ref *refinement, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">hl1.ReadLockElement(rPtr)
        hl2.ReadLockElement(ref)
        if rPtr.AbstractConceptID != ref.AbstractConceptID </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In refinement.isEquivalent, AbstractConecptIDs do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if rPtr.AbstractConceptVersion != ref.AbstractConceptVersion </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In refinement.isEquivalent, AbstractConecptVersionss do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if rPtr.RefinedConceptID != ref.RefinedConceptID </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In refinement.isEquivalent, RefinedConecptIDs do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">if rPtr.RefinedConceptVersion != ref.RefinedConceptVersion </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In refinement.isEquivalent, RefinedConecptVersions do not match")
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return rPtr.element.isEquivalent(hl1, &amp;ref.element, hl2, print)</span>
}

// MarshalJSON produces a byte string JSON representation of the Element
func (rPtr *refinement) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        buffer := bytes.NewBufferString("{")
        typeName := reflect.TypeOf(rPtr).String()
        buffer.WriteString(fmt.Sprintf("\"Type\":\"%s\",", typeName))
        err := rPtr.marshalRefinementFields(buffer)
        buffer.WriteString("}")
        return buffer.Bytes(), err
}</span>

func (rPtr *refinement) marshalRefinementFields(buffer *bytes.Buffer) error <span class="cov8" title="1">{
        buffer.WriteString(fmt.Sprintf("\"AbstractConceptID\":\"%s\",", rPtr.AbstractConceptID))
        buffer.WriteString(fmt.Sprintf("\"AbstractConceptVersion\":\"%d\",", rPtr.AbstractConceptVersion))
        buffer.WriteString(fmt.Sprintf("\"RefinedConceptID\":\"%s\",", rPtr.RefinedConceptID))
        buffer.WriteString(fmt.Sprintf("\"RefinedConceptVersion\":\"%d\",", rPtr.RefinedConceptVersion))
        rPtr.element.marshalElementFields(buffer)
        return nil
}</span>

// recoverRefinementFields() is used when de-serializing an element. The activities in restoring the
// element are not considered changes so the version counter is not incremented and the monitors of this
// element are not notified of chaanges.
func (rPtr *refinement) recoverRefinementFields(unmarshaledData *map[string]json.RawMessage, hl *Transaction) error <span class="cov8" title="1">{
        err := rPtr.recoverElementFields(unmarshaledData, hl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // AbstractConceptID
        <span class="cov8" title="1">var recoveredAbstractConceptID string
        err = json.Unmarshal((*unmarshaledData)["AbstractConceptID"], &amp;recoveredAbstractConceptID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Refinement.AbstractConceptID as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.AbstractConceptID = recoveredAbstractConceptID
        // AbstractConceptVersion
        var recoveredAbstractConceptVersion string
        err = json.Unmarshal((*unmarshaledData)["AbstractConceptVersion"], &amp;recoveredAbstractConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Refinement.AbstractConceptVersion failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.AbstractConceptVersion, err = strconv.Atoi(recoveredAbstractConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of Refinement.AbstractConceptVersion to integer failed\n")
                return err
        }</span>
        // RefinedConceptID
        <span class="cov8" title="1">var recoveredRefinedConceptID string
        err = json.Unmarshal((*unmarshaledData)["RefinedConceptID"], &amp;recoveredRefinedConceptID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Refinement.RefinedConceptID as string failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.RefinedConceptID = recoveredRefinedConceptID
        // RefinedConceptVersion
        var recoveredRefinedConceptVersion string
        err = json.Unmarshal((*unmarshaledData)["RefinedConceptVersion"], &amp;recoveredRefinedConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Recovery of Refinement.RefinedConceptVersion failed\n")
                return err
        }</span>
        <span class="cov8" title="1">rPtr.RefinedConceptVersion, err = strconv.Atoi(recoveredRefinedConceptVersion)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Conversion of Refinement.RefinedConceptVersion to integer failed\n")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetAbstractConcept sets the abstract concept using the ID of the supplied Element
func (rPtr *refinement) SetAbstractConcept(el Element, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("refinement.SetAbstractConcept failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        id := ""
        if el != nil </span><span class="cov8" title="1">{
                id = el.getConceptIDNoLock()
        }</span>
        <span class="cov8" title="1">return rPtr.SetAbstractConceptID(id, hl)</span>
}

func (rPtr *refinement) SetAbstractConceptID(acID string, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("refinement.SetAbstractConceptID failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        if !rPtr.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("refinement.SetAbstractConceptID failed because the refinement is not editable")
        }</span>
        <span class="cov8" title="1">if rPtr.AbstractConceptID != acID </span><span class="cov8" title="1">{
                rPtr.uOfD.preChange(rPtr, hl)
                beforeState, err := NewConceptState(rPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "refinement.SetAbstractConceptID failed")
                }</span>
                <span class="cov8" title="1">rPtr.incrementVersion(hl)
                var oldAbstractConcept Element
                if rPtr.AbstractConceptID != "" </span><span class="cov8" title="1">{
                        oldAbstractConcept = rPtr.uOfD.GetElement(rPtr.AbstractConceptID)
                        if oldAbstractConcept != nil </span><span class="cov8" title="1">{
                                oldAbstractConcept.removeListener(rPtr.ConceptID, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "refinement.SetAbstractConceptID failed")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // This case can arise if the abstract concept is not currently loaded
                                rPtr.uOfD.listenersMap.RemoveMappedValue(rPtr.AbstractConceptID, rPtr.ConceptID)
                        }</span>
                }
                <span class="cov8" title="1">var newAbstractConcept Element
                if acID != "" </span><span class="cov8" title="1">{
                        newAbstractConcept = rPtr.uOfD.GetElement(acID)
                        if newAbstractConcept != nil </span><span class="cov8" title="1">{
                                newAbstractConcept.addListener(rPtr.ConceptID, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "refinement.SetAbstractConceptID failed")
                                }</span>
                        }
                }
                <span class="cov8" title="1">rPtr.AbstractConceptID = acID
                if newAbstractConcept != nil </span><span class="cov8" title="1">{
                        rPtr.AbstractConceptVersion = newAbstractConcept.GetVersion(hl)
                }</span> else<span class="cov8" title="1"> {
                        rPtr.AbstractConceptVersion = 0
                }</span>
                <span class="cov8" title="1">afterState, err2 := NewConceptState(rPtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "refinement.SetAbstractConceptID failed")
                }</span>
                <span class="cov8" title="1">err = rPtr.uOfD.SendPointerChangeNotification(rPtr, AbstractConceptChanged, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "refinement.SetAbstractConceptID failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rPtr *refinement) SetRefinedConcept(el Element, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("refinement.SetRefinedConcept failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        id := ""
        if el != nil </span><span class="cov8" title="1">{
                id = el.getConceptIDNoLock()
        }</span>
        <span class="cov8" title="1">return rPtr.SetRefinedConceptID(id, hl)</span>
}

func (rPtr *refinement) SetRefinedConceptID(rcID string, hl *Transaction) error <span class="cov8" title="1">{
        if rPtr.uOfD == nil </span><span class="cov0" title="0">{
                return errors.New("refinement.SetRefinedConceptID failed because the element uOfD is nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(rPtr)
        if !rPtr.isEditable(hl) </span><span class="cov0" title="0">{
                return errors.New("refinement.SetReferencedConceptID failed because the refinement is not editable")
        }</span>
        <span class="cov8" title="1">if rPtr.RefinedConceptID != rcID </span><span class="cov8" title="1">{
                rPtr.uOfD.preChange(rPtr, hl)
                beforeState, err := NewConceptState(rPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "refinement.SetRefinedConceptID failed")
                }</span>
                <span class="cov8" title="1">rPtr.incrementVersion(hl)
                var oldRefinedConcept Element
                if rPtr.RefinedConceptID != "" </span><span class="cov8" title="1">{
                        oldRefinedConcept = rPtr.uOfD.GetElement(rPtr.RefinedConceptID)
                        if oldRefinedConcept != nil </span><span class="cov8" title="1">{
                                oldRefinedConcept.removeListener(rPtr.ConceptID, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "refinement.SetRefinedConceptID failed")
                                }</span>
                        }
                }
                <span class="cov8" title="1">var newRefinedConcept Element
                if rcID != "" </span><span class="cov8" title="1">{
                        newRefinedConcept = rPtr.uOfD.GetElement(rcID)
                        if newRefinedConcept != nil </span><span class="cov8" title="1">{
                                newRefinedConcept.addListener(rPtr.ConceptID, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "refinement.SetRefinedConceptID failed")
                                }</span>
                        }
                }
                <span class="cov8" title="1">rPtr.RefinedConceptID = rcID
                if newRefinedConcept != nil </span><span class="cov8" title="1">{
                        rPtr.RefinedConceptVersion = newRefinedConcept.GetVersion(hl)
                }</span> else<span class="cov8" title="1"> {
                        rPtr.RefinedConceptVersion = 0
                }</span>
                <span class="cov8" title="1">afterState, err2 := NewConceptState(rPtr)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "refinement.SetRefinedConceptID failed")
                }</span>
                <span class="cov8" title="1">err = rPtr.uOfD.SendPointerChangeNotification(rPtr, RefinedConceptChanged, beforeState, afterState, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "refinement.SetRefinedConceptID failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Refinement is the reification of a refinement association between an abstract Element and a refined Element
type Refinement interface {
        Element
        GetAbstractConceptID(*Transaction) string
        getAbstractConceptIDNoLock() string
        GetAbstractConcept(*Transaction) Element
        getAbstractConceptNoLock() Element
        GetAbstractConceptVersion(*Transaction) int
        GetRefinedConceptID(*Transaction) string
        getRefinedConceptIDNoLock() string
        GetRefinedConcept(*Transaction) Element
        getRefinedConceptNoLock() Element
        GetRefinedConceptVersion(*Transaction) int
        SetAbstractConcept(Element, *Transaction) error
        SetAbstractConceptID(string, *Transaction) error
        SetRefinedConcept(Element, *Transaction) error
        SetRefinedConceptID(string, *Transaction) error
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import (
        //        "github.com/satori/go.uuid"
        "log"
        "sync"
)

// StringElementMap is a map from a UUID (a string) to the Element that represents it
type StringElementMap struct {
        sync.Mutex
        elementMap map[string]Element
}

// NewStringElementMap creates and initializes a stringElementMap
func NewStringElementMap() *StringElementMap <span class="cov8" title="1">{
        var uuidElementMap StringElementMap
        uuidElementMap.elementMap = make(map[string]Element)
        return &amp;uuidElementMap
}</span>

// Clear clears the map
func (seMap *StringElementMap) Clear() <span class="cov0" title="0">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        seMap.elementMap = make(map[string]Element)
}</span>

// CopyMap returns a copy of the map
func (seMap *StringElementMap) CopyMap() map[string]Element <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        copy := make(map[string]Element)
        for key, value := range seMap.elementMap </span><span class="cov8" title="1">{
                copy[key] = value
        }</span>
        <span class="cov8" title="1">return copy</span>
}

// DeleteEntry removes the map entry for the indicated UUID
func (seMap *StringElementMap) DeleteEntry(key string) <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        delete(seMap.elementMap, key)
}</span>

// GetEntry returns the Element corresponding to the UUID
func (seMap *StringElementMap) GetEntry(key string) Element <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        return seMap.elementMap[key]
}</span>

// IsEquivalent returns true if the map contains the same number of elements
// and each has the same set of keys. No comparison is performed on the elements
// themselves
func (seMap *StringElementMap) IsEquivalent(sem *StringElementMap) bool <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        sem.TraceableLock()
        defer sem.TraceableUnlock()
        if len(seMap.elementMap) != len(sem.elementMap) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for k := range seMap.elementMap </span><span class="cov8" title="1">{
                if sem.elementMap[k] == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Print prints the map. The function is intended for use in debugging
func (seMap *StringElementMap) Print(hl *Transaction) <span class="cov0" title="0">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        for uuid, be := range seMap.elementMap </span><span class="cov0" title="0">{
                log.Printf("Uri: %s\n", uuid)
                Print(be, "    ", hl)
        }</span>
}

// PrintJustIdentifiers prints just the UUIDs (keys) of the map. It is intended for use in debugging
func (seMap *StringElementMap) PrintJustIdentifiers(hl *Transaction) <span class="cov0" title="0">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        for uuid := range seMap.elementMap </span><span class="cov0" title="0">{
                log.Printf("UUID: %s \n", uuid)
        }</span>
}

// SetEntry sets the Element corresponding to the given UUID
func (seMap *StringElementMap) SetEntry(key string, value Element) <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        seMap.elementMap[key] = value
}</span>

// TraceableLock locks the map. If TraceLocks is true in logs the acquisition of the lock
func (seMap *StringElementMap) TraceableLock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to lock stringElementMap %p\n", seMap)
        // }
        seMap.Lock()
}</span>

// TraceableUnlock unlocks the map. If TraceLocks is true it logs the release of the lock
func (seMap *StringElementMap) TraceableUnlock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to unlock stringElementMap %p\n", seMap)
        // }
        seMap.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import (
        //        "github.com/satori/go.uuid"
        "log"
        "sync"
)

// StringStringMap is a map from a URI (a string) to the UUID of an Element that represents it
type StringStringMap struct {
        sync.Mutex
        uriUUIDMap map[string]string
}

// NewStringStringMap creates and initializes a stringElementMap
func NewStringStringMap() *StringStringMap <span class="cov8" title="1">{
        var uriUUIDMap StringStringMap
        uriUUIDMap.uriUUIDMap = make(map[string]string)
        return &amp;uriUUIDMap
}</span>

// Clear clears the map
func (seMap *StringStringMap) Clear() <span class="cov0" title="0">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        seMap.uriUUIDMap = make(map[string]string)
}</span>

// CopyMap returns a copy of the map
func (seMap *StringStringMap) CopyMap() map[string]string <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        copy := make(map[string]string)
        for key, value := range seMap.uriUUIDMap </span><span class="cov8" title="1">{
                copy[key] = value
        }</span>
        <span class="cov8" title="1">return copy</span>
}

// DeleteEntry removes the map entry for the indicated UUID
func (seMap *StringStringMap) DeleteEntry(key string) <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        delete(seMap.uriUUIDMap, key)
}</span>

// GetEntry returns the Element corresponding to the UUID
func (seMap *StringStringMap) GetEntry(key string) string <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        return seMap.uriUUIDMap[key]
}</span>

// IsEquivalent returns true if the map contains the same number of entries
// and each key same value
func (seMap *StringStringMap) IsEquivalent(sem *StringStringMap, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        sem.TraceableLock()
        defer sem.TraceableUnlock()
        if len(seMap.uriUUIDMap) != len(sem.uriUUIDMap) </span><span class="cov8" title="1">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("Map1 entries that differ from Map2:")
                        for k := range seMap.uriUUIDMap </span><span class="cov0" title="0">{
                                if seMap.uriUUIDMap[k] != sem.uriUUIDMap[k] </span><span class="cov0" title="0">{
                                        log.Printf("Map1 key: %s Map1 value %s Map2 value %s", k, seMap.uriUUIDMap[k], sem.uriUUIDMap[k])
                                }</span>
                        }
                        <span class="cov0" title="0">log.Printf("Map2 entries that differ frmo Map1")
                        for k := range sem.uriUUIDMap </span><span class="cov0" title="0">{
                                if sem.uriUUIDMap[k] != seMap.uriUUIDMap[k] </span><span class="cov0" title="0">{
                                        log.Printf("Map2 key: %s Map2 value %s Map1 value %s", k, sem.uriUUIDMap[k], seMap.uriUUIDMap[k])
                                }</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">for k := range seMap.uriUUIDMap </span><span class="cov8" title="1">{
                if seMap.uriUUIDMap[k] != sem.uriUUIDMap[k] </span><span class="cov0" title="0">{
                        if print </span><span class="cov0" title="0">{
                                log.Printf("Map1 entries that differ from Map2:")
                                for k := range seMap.uriUUIDMap </span><span class="cov0" title="0">{
                                        if seMap.uriUUIDMap[k] != sem.uriUUIDMap[k] </span><span class="cov0" title="0">{
                                                log.Printf("Map1 key: %s Map1 value %s Map2 value %s", k, seMap.uriUUIDMap[k], sem.uriUUIDMap[k])
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return false</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// Print prints the map. The function is intended for use in debugging
func (seMap *StringStringMap) Print(hl *Transaction) <span class="cov0" title="0">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        for uri, uuid := range seMap.uriUUIDMap </span><span class="cov0" title="0">{
                log.Printf("Uri: %s  UUID: %s\n", uri, uuid)
        }</span>
}

// SetEntry sets the UUID corresponding to the given URI
func (seMap *StringStringMap) SetEntry(key string, value string) <span class="cov8" title="1">{
        seMap.TraceableLock()
        defer seMap.TraceableUnlock()
        seMap.uriUUIDMap[key] = value
}</span>

// TraceableLock locks the map. If TraceLocks is true in logs the acquisition of the lock
func (seMap *StringStringMap) TraceableLock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to lock stringElementMap %p\n", seMap)
        // }
        seMap.Lock()
}</span>

// TraceableUnlock unlocks the map. If TraceLocks is true it logs the release of the lock
func (seMap *StringStringMap) TraceableUnlock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to unlock stringElementMap %p\n", seMap)
        // }
        seMap.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

// TraceChange is a boolean that, when true, turns on the tracing of ChangeNotifications
var TraceChange bool

// OmitHousekeepingCalls is a boolean that indicates whether housekeeping calls should be omitted when TraceChanve is enabled.
var OmitHousekeepingCalls bool

// OmitManageTreeNodesCalls is a boolean that indicates whether tree node management calls should be omitted when TraceChanve is enabled.
var OmitManageTreeNodesCalls bool

// OmitDiagramRelatedCalls is a boolean that indicates whether diagram management calls should be omitted when TraceChanve is enabled.
var OmitDiagramRelatedCalls bool

// TraceLocks is a boolean that, when true, turns on the tracing of locks
var TraceLocks = false

var notificationGraphs []*NotificationGraph

// EnableNotificationPrint turns on the printing of notifications during tracing.
var EnableNotificationPrint bool

// traceFunctionCalls determines whether individual function calls will be traced. Its primary purpose is
// to understand what notifications resulted in the call to the function. When true, every time a function call
// is executed a graph of the function call and its antecedent notifications will be created and added to the
// functionCallGraphs
// var traceFunctionCalls bool
var functionCallGraphs []*FunctionCallGraph

// notificationsLimit places an absolute limit on the number of notifications allowed. A value of 0 means no limit.
var notificationsLimit int

// ClearFunctionCallGraphs deletes all existing FunctionCallGraphs
func ClearFunctionCallGraphs() <span class="cov0" title="0">{
        functionCallGraphs = nil
}</span>

// ClearNotificationGraphs deletes all existing NotificationGraphs
func ClearNotificationGraphs() <span class="cov0" title="0">{
        notificationGraphs = nil
}</span>

// GetFunctionCallGraphs returns the array of FunctionCallGraphs that have been created
func GetFunctionCallGraphs() []*FunctionCallGraph <span class="cov0" title="0">{
        return functionCallGraphs
}</span>

// GetNotificationGraphs returns the array of NotificationGraphs that have been created
func GetNotificationGraphs() []*NotificationGraph <span class="cov0" title="0">{
        return notificationGraphs
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2017, 2018 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can el found in the LICENSE file.

package core

import (
        "log"
        "sync"

        "github.com/pkg/errors"
)

// Transaction maintains a record of which elements are currently read and write locked and provides facilities
// for locking additional elements.
type Transaction struct {
        sync.Mutex
        // functionCallManager *functionCallManager
        readLocks  map[string]Element
        uOfD       *UniverseOfDiscourse
        writeLocks map[string]Element
        // functionCallQueue *pendingFunctionCallQueue
}

// callFunction calls the referenced function on the target element
func (transPtr *Transaction) callFunctions(functionID string, targetElement Element, notification *ChangeNotification) error <span class="cov8" title="1">{
        for _, function := range transPtr.uOfD.getFunctions(functionID) </span><span class="cov8" title="1">{
                if transPtr.uOfD.getExecutedCalls() != nil </span><span class="cov0" title="0">{
                        functionCallRecord, err := newFunctionCallRecord(functionID, function, targetElement, notification)
                        transPtr.uOfD.getExecutedCalls() &lt;- functionCallRecord
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "Transaction.callFunctions failed to queue functionCallRecord")
                        }</span>
                }
                <span class="cov8" title="1">if TraceLocks || TraceChange </span><span class="cov8" title="1">{
                        omitCall := (OmitManageTreeNodesCalls &amp;&amp; functionID == "http://activeCrl.com/crlEditor/EditorDomain/TreeViews/TreeNodeManager") ||
                                (OmitDiagramRelatedCalls &amp;&amp; isDiagramRelatedFunction(functionID))
                        if !omitCall </span><span class="cov8" title="1">{
                                functionCallGraphs = append(functionCallGraphs, NewFunctionCallGraph(functionID, targetElement, notification, transPtr))
                        }</span>
                }
                <span class="cov8" title="1">err := function(targetElement, notification, transPtr)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "Transaction.callFunctions failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetUniverseOfDiscourse returns the UniverseOfDiscourse to which this HeldLocks belongs
func (transPtr *Transaction) GetUniverseOfDiscourse() *UniverseOfDiscourse <span class="cov8" title="1">{
        return transPtr.uOfD
}</span>

// // IsLocked checks to see whether this HeldLocks structure already has a record of the Element being locked
// // and returns the result.
// func (transPtr *HeldLocks) IsLocked(el Element) bool {
//         transPtr.Lock()
//         defer transPtr.Unlock()
//         id := el.getConceptIDNoLock()
//         return transPtr.writeLocks[id] != nil
// }

// ReadLockElement checks to see whether this HeldLocks structure already has a record of the Element being
// locked, either read or write. If it does, it simply returns. If not, it attempts to acquire the read on the Element and makes
// a record of the fact that the read lock has been obtained.
func (transPtr *Transaction) ReadLockElement(el Element) <span class="cov8" title="1">{
        transPtr.Lock()
        defer transPtr.Unlock()
        id := el.getConceptIDNoLock()
        _, writeLocked := transPtr.writeLocks[id]
        if writeLocked </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">_, readLocked := transPtr.readLocks[id]
        if !readLocked </span><span class="cov8" title="1">{
                el.TraceableReadLock(transPtr)
                transPtr.readLocks[id] = el
        }</span>
}

// WriteLockElement checks to see whether this HeldLocks structure already has a record of the Element being
// write locked. If it does, it simply returns. If not, it attempts to acquire the write lock on the Element and makes
// a record of the fact that the lock has been obtained.
func (transPtr *Transaction) WriteLockElement(el Element) error <span class="cov8" title="1">{
        transPtr.Lock()
        defer transPtr.Unlock()
        id := el.getConceptIDNoLock()
        _, readLocked := transPtr.readLocks[id]
        if readLocked </span><span class="cov8" title="1">{
                return errors.New("Write lock attempted on Element with read lock: " + id)
        }</span>
        <span class="cov8" title="1">_, writeLocked := transPtr.writeLocks[id]
        if !writeLocked </span><span class="cov8" title="1">{
                el.TraceableWriteLock(transPtr)
                transPtr.writeLocks[id] = el
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReleaseLocks releases all pending functions for execution (asynchronously) and releases all currently held locks
func (transPtr *Transaction) ReleaseLocks() <span class="cov8" title="1">{
        transPtr.Lock()
        defer transPtr.Unlock()
        if TraceLocks </span><span class="cov0" title="0">{
                log.Printf("HL %p about to ReleaseLocks", transPtr)
        }</span>
        <span class="cov8" title="1">for _, el := range transPtr.readLocks </span><span class="cov8" title="1">{
                el.TraceableReadUnlock(transPtr)
                delete(transPtr.readLocks, el.getConceptIDNoLock())
        }</span>
        <span class="cov8" title="1">for _, el := range transPtr.writeLocks </span><span class="cov8" title="1">{
                el.TraceableWriteUnlock(transPtr)
                delete(transPtr.writeLocks, el.getConceptIDNoLock())
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import (
        "errors"
        "log"
        "runtime/debug"
        "sync"
)

type undoManager struct {
        sync.Mutex
        debugUndo     bool
        recordingUndo bool
        redoStack     undoStack
        undoStack     undoStack
        uOfD          *UniverseOfDiscourse
}

// NewUndoManager creates and initializes the manager for the undo/redo functionality
func newUndoManager(uOfD *UniverseOfDiscourse) *undoManager <span class="cov8" title="1">{
        var undoMgr undoManager
        undoMgr.debugUndo = false
        undoMgr.recordingUndo = false
        undoMgr.uOfD = uOfD
        return &amp;undoMgr
}</span>

// markChangedElement() If undo is enabled, updates the undo stack.
func (undoMgr *undoManager) markChangedElement(changedElement Element, hl *Transaction) error <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        hl.ReadLockElement(changedElement)
        if undoMgr.debugUndo </span><span class="cov0" title="0">{
                debug.PrintStack()
        }</span>
        <span class="cov8" title="1">priorState := clone(changedElement, hl)
        priorOwnedElements := undoMgr.uOfD.ownedIDsMap.GetMappedValues(changedElement.GetConceptID(hl)).Clone()
        priorListeners := undoMgr.uOfD.listenersMap.GetMappedValues(changedElement.GetConceptID(hl)).Clone()
        if undoMgr.recordingUndo </span><span class="cov8" title="1">{
                undoMgr.undoStack.Push(newUndoRedoStackEntry(Change, priorState, priorOwnedElements, priorListeners, changedElement))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// markNewElement() If undo is enabled, updates the undo stack.
func (undoMgr *undoManager) markNewElement(el Element, hl *Transaction) error <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        if hl == nil </span><span class="cov0" title="0">{
                return errors.New("UndoManager.markNewElement called with nil HeldLocks")
        }</span>
        <span class="cov8" title="1">hl.ReadLockElement(el)
        if undoMgr.debugUndo </span><span class="cov0" title="0">{
                debug.PrintStack()
        }</span>
        <span class="cov8" title="1">if undoMgr.recordingUndo </span><span class="cov8" title="1">{
                clone := clone(el, hl)
                priorOwnedElements := undoMgr.uOfD.ownedIDsMap.GetMappedValues(el.GetConceptID(hl)).Clone()
                priorListeners := undoMgr.uOfD.listenersMap.GetMappedValues(el.GetConceptID(hl)).Clone()
                stackEntry := newUndoRedoStackEntry(Creation, clone, priorOwnedElements, priorListeners, el)
                if undoMgr.debugUndo </span><span class="cov0" title="0">{
                        PrintStackEntry(stackEntry, hl)
                }</span>
                <span class="cov8" title="1">undoMgr.undoStack.Push(stackEntry)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// markRemoveElement() If undo is enabled, updates the undo stack.
func (undoMgr *undoManager) markRemovedElement(el Element, hl *Transaction) error <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        if hl == nil </span><span class="cov0" title="0">{
                return errors.New("UndoManager.markRemovedElement called with nil HeldLocks")
        }</span>
        <span class="cov8" title="1">hl.ReadLockElement(el)
        if undoMgr.debugUndo </span><span class="cov0" title="0">{
                debug.PrintStack()
        }</span>
        <span class="cov8" title="1">if undoMgr.recordingUndo </span><span class="cov8" title="1">{
                clone := clone(el, hl)
                priorOwnedElements := undoMgr.uOfD.ownedIDsMap.GetMappedValues(el.GetConceptID(hl)).Clone()
                priorListeners := undoMgr.uOfD.listenersMap.GetMappedValues(el.GetConceptID(hl)).Clone()
                undoMgr.undoStack.Push(newUndoRedoStackEntry(Deletion, clone, priorOwnedElements, priorListeners, el))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MarkUndoPoint() If undo is enabled, puts a marker on the undo stack.
func (undoMgr *undoManager) MarkUndoPoint() <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        if undoMgr.recordingUndo </span><span class="cov8" title="1">{
                undoMgr.undoStack.Push(newUndoRedoStackEntry(Marker, nil, nil, nil, nil))
        }</span>
}

// PrintUndoStack prints the undo stack. It is intended only for debugging.
func PrintUndoStack(s undoStack, stackName string, uOfD *UniverseOfDiscourse) <span class="cov0" title="0">{
        hl := uOfD.NewTransaction()
        defer hl.ReleaseLocks()
        log.Printf("%s:", stackName)
        for _, entry := range s </span><span class="cov0" title="0">{
                var changeType string
                switch entry.changeType </span>{
                case Creation:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                changeType = "Creation"
                        }</span>
                case Deletion:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                changeType = "Deletion"
                        }</span>
                case Change:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                changeType = "Change"
                        }</span>
                case Marker:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                changeType = "Marker"
                        }</span>
                }
                <span class="cov0" title="0">log.Printf("   Change type: %s", changeType)
                log.Printf("   Prior state:")
                Print(entry.priorState, "      ", hl)
                log.Printf("   Changed element:")
                Print(entry.changedElement, "      ", hl)</span>
        }
}

// PrintStackEntry prints the entry on the stack. It is intended for use only in debugging
func PrintStackEntry(entry *undoRedoStackEntry, hl *Transaction) <span class="cov0" title="0">{
        var changeType string
        switch entry.changeType </span>{
        case Creation:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        changeType = "Creation"
                }</span>
        case Deletion:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        changeType = "Deletion"
                }</span>
        case Change:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        changeType = "Change"
                }</span>
        case Marker:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        changeType = "Marker"
                }</span>
        }
        <span class="cov0" title="0">log.Printf("   Change type: %s", changeType)
        log.Printf("   Prior state:")
        Print(entry.priorState, "      ", hl)
        log.Printf("   Changed element:")
        Print(entry.changedElement, "      ", hl)</span>
}

func (undoMgr *undoManager) redo(hl *Transaction) <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        uOfD := undoMgr.uOfD
        for len(undoMgr.redoStack) &gt; 0 </span><span class="cov8" title="1">{
                currentEntry := undoMgr.redoStack.Pop()
                var currentID string
                if currentEntry.changedElement != nil </span><span class="cov8" title="1">{
                        currentID = currentEntry.changedElement.GetConceptID(hl)
                }</span>
                <span class="cov8" title="1">if currentEntry.changeType == Marker </span><span class="cov8" title="1">{
                        undoMgr.undoStack.Push(currentEntry)
                        return
                }</span> else<span class="cov8" title="1"> if currentEntry.changeType == Creation </span><span class="cov8" title="1">{
                        // Update owner's owned elements. Since we are redoing a creation, if the changed element has an owner
                        // we must add the current element to the owner's ownedElements
                        if currentEntry.changedElement.GetOwningConceptID(hl) != "" </span><span class="cov0" title="0">{
                                uOfD.ownedIDsMap.AddMappedValue(currentEntry.changedElement.GetOwningConceptID(hl), currentID)
                        }</span>
                        // Update listeners. If this is a reference or refinement pointing to another element, add this element to the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.changedElement.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                referencedElementID := currentEntry.changedElement.(*reference).ReferencedConceptID
                                if referencedElementID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.AddMappedValue(referencedElementID, currentID)
                                }</span>
                        case *refinement:<span class="cov8" title="1">
                                abstractID := currentEntry.changedElement.(*refinement).AbstractConceptID
                                if abstractID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.AddMappedValue(abstractID, currentID)
                                }</span>
                                <span class="cov8" title="1">refinedID := currentEntry.changedElement.(*refinement).RefinedConceptID
                                if refinedID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.AddMappedValue(refinedID, currentID)
                                }</span>
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">uri := currentEntry.changedElement.GetURI(hl)
                        if uri != "" </span><span class="cov8" title="1">{
                                uOfD.uriUUIDMap.SetEntry(uri, currentID)
                        }</span>
                        <span class="cov8" title="1">undoMgr.undoStack.Push(currentEntry)
                        undoMgr.restoreState(currentEntry.priorState, currentEntry.changedElement, hl)
                        // this was a new element
                        uOfD.addElementForUndo(currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)</span>
                } else<span class="cov8" title="1"> if currentEntry.changeType == Deletion </span><span class="cov8" title="1">{
                        // Update owner's owned elements. Since we are redoing a deletion, if the changed element has an owner
                        // we must remove the current element from the owner's ownedElements
                        if currentEntry.priorState.GetOwningConceptID(hl) != "" </span><span class="cov8" title="1">{
                                uOfD.ownedIDsMap.RemoveMappedValue(currentEntry.priorState.GetOwningConceptID(hl), currentEntry.priorState.GetConceptID(hl))
                        }</span>
                        // Update listeners. If this is a reference or refinement pointing to another element, remove this element from the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.priorState.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                referencedElementID := currentEntry.priorState.(*reference).ReferencedConceptID
                                if referencedElementID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.RemoveMappedValue(referencedElementID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                        case *refinement:<span class="cov8" title="1">
                                abstractID := currentEntry.priorState.(*refinement).AbstractConceptID
                                if abstractID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.RemoveMappedValue(abstractID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                                <span class="cov8" title="1">refinedID := currentEntry.priorState.(*refinement).RefinedConceptID
                                if refinedID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.RemoveMappedValue(refinedID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">uri := currentEntry.priorState.GetURI(hl)
                        if uri != "" </span><span class="cov8" title="1">{
                                uOfD.uriUUIDMap.DeleteEntry(uri)
                        }</span>
                        <span class="cov8" title="1">undoMgr.undoStack.Push(currentEntry)
                        undoMgr.restoreState(currentEntry.priorState, currentEntry.changedElement, hl)
                        // this was an deleted element
                        uOfD.removeElementForUndo(currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)</span>
                } else<span class="cov8" title="1"> if currentEntry.changeType == Change </span><span class="cov8" title="1">{
                        // If the owner changes, update owner's owned elements.
                        currentOwnerID := currentEntry.changedElement.GetOwningConceptID(hl)
                        priorOwnerID := currentEntry.priorState.GetOwningConceptID(hl)
                        if currentOwnerID != priorOwnerID </span><span class="cov8" title="1">{
                                if currentOwnerID != "" </span><span class="cov8" title="1">{
                                        uOfD.ownedIDsMap.AddMappedValue(currentOwnerID, currentID)
                                }</span>
                                <span class="cov8" title="1">if priorOwnerID != "" </span><span class="cov8" title="1">{
                                        uOfD.ownedIDsMap.RemoveMappedValue(priorOwnerID, currentID)
                                }</span>
                        }
                        // Update listeners. If this is a reference or refinement pointing to another element, remove this element from the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.changedElement.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                currentReferencedElementID := currentEntry.changedElement.(*reference).ReferencedConceptID
                                priorReferencedElementID := currentEntry.priorState.(*reference).ReferencedConceptID
                                if currentReferencedElementID != priorReferencedElementID </span><span class="cov8" title="1">{
                                        if currentReferencedElementID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentReferencedElementID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorReferencedElementID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorReferencedElementID, currentID)
                                        }</span>
                                }
                        case *refinement:<span class="cov8" title="1">
                                currentAbstractID := currentEntry.changedElement.(*refinement).AbstractConceptID
                                priorAbstractID := currentEntry.priorState.(*refinement).AbstractConceptID
                                if currentAbstractID != priorAbstractID </span><span class="cov8" title="1">{
                                        if currentAbstractID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentAbstractID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorAbstractID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorAbstractID, currentID)
                                        }</span>
                                }
                                <span class="cov8" title="1">currentRefinedID := currentEntry.changedElement.(*refinement).RefinedConceptID
                                priorRefinedID := currentEntry.priorState.(*refinement).RefinedConceptID
                                if currentRefinedID != priorRefinedID </span><span class="cov8" title="1">{
                                        if currentRefinedID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentRefinedID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorRefinedID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorRefinedID, currentID)
                                        }</span>
                                }
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">currentURI := currentEntry.changedElement.GetURI(hl)
                        priorURI := currentEntry.priorState.GetURI(hl)
                        if currentURI != priorURI </span><span class="cov8" title="1">{
                                if currentURI != "" </span><span class="cov8" title="1">{
                                        uOfD.uriUUIDMap.DeleteEntry(currentURI)
                                }</span>
                                <span class="cov8" title="1">if priorURI != "" </span><span class="cov8" title="1">{
                                        uOfD.uriUUIDMap.SetEntry(priorURI, currentID)
                                }</span>
                        }
                        <span class="cov8" title="1">clone := clone(currentEntry.changedElement, hl)
                        priorOwnedElements := undoMgr.uOfD.ownedIDsMap.GetMappedValues(currentID).Clone()
                        priorListeners := undoMgr.uOfD.listenersMap.GetMappedValues(currentID).Clone()
                        undoEntry := newUndoRedoStackEntry(Change, clone, priorOwnedElements, priorListeners, currentEntry.changedElement)
                        undoMgr.restoreState(currentEntry.priorState, currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)
                        undoMgr.undoStack.Push(undoEntry)</span>
                }
        }
}

// restoreState is used as part of the undo process. It changes the currentState object
// to have the priorState.
func (undoMgr *undoManager) restoreState(priorState Element, currentState Element, hl *Transaction) <span class="cov8" title="1">{
        if undoMgr.debugUndo </span><span class="cov0" title="0">{
                log.Printf("Restoring State")
                log.Printf("   Current state:")
                Print(currentState, "      ", hl)
                log.Printf("   Prior state")
                Print(priorState, "      ", hl)
        }</span>
        <span class="cov8" title="1">switch currentState.(type) </span>{
        case *element:<span class="cov8" title="1">
                currentState.(*element).cloneAttributes(priorState.(*element), hl)</span>
        case *reference:<span class="cov8" title="1">
                currentState.(*reference).cloneAttributes(priorState.(*reference), hl)</span>
        case *literal:<span class="cov8" title="1">
                currentState.(*literal).cloneAttributes(priorState.(*literal), hl)</span>
        case *refinement:<span class="cov8" title="1">
                currentState.(*refinement).cloneAttributes(priorState.(*refinement), hl)</span>
        default:<span class="cov0" title="0">
                log.Printf("restoreState called with unhandled type %T\n", currentState)</span>
        }
}

// func (undoMgr *undoManager) setDebugUndo(newSetting bool) {
//         undoMgr.TraceableLock()
//         defer undoMgr.TraceableUnlock()
//         undoMgr.debugUndo = newSetting
// }

func (undoMgr *undoManager) setRecordingUndo(newSetting bool) <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        undoMgr.recordingUndo = newSetting
}</span>

func (undoMgr *undoManager) TraceableLock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to lock Undo Manager %p\n", undoMgr)
        // }
        undoMgr.Lock()
}</span>

func (undoMgr *undoManager) TraceableUnlock() <span class="cov8" title="1">{
        // if TraceLocks {
        //         log.Printf("About to unlock Undo Manager %p\n", undoMgr)
        // }
        undoMgr.Unlock()
}</span>

func (undoMgr *undoManager) undo(hl *Transaction) <span class="cov8" title="1">{
        undoMgr.TraceableLock()
        defer undoMgr.TraceableUnlock()
        uOfD := undoMgr.uOfD
        firstEntry := true
        for len(undoMgr.undoStack) &gt; 0 </span><span class="cov8" title="1">{
                currentEntry := undoMgr.undoStack.Pop()
                var currentID string
                if currentEntry.changedElement != nil </span><span class="cov8" title="1">{
                        currentID = currentEntry.changedElement.GetConceptID(hl)
                }</span>
                <span class="cov8" title="1">if currentEntry.changeType == Marker </span><span class="cov8" title="1">{
                        if firstEntry </span><span class="cov8" title="1">{
                                undoMgr.redoStack.Push(currentEntry)
                        }</span> else<span class="cov8" title="1"> {
                                // Put it back on the undo stack
                                undoMgr.undoStack.Push(currentEntry)
                                return
                        }</span>
                } else<span class="cov8" title="1"> if currentEntry.changeType == Creation </span><span class="cov8" title="1">{
                        // Update owner's owned elements. Since we are undoing a creation, if the changed element has an owner
                        // we must remove the current element from the owner's ownedElements
                        if currentEntry.changedElement.GetOwningConceptID(hl) != "" </span><span class="cov0" title="0">{
                                uOfD.ownedIDsMap.RemoveMappedValue(currentEntry.changedElement.GetOwningConceptID(hl), currentID)
                        }</span>
                        // Update listeners. If this is a reference or refinement pointing to another element, remove this element from the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.changedElement.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                referencedElementID := currentEntry.changedElement.(*reference).ReferencedConceptID
                                if referencedElementID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.RemoveMappedValue(referencedElementID, currentID)
                                }</span>
                        case *refinement:<span class="cov8" title="1">
                                abstractID := currentEntry.changedElement.(*refinement).AbstractConceptID
                                if abstractID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.RemoveMappedValue(abstractID, currentID)
                                }</span>
                                <span class="cov8" title="1">refinedID := currentEntry.changedElement.(*refinement).RefinedConceptID
                                if refinedID != "" </span><span class="cov0" title="0">{
                                        uOfD.listenersMap.RemoveMappedValue(refinedID, currentID)
                                }</span>
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">uri := currentEntry.changedElement.GetURI(hl)
                        if uri != "" </span><span class="cov8" title="1">{
                                uOfD.uriUUIDMap.DeleteEntry(uri)
                        }</span>
                        <span class="cov8" title="1">undoMgr.redoStack.Push(currentEntry)
                        uOfD.removeElementForUndo(currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)</span>
                } else<span class="cov8" title="1"> if currentEntry.changeType == Deletion </span><span class="cov8" title="1">{
                        // Update owner's owned elements. Since we are undoing a deletion, if the changed element has an owner
                        // we must add the current element from the owner's ownedElements
                        if currentEntry.priorState.GetOwningConceptID(hl) != "" </span><span class="cov8" title="1">{
                                uOfD.ownedIDsMap.AddMappedValue(currentEntry.priorState.GetOwningConceptID(hl), currentEntry.priorState.GetConceptID(hl))
                        }</span>
                        // Update listeners. If this is a reference or refinement pointing to another element, add this element to the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.priorState.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                referencedElementID := currentEntry.priorState.(*reference).ReferencedConceptID
                                if referencedElementID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.AddMappedValue(referencedElementID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                        case *refinement:<span class="cov8" title="1">
                                abstractID := currentEntry.priorState.(*refinement).AbstractConceptID
                                if abstractID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.AddMappedValue(abstractID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                                <span class="cov8" title="1">refinedID := currentEntry.priorState.(*refinement).RefinedConceptID
                                if refinedID != "" </span><span class="cov8" title="1">{
                                        uOfD.listenersMap.AddMappedValue(refinedID, currentEntry.priorState.GetConceptID(hl))
                                }</span>
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">uri := currentEntry.priorState.GetURI(hl)
                        if uri != "" </span><span class="cov8" title="1">{
                                uOfD.uriUUIDMap.SetEntry(uri, currentID)
                        }</span>
                        <span class="cov8" title="1">undoMgr.restoreState(currentEntry.priorState, currentEntry.changedElement, hl)
                        undoMgr.redoStack.Push(currentEntry)
                        uOfD.addElementForUndo(currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)</span>
                } else<span class="cov8" title="1"> if currentEntry.changeType == Change </span><span class="cov8" title="1">{
                        // If the owner changes, update owner's owned elements.
                        currentOwnerID := currentEntry.changedElement.GetOwningConceptID(hl)
                        priorOwnerID := currentEntry.priorState.GetOwningConceptID(hl)
                        if currentOwnerID != priorOwnerID </span><span class="cov8" title="1">{
                                if currentOwnerID != "" </span><span class="cov8" title="1">{
                                        uOfD.ownedIDsMap.RemoveMappedValue(currentOwnerID, currentID)
                                }</span>
                                <span class="cov8" title="1">if priorOwnerID != "" </span><span class="cov8" title="1">{
                                        uOfD.ownedIDsMap.AddMappedValue(priorOwnerID, currentID)
                                }</span>
                        }
                        // Update listeners. If this is a reference or refinement pointing to another element, remove this element from the other element's listener's set
                        <span class="cov8" title="1">switch currentEntry.changedElement.(type) </span>{
                        case *reference:<span class="cov8" title="1">
                                currentReferencedElementID := currentEntry.changedElement.(*reference).ReferencedConceptID
                                priorReferencedElementID := currentEntry.priorState.(*reference).ReferencedConceptID
                                if currentReferencedElementID != priorReferencedElementID </span><span class="cov8" title="1">{
                                        if currentReferencedElementID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentReferencedElementID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorReferencedElementID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorReferencedElementID, currentID)
                                        }</span>
                                }
                        case *refinement:<span class="cov8" title="1">
                                currentAbstractID := currentEntry.changedElement.(*refinement).AbstractConceptID
                                priorAbstractID := currentEntry.priorState.(*refinement).AbstractConceptID
                                if currentAbstractID != priorAbstractID </span><span class="cov8" title="1">{
                                        if currentAbstractID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentAbstractID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorAbstractID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorAbstractID, currentID)
                                        }</span>
                                }
                                <span class="cov8" title="1">currentRefinedID := currentEntry.changedElement.(*refinement).RefinedConceptID
                                priorRefinedID := currentEntry.priorState.(*refinement).RefinedConceptID
                                if currentRefinedID != priorRefinedID </span><span class="cov8" title="1">{
                                        if currentRefinedID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.RemoveMappedValue(currentRefinedID, currentID)
                                        }</span>
                                        <span class="cov8" title="1">if priorRefinedID != "" </span><span class="cov8" title="1">{
                                                uOfD.listenersMap.AddMappedValue(priorRefinedID, currentID)
                                        }</span>
                                }
                        }
                        // Update the uriUUIDMap
                        <span class="cov8" title="1">currentURI := currentEntry.changedElement.GetURI(hl)
                        priorURI := currentEntry.priorState.GetURI(hl)
                        if currentURI != priorURI </span><span class="cov8" title="1">{
                                if currentURI != "" </span><span class="cov8" title="1">{
                                        uOfD.uriUUIDMap.DeleteEntry(currentURI)
                                }</span>
                                <span class="cov8" title="1">if priorURI != "" </span><span class="cov8" title="1">{
                                        uOfD.uriUUIDMap.SetEntry(priorURI, currentID)
                                }</span>
                        }
                        <span class="cov8" title="1">clone := clone(currentEntry.changedElement, hl)
                        priorOwnedElements := uOfD.ownedIDsMap.GetMappedValues(currentID).Clone()
                        priorListeners := uOfD.listenersMap.GetMappedValues(currentID).Clone()
                        redoEntry := newUndoRedoStackEntry(Change, clone, priorOwnedElements, priorListeners, currentEntry.changedElement)
                        undoMgr.restoreState(currentEntry.priorState, currentEntry.changedElement, hl)
                        uOfD.ownedIDsMap.SetMappedValues(currentID, currentEntry.priorOwnedElements)
                        uOfD.listenersMap.SetMappedValues(currentID, currentEntry.priorListeners)
                        undoMgr.redoStack.Push(redoEntry)</span>
                }
                <span class="cov8" title="1">firstEntry = false</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

type undoStack []*undoRedoStackEntry

func (s undoStack) Empty() bool <span class="cov0" title="0">{
        return len(s) == 0
}</span>

func (s undoStack) Peek() *undoRedoStackEntry <span class="cov0" title="0">{
        return s[len(s)-1]
}</span>

func (s *undoStack) Push(entry *undoRedoStackEntry) <span class="cov8" title="1">{
        (*s) = append((*s), entry)
}</span>

func (s *undoStack) Pop() *undoRedoStackEntry <span class="cov8" title="1">{
        entry := (*s)[len(*s)-1]
        (*s) = (*s)[:len(*s)-1]
        return entry
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package core

import mapset "github.com/deckarep/golang-set"

// UndoChangeType identifies the type of undo change
type UndoChangeType int

const (
        // Marker marks the point on the stack at which an undo or redo operation will stop
        Marker UndoChangeType = iota
        // Creation marks the creation of a new Element
        Creation
        // Deletion marks the deletion of an Element
        Deletion
        // Change marks a change to an element
        Change
)

type undoRedoStackEntry struct {
        changeType         UndoChangeType
        priorState         Element
        priorOwnedElements mapset.Set
        priorListeners     mapset.Set
        changedElement     Element
}

func newUndoRedoStackEntry(changeType UndoChangeType, priorState Element, priorOwnedElements mapset.Set, priorListeners mapset.Set, changedElement Element) *undoRedoStackEntry <span class="cov8" title="1">{
        var entry undoRedoStackEntry
        entry.changeType = changeType
        entry.priorState = priorState
        entry.priorOwnedElements = priorOwnedElements
        entry.priorListeners = priorListeners
        entry.changedElement = changedElement
        return &amp;entry
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package core

import (
        "encoding/json"
        "fmt"
        "log"
        "net/url"
        "reflect"
        "strconv"

        "github.com/pkg/errors"

        mapset "github.com/deckarep/golang-set"
        uuid "github.com/satori/go.uuid"
)

// UniverseOfDiscourse represents the scope of relevant concepts
type UniverseOfDiscourse struct {
        // element
        computeFunctions functions
        executedCalls    chan *functionCallRecord
        undoManager      *undoManager
        uriUUIDMap       *StringStringMap
        uuidElementMap   *StringElementMap
        ownedIDsMap      *OneToNStringMap
        listenersMap     *OneToNStringMap
        abstractionsMap  *OneToNStringMap
        observers        mapset.Set
}

// NewUniverseOfDiscourse creates and initializes a new UniverseOfDiscourse
func NewUniverseOfDiscourse() *UniverseOfDiscourse <span class="cov8" title="1">{
        var uOfD UniverseOfDiscourse
        uOfD.observers = mapset.NewSet()
        uOfD.computeFunctions = make(map[string][]crlExecutionFunction)
        uOfD.undoManager = newUndoManager(&amp;uOfD)
        uOfD.uriUUIDMap = NewStringStringMap()
        uOfD.uuidElementMap = NewStringElementMap()
        uOfD.ownedIDsMap = NewOneToNStringMap()
        uOfD.listenersMap = NewOneToNStringMap()
        uOfD.abstractionsMap = NewOneToNStringMap()
        hl := uOfD.NewTransaction()
        buildCoreDomain(&amp;uOfD, hl)
        hl.ReleaseLocks()
        return &amp;uOfD
}</span>

func (uOfDPtr *UniverseOfDiscourse) addElement(el Element, inRecovery bool, hl *Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscource addElement() failed because element was nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(el)
        uOfDPtr.undoManager.markNewElement(el, hl)
        uuid := el.GetConceptID(hl)
        if uuid == "" </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscource addElement() failed because UUID was nil")
        }</span>
        <span class="cov8" title="1">uOfDPtr.uuidElementMap.SetEntry(el.getConceptIDNoLock(), el)
        uri := el.GetURI(hl)
        if uri != "" </span><span class="cov8" title="1">{
                uOfDPtr.uriUUIDMap.SetEntry(uri, uuid)
        }</span>
        <span class="cov8" title="1">ownerID := el.GetOwningConceptID(hl)
        if ownerID != "" </span><span class="cov8" title="1">{
                uOfDPtr.ownedIDsMap.AddMappedValue(ownerID, uuid)
        }</span>
        // Add element to all listener's lists
        <span class="cov8" title="1">switch typedEl := el.(type) </span>{
        case *reference:<span class="cov8" title="1">
                ref := typedEl
                referencedConceptID := ref.GetReferencedConceptID(hl)
                if referencedConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.AddMappedValue(referencedConceptID, uuid)
                }</span>
        case *refinement:<span class="cov8" title="1">
                ref := el.(*refinement)
                abstractConceptID := ref.GetAbstractConceptID(hl)
                if abstractConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.AddMappedValue(abstractConceptID, uuid)
                }</span>
                <span class="cov8" title="1">refinedConceptID := ref.GetRefinedConceptID(hl)
                if refinedConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.AddMappedValue(refinedConceptID, uuid)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (uOfDPtr *UniverseOfDiscourse) addElementForUndo(el Element, hl *Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscource addElementForUndo() failed because element was nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(el)
        if uOfDPtr.undoManager.debugUndo </span><span class="cov0" title="0">{
                log.Printf("Adding element for undo, id: %s\n", el.GetConceptID(hl))
                Print(el, "Added Element: ", hl)
        }</span>
        <span class="cov8" title="1">uOfDPtr.uuidElementMap.SetEntry(el.GetConceptID(hl), el)
        uri := el.GetURI(hl)
        if uri != "" </span><span class="cov8" title="1">{
                uOfDPtr.uriUUIDMap.SetEntry(uri, el.GetConceptID(hl))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddFunction registers a function with the indicated uri
func (uOfDPtr *UniverseOfDiscourse) AddFunction(uri string, function crlExecutionFunction) <span class="cov8" title="1">{
        uOfDPtr.computeFunctions[string(uri)] = append(uOfDPtr.computeFunctions[string(uri)], function)
}</span>

func (uOfDPtr *UniverseOfDiscourse) changeURIForElement(el Element, oldURI string, newURI string) error <span class="cov8" title="1">{
        if oldURI != "" &amp;&amp; uOfDPtr.uriUUIDMap.GetEntry(oldURI) == el.getConceptIDNoLock() </span><span class="cov8" title="1">{
                uOfDPtr.uriUUIDMap.DeleteEntry(oldURI)
        }</span>
        <span class="cov8" title="1">if newURI != "" </span><span class="cov8" title="1">{
                if uOfDPtr.uriUUIDMap.GetEntry(newURI) != "" </span><span class="cov0" title="0">{
                        return errors.New("Attempted to assign a URI that is already in use")
                }</span>
                <span class="cov8" title="1">uOfDPtr.uriUUIDMap.SetEntry(newURI, el.getConceptIDNoLock())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Clone makes an exact copy of the UniverseOfDiscourse and all its contents except for the undo/redo stack. All Elements are new objects,
// but all the identifiers are retained from the original uOfD.
func (uOfDPtr *UniverseOfDiscourse) Clone(hl *Transaction) *UniverseOfDiscourse <span class="cov8" title="1">{
        newUofD := NewUniverseOfDiscourse()

        // uOfD.computeFunctions = make(map[string][]crlExecutionFunction)
        var uri string
        var functionArray []crlExecutionFunction
        for uri, functionArray = range uOfDPtr.computeFunctions </span><span class="cov8" title="1">{
                // Housekeeping functions are already present in a new uOfD
                if uri != "http://activeCrl.com/core/coreHousekeeping" </span><span class="cov8" title="1">{
                        newUofD.computeFunctions[uri] = append(newUofD.computeFunctions[uri], functionArray...)
                }</span>
        }

        // uOfD.undoManager = newUndoManager(&amp;uOfD)
        // Nothing to do here

        // uOfD.uriUUIDMap = NewStringStringMap()
        <span class="cov8" title="1">for uri, uuid := range uOfDPtr.uriUUIDMap.CopyMap() </span><span class="cov8" title="1">{
                newUofD.uriUUIDMap.SetEntry(uri, uuid)
        }</span>

        // uOfD.uuidElementMap = NewStringElementMap()
        <span class="cov8" title="1">for id, el := range uOfDPtr.uuidElementMap.CopyMap() </span><span class="cov8" title="1">{
                switch el.(type) </span>{
                case *element, *literal, *reference, *refinement:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                newElement := clone(el, hl)
                                newUofD.uuidElementMap.SetEntry(id, newElement)
                        }</span>
                }
        }
        // newUofD.uuidElementMap.SetEntry(newUofD.ConceptID, newUofD)

        // uOfD.ownedIDsMap = NewOneToNStringMap()
        <span class="cov8" title="1">for key, strings := range uOfDPtr.ownedIDsMap.CopyMap() </span><span class="cov8" title="1">{
                newUofD.ownedIDsMap.SetMappedValues(key, strings)
        }</span>

        // uOfD.listenersMap = NewOneToNStringMap()
        <span class="cov8" title="1">for key, strings := range uOfDPtr.listenersMap.CopyMap() </span><span class="cov8" title="1">{
                newUofD.listenersMap.SetMappedValues(key, strings)
        }</span>

        // uOfD.abstractionsMap = NewOneToNStringMap()
        <span class="cov8" title="1">for key, strings := range uOfDPtr.abstractionsMap.CopyMap() </span><span class="cov0" title="0">{
                newUofD.abstractionsMap.SetMappedValues(key, strings)
        }</span>

        <span class="cov8" title="1">return newUofD</span>
}

// CreateReplicateAsRefinement replicates the indicated Element and all of its descendent Elements
// except that descendant Refinements are not replicated.
// For each replicated Element, a Refinement is created with the abstractElement being the original and the refinedElement
// being the replica. The root replicated element is returned.
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateAsRefinement(original Element, hl *Transaction, newURI ...string) (Element, error) <span class="cov8" title="1">{
        uri := ""
        if len(newURI) &gt; 0 </span><span class="cov8" title="1">{
                uri = newURI[0]
        }</span>
        <span class="cov8" title="1">var replicate Element
        var err error
        switch original.(type) </span>{
        case Literal:<span class="cov8" title="1">
                replicate, err = uOfDPtr.NewLiteral(hl, uri)</span>
        case Reference:<span class="cov8" title="1">
                replicate, err = uOfDPtr.NewReference(hl, uri)</span>
        case Refinement:<span class="cov8" title="1">
                replicate, err = uOfDPtr.NewRefinement(hl, uri)</span>
        case Element:<span class="cov8" title="1">
                replicate, err = uOfDPtr.NewElement(hl, uri)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = uOfDPtr.replicateAsRefinement(original, replicate, hl, newURI...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return replicate, nil</span>
}

// CreateReplicateAsRefinementFromURI replicates the Element indicated by the URI
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateAsRefinementFromURI(originalURI string, hl *Transaction, newURI ...string) (Element, error) <span class="cov8" title="1">{
        original := uOfDPtr.GetElementWithURI(originalURI)
        if original == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("in CreateReplicateAsRefinementFromURI Element with uri %s not found", originalURI)
        }</span>
        <span class="cov8" title="1">return uOfDPtr.CreateReplicateAsRefinement(original, hl, newURI...)</span>
}

// CreateReplicateLiteralAsRefinement replicates the supplied Literal and makes all elements of the replicate
// refinements of the original elements
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateLiteralAsRefinement(original Literal, hl *Transaction, newURI ...string) (Literal, error) <span class="cov8" title="1">{
        uri := ""
        if len(newURI) &gt; 0 </span><span class="cov8" title="1">{
                uri = newURI[0]
        }</span>
        <span class="cov8" title="1">replicate, err := uOfDPtr.NewLiteral(hl, uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = uOfDPtr.replicateAsRefinement(original, replicate, hl, uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return replicate, nil</span>
}

// CreateReplicateLiteralAsRefinementFromURI replicates the Literal indicated by the URI
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateLiteralAsRefinementFromURI(originalURI string, hl *Transaction, newURI ...string) (Literal, error) <span class="cov8" title="1">{
        original := uOfDPtr.GetLiteralWithURI(originalURI)
        if original == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("in CreateReplicateLiteralAsRefinementFromURI Element with uri %s not found", originalURI)
        }</span>
        <span class="cov8" title="1">return uOfDPtr.CreateReplicateLiteralAsRefinement(original, hl, newURI...)</span>
}

// CreateReplicateReferenceAsRefinement replicates the supplied reference and makes all elements of the replicate
// refinements of the original elements
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateReferenceAsRefinement(original Reference, hl *Transaction, newURI ...string) (Reference, error) <span class="cov8" title="1">{
        uri := ""
        if len(newURI) &gt; 0 </span><span class="cov0" title="0">{
                uri = newURI[0]
        }</span>
        <span class="cov8" title="1">replicate, err := uOfDPtr.NewReference(hl, uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = uOfDPtr.replicateAsRefinement(original, replicate, hl, uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return replicate, nil</span>
}

// CreateReplicateReferenceAsRefinementFromURI replicates the Reference indicated by the URI
func (uOfDPtr *UniverseOfDiscourse) CreateReplicateReferenceAsRefinementFromURI(originalURI string, hl *Transaction, newURI ...string) (Reference, error) <span class="cov8" title="1">{
        original := uOfDPtr.GetReferenceWithURI(originalURI)
        if original == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("in CreateReplicateAsRefinementFromURI Element with uri %s not found", originalURI)
        }</span>
        <span class="cov8" title="1">return uOfDPtr.CreateReplicateReferenceAsRefinement(original, hl, newURI...)</span>
}

func (uOfDPtr *UniverseOfDiscourse) findFunctions(element Element, notification *ChangeNotification, hl *Transaction) []string <span class="cov8" title="1">{
        var functionIdentifiers []string
        if element == nil </span><span class="cov0" title="0">{
                return functionIdentifiers
        }</span>
        // Now find functions associated with self and abstractions
        <span class="cov8" title="1">selfAndAbstractions := make(map[string]Element)
        selfAndAbstractions[element.getConceptIDNoLock()] = element
        element.FindAbstractions(selfAndAbstractions, hl)
        for _, candidate := range selfAndAbstractions </span><span class="cov8" title="1">{
                uri := candidate.GetURI(hl)
                if uri != "" </span><span class="cov8" title="1">{
                        functions := uOfDPtr.computeFunctions[uri]
                        if functions != nil </span><span class="cov8" title="1">{
                                functionIdentifiers = append(functionIdentifiers, uri)
                        }</span>
                }
        }
        <span class="cov8" title="1">return functionIdentifiers</span>
}

func (uOfDPtr *UniverseOfDiscourse) deleteElement(el Element, deletedElements mapset.Set, hl *Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscource removeElement failed elcause Element was nil")
        }</span>
        <span class="cov8" title="1">hl.WriteLockElement(el)
        beforeState, err := NewConceptState(el)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.deleteElement failed")
        }</span>
        <span class="cov8" title="1">uOfDPtr.undoManager.markRemovedElement(el, hl)
        uuid := el.GetConceptID(hl)
        uri := el.GetURI(hl)
        if uri != "" </span><span class="cov8" title="1">{
                uOfDPtr.uriUUIDMap.DeleteEntry(uri)
        }</span>
        // Remove element from owner's child list
        <span class="cov8" title="1">ownerID := el.GetOwningConceptID(hl)
        if ownerID != "" </span><span class="cov8" title="1">{
                el.SetOwningConceptID("", hl)
        }</span>
        <span class="cov8" title="1">it := uOfDPtr.listenersMap.GetMappedValues(uuid).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                listener := uOfDPtr.GetElement(id.(string))
                switch typedListener := listener.(type) </span>{
                case Reference:<span class="cov8" title="1">
                        typedListener.SetReferencedConcept(nil, NoAttribute, hl)</span>
                case Refinement:<span class="cov8" title="1">
                        if typedListener.GetAbstractConcept(hl) == el </span><span class="cov0" title="0">{
                                typedListener.SetAbstractConcept(nil, hl)
                        }</span> else<span class="cov8" title="1"> if typedListener.GetRefinedConcept(hl) == el </span><span class="cov8" title="1">{
                                typedListener.SetRefinedConcept(nil, hl)
                        }</span>
                }
        }
        // Spread the news
        <span class="cov8" title="1">conceptRemovedNotification := uOfDPtr.newUofDConceptRemovedNotification(beforeState, hl)
        err = uOfDPtr.NotifyUofDObservers(conceptRemovedNotification, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.deleteElement failed")
        }</span>
        <span class="cov8" title="1">err = el.notifyObservers(conceptRemovedNotification, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.deleteElement failed")
        }</span>
        // Remove element from all listener's lists
        <span class="cov8" title="1">switch typedEl := el.(type) </span>{
        case *reference:<span class="cov8" title="1">
                referencedConceptID := typedEl.GetReferencedConceptID(hl)
                if referencedConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.RemoveMappedValue(referencedConceptID, uuid)
                }</span>
        case *refinement:<span class="cov8" title="1">
                abstractConceptID := typedEl.GetAbstractConceptID(hl)
                if abstractConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.RemoveMappedValue(abstractConceptID, uuid)
                }</span>
                <span class="cov8" title="1">refinedConceptID := typedEl.GetRefinedConceptID(hl)
                if refinedConceptID != "" </span><span class="cov8" title="1">{
                        uOfDPtr.listenersMap.RemoveMappedValue(refinedConceptID, uuid)
                }</span>
        }
        <span class="cov8" title="1">uOfDPtr.listenersMap.DeleteKey(uuid)
        uOfDPtr.abstractionsMap.DeleteKey(uuid)
        uOfDPtr.ownedIDsMap.DeleteKey(uuid)
        uOfDPtr.uuidElementMap.DeleteEntry(uuid)
        // Finally, remove from the universe of discourse
        el.setUniverseOfDiscourse(nil, hl)
        return nil</span>
}

// DeleteElement removes a single element and its descentants from the uOfD. Pointers to the elements from other elements are set to nil.
func (uOfDPtr *UniverseOfDiscourse) DeleteElement(element Element, hl *Transaction) error <span class="cov8" title="1">{
        id := element.GetConceptID(hl)
        elements := mapset.NewSet(id)
        uOfDPtr.GetConceptsOwnedConceptIDsRecursively(id, elements, hl)
        return uOfDPtr.DeleteElements(elements, hl)
}</span>

// DeleteElements removes the elements from the uOfD. Pointers to the elements from elements not being deleted are set to nil.
func (uOfDPtr *UniverseOfDiscourse) DeleteElements(elements mapset.Set, hl *Transaction) error <span class="cov8" title="1">{
        it := elements.Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                el := uOfDPtr.GetElement(id.(string))
                if el.GetIsCore(hl) </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.New("UniverseOfDiscourse.DeleteElements called on a CRL core concept")
                }</span>
                <span class="cov8" title="1">if el.GetUniverseOfDiscourse(hl) != uOfDPtr </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.New("UniverseOfDiscourse.DeleteElements called on an Element in a different UofD")
                }</span>
                <span class="cov8" title="1">if el.IsReadOnly(hl) </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.New("UniverseOfDiscourse.DeleteElements called on read-only Element")
                }</span>
        }
        <span class="cov8" title="1">it2 := elements.Iterator()
        for id := range it2.C </span><span class="cov8" title="1">{
                el := uOfDPtr.GetElement(id.(string))
                if el != nil </span><span class="cov8" title="1">{
                        hl.WriteLockElement(el)
                        uOfDPtr.preChange(el, hl)
                        uOfDPtr.deleteElement(el, elements, hl)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Deregister removes the registration of an Observer
func (uOfDPtr *UniverseOfDiscourse) Deregister(observer Observer) error <span class="cov0" title="0">{
        uOfDPtr.observers.Remove(observer)
        return nil
}</span>

func (uOfDPtr *UniverseOfDiscourse) generateConceptID(uri ...string) (string, error) <span class="cov8" title="1">{
        var conceptID string
        if len(uri) == 0 || (len(uri) == 1 &amp;&amp; uri[0] == "") </span><span class="cov8" title="1">{
                newUUID, err := uuid.NewV4()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "failure in UniverseOfDiscourse.generateConceptID")
                }</span>
                <span class="cov8" title="1">conceptID = newUUID.String()</span>
        } else<span class="cov8" title="1"> {
                if len(uri) == 1 </span><span class="cov8" title="1">{
                        _, err := url.ParseRequestURI(uri[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return "", errors.New("Invalid URI provided for initializing Element")
                        }</span>
                        <span class="cov8" title="1">conceptID = uuid.NewV5(uuid.NamespaceURL, uri[0]).String()</span>
                } else<span class="cov0" title="0"> {
                        return "", errors.New("Invalid URI provided for initializing Element")
                }</span>
        }
        <span class="cov8" title="1">return conceptID, nil</span>
}

// getComputeFunctions returns a pointer to the compute functions. It is intended for the exclusive use of the
// FunctionCallManager
// func (uOfDPtr *UniverseOfDiscourse) getComputeFunctions() *functions {
//         return &amp;uOfDPtr.computeFunctions
// }

// GetElement returns the Element with the conceptID
func (uOfDPtr *UniverseOfDiscourse) GetElement(conceptID string) Element <span class="cov8" title="1">{
        return uOfDPtr.uuidElementMap.GetEntry(conceptID)
}</span>

// GetElements returns the Elements in the uOfD mapped by their ConceptIDs
func (uOfDPtr *UniverseOfDiscourse) GetElements() map[string]Element <span class="cov8" title="1">{
        return uOfDPtr.uuidElementMap.CopyMap()
}</span>

// GetElementWithURI returns the Element with the given URI
func (uOfDPtr *UniverseOfDiscourse) GetElementWithURI(uri string) Element <span class="cov8" title="1">{
        return uOfDPtr.GetElement(uOfDPtr.uriUUIDMap.GetEntry(uri))
}</span>

func (uOfDPtr *UniverseOfDiscourse) getExecutedCalls() chan *functionCallRecord <span class="cov8" title="1">{
        return uOfDPtr.executedCalls
}</span>

// getFunctions returns the array of functions associatee with the given URI
func (uOfDPtr *UniverseOfDiscourse) getFunctions(uri string) []crlExecutionFunction <span class="cov8" title="1">{
        return uOfDPtr.computeFunctions[string(uri)]
}</span>

// GetIDForURI returns a V5 UUID derived from the given URI. If the given URI
// is not valid it returns the empty string.
func (uOfDPtr *UniverseOfDiscourse) GetIDForURI(uri string) string <span class="cov0" title="0">{
        _, err := url.ParseRequestURI(uri)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return uuid.NewV5(uuid.NamespaceURL, uri).String()</span>
}

// getListenerIDs returns the set of listener IDs for the indicated ID
func (uOfDPtr *UniverseOfDiscourse) getListenerIDs(id string) mapset.Set <span class="cov8" title="1">{
        return uOfDPtr.listenersMap.GetMappedValues(id)
}</span>

// GetLiteral returns the literal with the indicated ID (if found)
func (uOfDPtr *UniverseOfDiscourse) GetLiteral(conceptID string) Literal <span class="cov8" title="1">{
        el := uOfDPtr.GetElement(conceptID)
        switch typedEl := el.(type) </span>{
        case *literal:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetLiteralWithURI returns the literal with the indicated URI (if found)
func (uOfDPtr *UniverseOfDiscourse) GetLiteralWithURI(uri string) Literal <span class="cov8" title="1">{
        el := uOfDPtr.GetElementWithURI(uri)
        switch typedEl := el.(type) </span>{
        case Literal:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetConceptsOwnedConceptIDs returns the set of owned concepts for the indicated ID
func (uOfDPtr *UniverseOfDiscourse) GetConceptsOwnedConceptIDs(id string) mapset.Set <span class="cov8" title="1">{
        return uOfDPtr.ownedIDsMap.GetMappedValues(id)
}</span>

// GetConceptsOwnedConceptIDsRecursively returns the IDs of owned concepts
func (uOfDPtr *UniverseOfDiscourse) GetConceptsOwnedConceptIDsRecursively(rootID string, descendants mapset.Set, hl *Transaction) <span class="cov8" title="1">{
        it := uOfDPtr.ownedIDsMap.GetMappedValues(rootID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                descendants.Add(id.(string))
                uOfDPtr.GetConceptsOwnedConceptIDsRecursively(id.(string), descendants, hl)
        }</span>
}

// GetReference returns the reference with the indicated ID (if found)
func (uOfDPtr *UniverseOfDiscourse) GetReference(conceptID string) Reference <span class="cov8" title="1">{
        el := uOfDPtr.GetElement(conceptID)
        switch typedEl := el.(type) </span>{
        case *reference:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetReferenceWithURI returns the reference with the indicated URI (if found)
func (uOfDPtr *UniverseOfDiscourse) GetReferenceWithURI(uri string) Reference <span class="cov8" title="1">{
        el := uOfDPtr.GetElementWithURI(uri)
        switch typedEl := el.(type) </span>{
        case *reference:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRefinement returns the refinement with the indicated ID (if found)
func (uOfDPtr *UniverseOfDiscourse) GetRefinement(conceptID string) Refinement <span class="cov8" title="1">{
        el := uOfDPtr.GetElement(conceptID)
        switch typedEl := el.(type) </span>{
        case *refinement:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRefinementWithURI returns the refinement with the indicated URI (if found)
func (uOfDPtr *UniverseOfDiscourse) GetRefinementWithURI(uri string) Refinement <span class="cov8" title="1">{
        el := uOfDPtr.GetElementWithURI(uri)
        switch typedEl := el.(type) </span>{
        case *refinement:<span class="cov8" title="1">
                return typedEl</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRootElements returns all elements that do not have owners
func (uOfDPtr *UniverseOfDiscourse) GetRootElements(hl *Transaction) map[string]Element <span class="cov8" title="1">{
        allElements := uOfDPtr.GetElements()
        rootElements := make(map[string]Element)
        for id, el := range allElements </span><span class="cov8" title="1">{
                if el.GetOwningConceptID(hl) == "" </span><span class="cov8" title="1">{
                        rootElements[id] = el
                }</span>
        }
        <span class="cov8" title="1">return rootElements</span>
}

func (uOfDPtr *UniverseOfDiscourse) getURIUUIDMap() *StringStringMap <span class="cov8" title="1">{
        return uOfDPtr.uriUUIDMap
}</span>

// IsEquivalent returns true if all of the root elements in the uOfD are recursively equivalent
func (uOfDPtr *UniverseOfDiscourse) IsEquivalent(hl1 *Transaction, uOfD2 *UniverseOfDiscourse, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var printEquivalenceExceptions bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                printEquivalenceExceptions = printExceptions[0]
        }</span>
        // Functions
        // uOfD.computeFunctions = make(map[string][]crlExecutionFunction)
        <span class="cov8" title="1">if len(uOfDPtr.computeFunctions) != len(uOfD2.computeFunctions) </span><span class="cov0" title="0">{
                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                        log.Printf("Length of compute functions map not equivalent")
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">var uri string
        var functionArray []crlExecutionFunction
        for uri, functionArray = range uOfDPtr.computeFunctions </span><span class="cov8" title="1">{
                if len(functionArray) != len(uOfD2.computeFunctions[uri]) </span><span class="cov0" title="0">{
                        if printEquivalenceExceptions </span><span class="cov0" title="0">{
                                log.Printf("Length of compute functions array not equivalent for uri: %s", uri)
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }
                <span class="cov8" title="1">var crlFunction crlExecutionFunction
                var crlFunction2 crlExecutionFunction
                var i int
                for i, crlFunction = range functionArray </span><span class="cov8" title="1">{
                        crlFunction2 = uOfD2.computeFunctions[uri][i]
                        if reflect.ValueOf(crlFunction).Pointer() != reflect.ValueOf(crlFunction2).Pointer() </span><span class="cov0" title="0">{
                                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                                        log.Printf("The %dth compute function is not equivalent for uri: %s", i, uri)
                                }</span>
                                <span class="cov0" title="0">return false</span>
                        }
                }
        }

        // uOfD.uriUUIDMap = NewStringStringMap()
        <span class="cov8" title="1">if !uOfDPtr.uriUUIDMap.IsEquivalent(uOfD2.uriUUIDMap, printEquivalenceExceptions) </span><span class="cov8" title="1">{
                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                        log.Printf("uriUUDIMap not equivalent")
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        // uOfD.uuidElementMap = NewStringElementMap()
        <span class="cov8" title="1">if !uOfDPtr.uuidElementMap.IsEquivalent(uOfD2.uuidElementMap) </span><span class="cov8" title="1">{
                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                        log.Printf("uriUUDIMap keys not equivalent")
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        // uOfD.ownedIDsMap
        <span class="cov8" title="1">if !uOfDPtr.ownedIDsMap.IsEquivalent(uOfD2.ownedIDsMap) </span><span class="cov8" title="1">{
                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                        log.Printf("ownedIDsMap not equivalent")
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        // uOfD.listenersMap
        <span class="cov8" title="1">if !uOfDPtr.listenersMap.IsEquivalent(uOfD2.listenersMap) </span><span class="cov8" title="1">{
                if printEquivalenceExceptions </span><span class="cov0" title="0">{
                        log.Printf("listenersMap not equivalent")
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">rootElements1 := uOfDPtr.GetRootElements(hl1)
        rootElements2 := uOfD2.GetRootElements(hl2)
        for id1, el1 := range rootElements1 </span><span class="cov8" title="1">{
                el2 := rootElements2[id1]
                if el2 == nil || !RecursivelyEquivalent(el1, hl1, el2, hl2, printEquivalenceExceptions) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// IsRecordingUndo reveals whether undo recording is on
func (uOfDPtr *UniverseOfDiscourse) IsRecordingUndo() bool <span class="cov8" title="1">{
        // TODO Remove this debugging code
        if uOfDPtr == nil </span><span class="cov0" title="0">{
                log.Fatal("In UniverseOfDiscourse.IsRecordingUndo() will nil uOfDPtr")
        }</span>
        <span class="cov8" title="1">return uOfDPtr.undoManager.recordingUndo</span>
}

// MarkUndoPoint marks a point on the undo stack. The next undo operation will undo everything back to this point.
func (uOfDPtr *UniverseOfDiscourse) MarkUndoPoint() <span class="cov8" title="1">{
        uOfDPtr.undoManager.MarkUndoPoint()
}</span>

// MarshalDomain creates a JSON representation of an element and all of its descendants
func (uOfDPtr *UniverseOfDiscourse) MarshalDomain(el Element, hl *Transaction) ([]byte, error) <span class="cov8" title="1">{
        var result []byte
        result = append(result, []byte("[")...)
        marshaledConcept, err := uOfDPtr.marshalConceptRecursively(el, hl)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        // The last byte of marshaledConcept is going to be a comma we don't want
        <span class="cov8" title="1">result = append(result, marshaledConcept[0:len(marshaledConcept)-1]...)
        result = append(result, []byte("]")...)
        return result, nil</span>
}

func (uOfDPtr *UniverseOfDiscourse) marshalConceptRecursively(el Element, hl *Transaction) ([]byte, error) <span class="cov8" title="1">{
        var result []byte
        if el == nil </span><span class="cov0" title="0">{
                return result, errors.New("UniverseOfDiscourse.marshalConceptRecursively called with nil concept")
        }</span>
        <span class="cov8" title="1">marshaledElement, err := el.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov8" title="1">result = append(result, marshaledElement...)
        result = append(result, []byte(",")...)
        elID := el.GetConceptID(hl)
        it := uOfDPtr.GetConceptsOwnedConceptIDs(elID).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                child := uOfDPtr.GetElement(id.(string))
                marshaledChild, err := uOfDPtr.marshalConceptRecursively(child, hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return result, err
                }</span>
                <span class="cov8" title="1">result = append(result, marshaledChild...)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// newUofDConceptAddedNotification creates a UofDConceptAdded notification
func (uOfDPtr *UniverseOfDiscourse) newUofDConceptAddedNotification(afterState *ConceptState, hl *Transaction) *ChangeNotification <span class="cov8" title="1">{
        var notification ChangeNotification
        notification.afterConceptState = afterState
        notification.natureOfChange = ConceptAdded
        notification.uOfD = uOfDPtr
        return &amp;notification
}</span>

// SendConceptChangeNotification creates a ConceptChangeNotification
func (uOfDPtr *UniverseOfDiscourse) SendConceptChangeNotification(reportingElement Element, beforeState *ConceptState, afterState *ConceptState, hl *Transaction) error <span class="cov8" title="1">{
        notification := &amp;ChangeNotification{}
        reportingConceptState, err := NewConceptState(reportingElement)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.NewConceptChangeNotification failed")
        }</span>
        <span class="cov8" title="1">notification.reportingElementState = reportingConceptState
        notification.beforeConceptState = beforeState
        notification.afterConceptState = afterState
        notification.natureOfChange = ConceptChanged
        notification.uOfD = uOfDPtr
        err = reportingElement.propagateChange(notification, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.SendConceptChangeNotification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SendPointerChangeNotification creates a PointerChangeNotification and sends it to the relevant parties
func (uOfDPtr *UniverseOfDiscourse) SendPointerChangeNotification(reportingElement Element, natureOfChange NatureOfChange, beforeConceptState *ConceptState, afterConceptState *ConceptState, hl *Transaction) error <span class="cov8" title="1">{
        notification := &amp;ChangeNotification{}
        reportingConceptState, err := NewConceptState(reportingElement)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.NewPointerChangeNotification failed")
        }</span>
        <span class="cov8" title="1">notification.reportingElementState = reportingConceptState
        notification.beforeConceptState = beforeConceptState
        notification.afterConceptState = afterConceptState
        notification.natureOfChange = natureOfChange
        notification.uOfD = uOfDPtr
        reportingElement.propagateChange(notification, hl)
        return nil</span>
}

// newUofDConceptRemovedNotification creates a UniverseOfDiscourseRemoved notification
func (uOfDPtr *UniverseOfDiscourse) newUofDConceptRemovedNotification(beforeState *ConceptState, hl *Transaction) *ChangeNotification <span class="cov8" title="1">{
        var notification ChangeNotification
        notification.natureOfChange = ConceptRemoved
        notification.beforeConceptState = beforeState
        notification.uOfD = uOfDPtr
        return &amp;notification
}</span>

// NewForwardingChangeNotification creates a ChangeNotification that records the reason for the change to the element,
// including the nature of the change, an indication of which component originated the change, and whether there
// was a preceeding notification that triggered this change.
func (uOfDPtr *UniverseOfDiscourse) NewForwardingChangeNotification(reportingElement Element, natureOfChange NatureOfChange, underlyingChange *ChangeNotification, hl *Transaction) (*ChangeNotification, error) <span class="cov8" title="1">{
        notification := &amp;ChangeNotification{}
        reportingElementState, err := NewConceptState(reportingElement)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewForwardingChangeNotification failed")
        }</span>
        <span class="cov8" title="1">notification.reportingElementState = reportingElementState
        notification.natureOfChange = natureOfChange
        notification.underlyingChange = underlyingChange
        notification.uOfD = uOfDPtr
        return notification, nil</span>
}

// NewElement creates and initializes a new Element
func (uOfDPtr *UniverseOfDiscourse) NewElement(hl *Transaction, uri ...string) (Element, error) <span class="cov8" title="1">{
        conceptID, err := uOfDPtr.generateConceptID(uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">actualURI := ""
        if len(uri) == 1 </span><span class="cov8" title="1">{
                actualURI = uri[0]
        }</span>
        <span class="cov8" title="1">var el element
        el.initializeElement(conceptID, actualURI)
        hl.WriteLockElement(&amp;el)
        uOfDPtr.SetUniverseOfDiscourse(&amp;el, hl)
        if actualURI != "" </span><span class="cov8" title="1">{
                el.SetURI(actualURI, hl)
        }</span>
        <span class="cov8" title="1">return &amp;el, nil</span>
}

// NewTransaction creates and initializes a HeldLocks structure utilizing the supplied WaitGroup
func (uOfDPtr *UniverseOfDiscourse) NewTransaction() *Transaction <span class="cov8" title="1">{
        var hl Transaction
        hl.readLocks = make(map[string]Element)
        hl.writeLocks = make(map[string]Element)
        hl.uOfD = uOfDPtr
        return &amp;hl
}</span>

// NewLiteral creates and initializes a new Literal
func (uOfDPtr *UniverseOfDiscourse) NewLiteral(hl *Transaction, uri ...string) (Literal, error) <span class="cov8" title="1">{
        conceptID, err := uOfDPtr.generateConceptID(uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">actualURI := ""
        if len(uri) == 1 </span><span class="cov8" title="1">{
                actualURI = uri[0]
        }</span>
        <span class="cov8" title="1">var lit literal
        lit.initializeLiteral(conceptID, actualURI)
        hl.WriteLockElement(&amp;lit)
        uOfDPtr.SetUniverseOfDiscourse(&amp;lit, hl)
        if actualURI != "" </span><span class="cov8" title="1">{
                lit.SetURI(actualURI, hl)
        }</span>
        <span class="cov8" title="1">return &amp;lit, nil</span>
}

// NewOwnedElement creates an element (with optional URI) and sets its owner and label
func (uOfDPtr *UniverseOfDiscourse) NewOwnedElement(owner Element, label string, hl *Transaction, uri ...string) (Element, error) <span class="cov8" title="1">{
        el, err := uOfDPtr.NewElement(hl, uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedElement failed")
        }</span>
        <span class="cov8" title="1">err = el.SetLabel(label, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedElement failed")
        }</span>
        <span class="cov8" title="1">err = el.SetOwningConcept(owner, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedElement failed")
        }</span>
        <span class="cov8" title="1">return el, nil</span>
}

// NewOwnedLiteral creates a literal (with optional URI) and sets its owner and label
func (uOfDPtr *UniverseOfDiscourse) NewOwnedLiteral(owner Element, label string, hl *Transaction, uri ...string) (Literal, error) <span class="cov8" title="1">{
        lit, err := uOfDPtr.NewLiteral(hl, uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedLiteral failed")
        }</span>
        <span class="cov8" title="1">err = lit.SetLabel(label, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedLiteral failed")
        }</span>
        <span class="cov8" title="1">err = lit.SetOwningConcept(owner, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedLiteral failed")
        }</span>
        <span class="cov8" title="1">return lit, nil</span>
}

// NewOwnedReference creates a reference (with optional URI) and sets its owner and label
func (uOfDPtr *UniverseOfDiscourse) NewOwnedReference(owner Element, label string, hl *Transaction, uri ...string) (Reference, error) <span class="cov8" title="1">{
        ref, err := uOfDPtr.NewReference(hl, uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedReference failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetLabel(label, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedReference failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetOwningConcept(owner, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedReference failed")
        }</span>
        <span class="cov8" title="1">return ref, nil</span>
}

// NewOwnedRefinement creates a refinement (with optional URI) and sets its owner and label
func (uOfDPtr *UniverseOfDiscourse) NewOwnedRefinement(owner Element, label string, hl *Transaction, uri ...string) (Refinement, error) <span class="cov8" title="1">{
        ref, err := uOfDPtr.NewRefinement(hl, uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetLabel(label, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetOwningConcept(owner, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">return ref, nil</span>
}

// NewCompleteRefinement creates a refinement (with optional URI) and sets its abstract and refined references, sets the label, and
// makes the refined element the owner
func (uOfDPtr *UniverseOfDiscourse) NewCompleteRefinement(abstractElement Element, refinedElement Element, label string, hl *Transaction, uri ...string) (Refinement, error) <span class="cov8" title="1">{
        ref, err := uOfDPtr.NewRefinement(hl, uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetLabel(label, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetAbstractConcept(abstractElement, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetRefinedConcept(refinedElement, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">err = ref.SetOwningConcept(refinedElement, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "UniverseOfDiscourse.NewOwnedRefinement failed")
        }</span>
        <span class="cov8" title="1">return ref, nil</span>
}

// NewReference creates and initializes a new Reference
func (uOfDPtr *UniverseOfDiscourse) NewReference(hl *Transaction, uri ...string) (Reference, error) <span class="cov8" title="1">{
        conceptID, err := uOfDPtr.generateConceptID(uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">actualURI := ""
        if len(uri) == 1 </span><span class="cov8" title="1">{
                actualURI = uri[0]
        }</span>
        <span class="cov8" title="1">var ref reference
        ref.initializeReference(conceptID, actualURI)
        hl.WriteLockElement(&amp;ref)
        uOfDPtr.SetUniverseOfDiscourse(&amp;ref, hl)
        if actualURI != "" </span><span class="cov8" title="1">{
                ref.SetURI(actualURI, hl)
        }</span>
        <span class="cov8" title="1">return &amp;ref, nil</span>
}

// NewRefinement creates and initializes a new Refinement
func (uOfDPtr *UniverseOfDiscourse) NewRefinement(hl *Transaction, uri ...string) (Refinement, error) <span class="cov8" title="1">{
        conceptID, err := uOfDPtr.generateConceptID(uri...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">actualURI := ""
        if len(uri) == 1 </span><span class="cov8" title="1">{
                actualURI = uri[0]
        }</span>
        <span class="cov8" title="1">var ref refinement
        ref.initializeRefinement(conceptID, actualURI)
        hl.WriteLockElement(&amp;ref)
        uOfDPtr.SetUniverseOfDiscourse(&amp;ref, hl)
        if actualURI != "" </span><span class="cov8" title="1">{
                ref.SetURI(actualURI, hl)
        }</span>
        <span class="cov8" title="1">return &amp;ref, nil</span>
}

// newUniverseOfDiscourseChangeNotification creates a new ChangeNotification for a UofD change
// func (uOfDPtr *UniverseOfDiscourse) newUniverseOfDiscourseChangeNotification(underlyingChange *ChangeNotification) *ChangeNotification {
//         var notification ChangeNotification
//         notification.reportingElementID = uOfDPtr.ConceptID
//         notification.reportingElementLabel = uOfDPtr.Label
//         notification.reportingElementType = reflect.TypeOf(uOfDPtr).String()
//         notification.natureOfChange = UofDConceptChanged
//         notification.underlyingChange = underlyingChange
//         notification.uOfD = uOfDPtr
//         return &amp;notification
// }

// NotifyUofDObservers passes the notification to all registered Observers
func (uOfDPtr *UniverseOfDiscourse) NotifyUofDObservers(notification *ChangeNotification, hl *Transaction) error <span class="cov8" title="1">{
        it := uOfDPtr.observers.Iterator()
        for observer := range it.C </span><span class="cov8" title="1">{
                err := observer.(Observer).Update(notification, hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.Wrap(err, "element.NotifyUofDObservers failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (uOfDPtr *UniverseOfDiscourse) preChange(el Element, hl *Transaction) <span class="cov8" title="1">{
        if el != nil &amp;&amp; uOfDPtr.IsRecordingUndo() </span><span class="cov8" title="1">{
                uOfDPtr.undoManager.markChangedElement(el, hl)
        }</span>
}

func (uOfDPtr *UniverseOfDiscourse) callAssociatedFunctions(el Element, notification *ChangeNotification, hl *Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscourse.queueFunctionExecution called with a nil Element")
        }</span>
        <span class="cov8" title="1">if el.GetUniverseOfDiscourse(hl) == nil </span><span class="cov0" title="0">{
                // Functions do not get executed on elements that are no longer in a Universe of Discourse
                return nil
        }</span>
        <span class="cov8" title="1">if notification.GetNatureOfChange() == 0 </span><span class="cov0" title="0">{
                return errors.New("UniverseOfDiscourse.callAssociatedFunctions called without of NatureOfChange")
        }</span>
        <span class="cov8" title="1">functionIdentifiers := uOfDPtr.findFunctions(el, notification, hl)
        for _, functionIdentifier := range functionIdentifiers </span><span class="cov8" title="1">{
                if TraceLocks || TraceChange </span><span class="cov8" title="1">{
                        omitTrace := (OmitManageTreeNodesCalls &amp;&amp; functionIdentifier == "http://activeCrl.com/crlEditor/Editor/TreeViews/ManageTreeNodes") ||
                                (OmitDiagramRelatedCalls &amp;&amp; isDiagramRelatedFunction(functionIdentifier))
                        if !omitTrace </span><span class="cov8" title="1">{
                                log.Printf("Calling function with URI: %s notification: %s target: %p", functionIdentifier, notification.GetNatureOfChange().String(), el)
                                notification.Print("      Notification: ", hl)
                                log.Printf("  Function target: %T %s %s %p", el, el.getConceptIDNoLock(), el.GetLabel(hl), el)
                        }</span>
                }
                <span class="cov8" title="1">err := hl.callFunctions(functionIdentifier, el, notification)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "UniverseOfDiscourse.callAssociatedFunctions failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Redo redoes the last undo, if any
func (uOfDPtr *UniverseOfDiscourse) Redo(hl *Transaction) <span class="cov8" title="1">{
        uOfDPtr.undoManager.redo(hl)
}</span>

func (uOfDPtr *UniverseOfDiscourse) removeElementForUndo(el Element, hl *Transaction) <span class="cov8" title="1">{
        if el != nil </span><span class="cov8" title="1">{
                hl.ReadLockElement(el)
                elID := el.GetConceptID(hl)
                if uOfDPtr.undoManager.debugUndo </span><span class="cov0" title="0">{
                        log.Printf("Removing element for undo, id: %s\n", elID)
                        Print(el, "Removed Element: ", hl)
                }</span>
                <span class="cov8" title="1">uOfDPtr.uuidElementMap.DeleteEntry(elID)</span>
        }
}

// RecoverDomain reconstructs a concept space from its JSON representation
func (uOfDPtr *UniverseOfDiscourse) RecoverDomain(data []byte, hl *Transaction) (Element, error) <span class="cov8" title="1">{
        var unmarshaledData []json.RawMessage
        var conceptSpace Element
        err := json.Unmarshal(data, &amp;unmarshaledData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, data := range unmarshaledData </span><span class="cov8" title="1">{
                var el Element
                el, err = uOfDPtr.RecoverElement(data, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if el.GetOwningConceptID(hl) == "" </span><span class="cov8" title="1">{
                        if conceptSpace == nil </span><span class="cov8" title="1">{
                                conceptSpace = el
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("In UniverseOfDiscourse.RecoverDomain more than one element does not have an owner: %s %s", el.GetLabel(hl), el.GetConceptID(hl))
                        }</span>
                }
        }
        <span class="cov8" title="1">return conceptSpace, nil</span>
}

// RecoverElement reconstructs an Element (or subclass) from its JSON representation
func (uOfDPtr *UniverseOfDiscourse) RecoverElement(data []byte, hl *Transaction) (Element, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                err := errors.New("RecoverElement called with no data")
                return nil, err
        }</span>
        <span class="cov8" title="1">var recoveredElement Element
        err := uOfDPtr.unmarshalPolymorphicElement(data, &amp;recoveredElement, hl)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error recovering Element: %s \n", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">uOfDPtr.addElement(recoveredElement, true, hl)
        return recoveredElement, nil</span>
}

// replicateAsRefinement replicates the structure of the original in the replicate, ignoring
// Refinements The name from each original element is copied into the name of the
// corresponding replicate element. Most attributes
// are not replicated, specifically any pointers, ReadOnly, Definition, IsCore, Version, and observers.
// This function is idempotent: if applied to an existing structure,
// Elements of that structure that have existing Refinement relationships with original Elements
// will not be re-created.
func (uOfDPtr *UniverseOfDiscourse) replicateAsRefinement(original Element, replicate Element, hl *Transaction, uri ...string) error <span class="cov8" title="1">{
        hl.ReadLockElement(original)
        hl.WriteLockElement(replicate)

        // Set the attributes - but no IDs
        err := replicate.SetLabel(original.GetLabel(hl), hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "UniverseOfDiscourse.replicateAsRefinement replicate.SetLabel failed")
        }</span>
        <span class="cov8" title="1">switch castOriginal := original.(type) </span>{
        case Reference:<span class="cov8" title="1">
                switch castReplicate := replicate.(type) </span>{
                case Reference:<span class="cov8" title="1">
                        castReplicate.SetReferencedConcept(nil, castOriginal.GetReferencedAttributeName(hl), hl)</span>
                }
        }

        // Determine whether there is already a refinement in place; if not, create it
        <span class="cov8" title="1">if !replicate.IsRefinementOf(original, hl) </span><span class="cov8" title="1">{
                refinementURI := ""
                if len(uri) == 1 &amp;&amp; uri[0] != "" </span><span class="cov8" title="1">{
                        refinementURI = uri[0] + original.GetConceptID(hl) + "/Refinement"
                }</span>
                <span class="cov8" title="1">refinement, err := uOfDPtr.NewRefinement(hl, refinementURI)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "UniverseOfDiscourse.replicateAsRefinement failed: ")
                }</span>
                <span class="cov8" title="1">refinement.SetOwningConcept(replicate, hl)
                refinement.SetAbstractConcept(original, hl)
                refinement.SetRefinedConcept(replicate, hl)
                refinement.SetLabel("Refines "+original.GetLabel(hl), hl)</span>
        }

        // Now determine which children need to be replicated
        <span class="cov8" title="1">originalID := original.GetConceptID(hl)
        replicateID := replicate.GetConceptID(hl)
        it := uOfDPtr.GetConceptsOwnedConceptIDs(originalID).Iterator()
        newChildCount := 0
        for id := range it.C </span><span class="cov8" title="1">{
                newChildURI := ""
                originalChild := uOfDPtr.GetElement(id.(string))
                switch originalChild.(type) </span>{
                case Refinement:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">var replicateChild Element
                // For each original child, determine whether there is already a replicate child that
                // has the original child as one of its abstractions. This is replicateChild
                it2 := uOfDPtr.GetConceptsOwnedConceptIDs(replicateID).Iterator()
                for id := range it2.C </span><span class="cov8" title="1">{
                        currentChild := uOfDPtr.GetElement(id.(string))
                        switch currentChild.(type) </span>{
                        case Refinement:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">currentChildAbstractions := make(map[string]Element)
                        currentChild.FindAbstractions(currentChildAbstractions, hl)
                        for _, currentChildAbstraction := range currentChildAbstractions </span><span class="cov8" title="1">{
                                if currentChildAbstraction == originalChild </span><span class="cov8" title="1">{
                                        replicateChild = currentChild
                                }</span>
                        }
                }
                // If the replicate child is nil at this point, there is no existing replicate child that corresponds
                // to the original child - create one.
                <span class="cov8" title="1">if replicateChild == nil </span><span class="cov8" title="1">{
                        newChildCount++
                        if uri != nil &amp;&amp; uri[0] != "" </span><span class="cov8" title="1">{
                                newChildURI = uri[0] + ".child" + strconv.Itoa(newChildCount)
                        }</span> else<span class="cov8" title="1"> {
                                newChildURI = ""
                        }</span>
                        <span class="cov8" title="1">var replicateError error
                        switch originalChild.(type) </span>{
                        case Reference:<span class="cov8" title="1">
                                replicateChild, replicateError = uOfDPtr.NewReference(hl, newChildURI)</span>
                        case Literal:<span class="cov8" title="1">
                                replicateChild, replicateError = uOfDPtr.NewLiteral(hl, newChildURI)</span>
                        case Element:<span class="cov8" title="1">
                                replicateChild, replicateError = uOfDPtr.NewElement(hl, newChildURI)</span>
                        }
                        <span class="cov8" title="1">if replicateError != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(replicateError, "UniverseOfDiscourse.replicateAsRefinement failed: ")
                        }</span>
                        <span class="cov8" title="1">if replicateChild != nil </span><span class="cov8" title="1">{
                                replicateChild.SetOwningConcept(replicate, hl)
                                err := uOfDPtr.replicateAsRefinement(originalChild, replicateChild, hl, newChildURI)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Register adds the registration of an Observer
func (uOfDPtr *UniverseOfDiscourse) Register(observer Observer) error <span class="cov8" title="1">{
        uOfDPtr.observers.Add(observer)
        return nil
}</span>

// SetRecordingUndo turns undo/redo recording on and off
func (uOfDPtr *UniverseOfDiscourse) SetRecordingUndo(newSetting bool) <span class="cov8" title="1">{
        uOfDPtr.undoManager.setRecordingUndo(newSetting)
}</span>

// SetUniverseOfDiscourse sets the uOfD of which this element is a member. Strictly
// speaking, this is not an attribute of the elment, but rather a context in which
// the element is operating in which the element may be able to locate other objects
// by id.
func (uOfDPtr *UniverseOfDiscourse) SetUniverseOfDiscourse(el Element, hl *Transaction) error <span class="cov8" title="1">{
        hl.WriteLockElement(el)
        currentUofD := el.GetUniverseOfDiscourse(hl)
        if currentUofD != uOfDPtr </span><span class="cov8" title="1">{
                if el.GetIsCore(hl) </span><span class="cov0" title="0">{
                        return errors.New("SetUniverseOfDiscourse called on a CRL core concept")
                }</span>
                <span class="cov8" title="1">if currentUofD != nil </span><span class="cov8" title="1">{
                        return errors.New("SetUniverseOfDiscourse called on an Element in another uOfD")
                }</span>
                <span class="cov8" title="1">if el.IsReadOnly(hl) </span><span class="cov0" title="0">{
                        return errors.New("SetUniverseOfDiscourse called on read-only Element")
                }</span>
                <span class="cov8" title="1">uOfDPtr.preChange(el, hl)
                elementState, err := NewConceptState(el)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "UniverseOfDiscourse.SetUniverseOfDiscourse failed")
                }</span>
                <span class="cov8" title="1">conceptAddedNotification := uOfDPtr.newUofDConceptAddedNotification(elementState, hl)
                el.setUniverseOfDiscourse(uOfDPtr, hl)
                uOfDPtr.addElement(el, false, hl)
                uOfDPtr.NotifyUofDObservers(conceptAddedNotification, hl)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Undo undoes all the changes up to the last UndoMarker or the beginning of Undo, whichever comes first.
func (uOfDPtr *UniverseOfDiscourse) Undo(hl *Transaction) <span class="cov8" title="1">{
        uOfDPtr.undoManager.undo(hl)
}</span>

func (uOfDPtr *UniverseOfDiscourse) unmarshalPolymorphicElement(data []byte, result *Element, hl *Transaction) error <span class="cov8" title="1">{
        var unmarshaledData map[string]json.RawMessage
        err := json.Unmarshal(data, &amp;unmarshaledData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var elementType string
        err = json.Unmarshal(unmarshaledData["Type"], &amp;elementType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch elementType </span>{
        case "*core.element":<span class="cov8" title="1">
                //                fmt.Printf("Switch choice *core.element \n")
                var recoveredElement element
                recoveredElement.uOfD = uOfDPtr
                recoveredElement.initializeElement("", "")
                *result = &amp;recoveredElement
                err = recoveredElement.recoverElementFields(&amp;unmarshaledData, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "*core.reference":<span class="cov8" title="1">
                //                fmt.Printf("Switch choice *core.elementReference \n")
                var recoveredReference reference
                recoveredReference.uOfD = uOfDPtr
                recoveredReference.initializeReference("", "")
                *result = &amp;recoveredReference
                err = recoveredReference.recoverReferenceFields(&amp;unmarshaledData, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "*core.literal":<span class="cov8" title="1">
                //                fmt.Printf("Switch choice *core.literal \n")
                var recoveredLiteral literal
                recoveredLiteral.uOfD = uOfDPtr
                recoveredLiteral.initializeLiteral("", "")
                *result = &amp;recoveredLiteral
                err = recoveredLiteral.recoverLiteralFields(&amp;unmarshaledData, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "*core.refinement":<span class="cov8" title="1">
                var recoveredRefinement refinement
                recoveredRefinement.uOfD = uOfDPtr
                recoveredRefinement.initializeRefinement("", "")
                *result = &amp;recoveredRefinement
                err = recoveredRefinement.recoverRefinementFields(&amp;unmarshaledData, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                log.Printf("No case for %s in unmarshalPolymorphicBaseElement \n", elementType)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (uOfDPtr *UniverseOfDiscourse) uriValidForConceptID(uri ...string) error <span class="cov0" title="0">{
        if len(uri) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(uri) == 1 </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI(uri[0])
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("Invalid uri provided for Element conceptID: " + uri[0])
                }</span>
                <span class="cov0" title="0">id := uuid.NewV5(uuid.NamespaceURL, uri[0]).String()
                if uOfDPtr.GetElement(id) != nil </span><span class="cov0" title="0">{
                        return errors.New("A conceptID already exists for URI: " + uri[0])
                }</span>
        }
        <span class="cov0" title="0">if len(uri) &gt; 1 </span><span class="cov0" title="0">{
                return errors.New("Too many values provided for URI")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package core

import (
        "github.com/pkg/errors"
)

// UofDInitializationFunction is a function that adds core elements to the uOfD during its initialization process. These
// functions are called by the UofDManager after a new UniverseOfDiscourse has been created
type UofDInitializationFunction func(uOFD *UniverseOfDiscourse, hl *Transaction) error

// UofDPostInitializationFunction is an application-specific function that is called after a UofD has been created and all
// UofDInitializationFunctions have been invoked.
type UofDPostInitializationFunction func(uOfD *UniverseOfDiscourse, hl *Transaction) error

// UofDManager manages a universe of discourse and the functions used to initialize it
type UofDManager struct {
        UofD                        *UniverseOfDiscourse
        initializationFunctions     []UofDInitializationFunction
        postInitializationFunctions []UofDPostInitializationFunction
}

// AddInitializationFunction adds a function that will be called during the UniverseOfDiscourse initialization. The function is intended
// to be used by applications to add core concepts to the uOfD before any application data is added
func (mgr *UofDManager) AddInitializationFunction(function UofDInitializationFunction) <span class="cov0" title="0">{
        mgr.initializationFunctions = append(mgr.initializationFunctions, function)
}</span>

// AddPostInitializationFunction adds a function that will be called during the UniverseOfDiscourse initialization. The function is intended
// to be used by applications to perform activities after all core concepts have been added to the uOfD
func (mgr *UofDManager) AddPostInitializationFunction(function UofDInitializationFunction) <span class="cov0" title="0">{
        mgr.initializationFunctions = append(mgr.initializationFunctions, function)
}</span>

// Initialize establishes an initialized UniverseOfDiscourse. It creates the uOfD, calls all of the initialization functions,
// and then calls all of the post-initialization functions.
func (mgr *UofDManager) Initialize() error <span class="cov8" title="1">{
        mgr.UofD = NewUniverseOfDiscourse()
        hl := mgr.UofD.NewTransaction()
        defer hl.ReleaseLocks()
        for _, function := range mgr.initializationFunctions </span><span class="cov0" title="0">{
                err := function(mgr.UofD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        errors.Wrap(err, "UofDManager.Initialize failed")
                }</span>
        }
        <span class="cov8" title="1">for _, function := range mgr.postInitializationFunctions </span><span class="cov0" title="0">{
                err := function(mgr.UofD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        errors.Wrap(err, "UofDManager.Initialize failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2017 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can el found in the LICENSE file.

package core

import (
        "log"
        "reflect"
        "runtime/debug"
        // "sync"
)

// type printMutexStruct struct {
//         sync.Mutex
// }

// GetConceptTypeString returns the string representing the reflected type
func GetConceptTypeString(el Element) string <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return reflect.TypeOf(el).String()</span>
}

// // PrintMutex provides a mututal exclusion for print routhines shared across threads
// var PrintMutex printMutexStruct

func clone(el Element, hl *Transaction) Element <span class="cov8" title="1">{
        switch typedEl := el.(type) </span>{
        case *literal:<span class="cov8" title="1">
                return typedEl.clone(hl)</span>
        case *reference:<span class="cov8" title="1">
                return typedEl.clone(hl)</span>
        case *refinement:<span class="cov8" title="1">
                return typedEl.clone(hl)</span>
        case *element:<span class="cov8" title="1">
                return typedEl.clone(hl)</span>
        }
        <span class="cov0" title="0">log.Printf("clone called with unhandled type %T\n", el)
        debug.PrintStack()
        return nil</span>
}

// Equivalent returns true if the two elements are equivalent
func Equivalent(be1 Element, hl1 *Transaction, be2 Element, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">if be1 == nil &amp;&amp; be2 == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if (be1 == nil &amp;&amp; be2 != nil) || (be1 != nil &amp;&amp; be2 == nil) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">hl1.ReadLockElement(be1)
        if be2 != be1 </span><span class="cov8" title="1">{
                hl2.ReadLockElement(be2)
        }</span>
        <span class="cov8" title="1">return equivalent(be1, hl1, be2, hl2, print)</span>
}

// RecursivelyEquivalent returns true if two elements and all of their children are equivalent
func RecursivelyEquivalent(e1 Element, hl1 *Transaction, e2 Element, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) == 1 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">if !Equivalent(e1, hl1, e2, hl2, print) </span><span class="cov8" title="1">{
                if print </span><span class="cov8" title="1">{
                        log.Print("Equivalence failed")
                        Print(e1, "e1: ", hl1)
                        Print(e2, "e2: ", hl2)
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">children1 := e1.GetOwnedConceptIDs(hl1)
        children2 := e2.GetOwnedConceptIDs(hl2)
        if children1.Cardinality() != children2.Cardinality() </span><span class="cov0" title="0">{
                if print </span><span class="cov0" title="0">{
                        log.Print("Children Cardinality failed")
                        Print(e1, "Element1:", hl1)
                        log.Printf("Children1: %s", children1.String())
                        log.Printf("Children2: %s", children2.String())
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">if !children1.Equal(children2) </span><span class="cov0" title="0">{
                if print </span><span class="cov0" title="0">{
                        log.Print("Children Equal failed")
                        Print(e1, "Element1:", hl1)
                        log.Printf("Children1: %s", children1.String())
                        log.Printf("Children2: %s", children2.String())
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">it := children1.Iterator()
        for childEntry := range it.C </span><span class="cov8" title="1">{
                childID := childEntry.(string)
                child1 := e1.GetUniverseOfDiscourse(hl1).GetElement(childID)
                child2 := e2.GetUniverseOfDiscourse(hl2).GetElement(childID)
                if child1 == nil || child2 == nil || !RecursivelyEquivalent(child1, hl1, child2, hl2, print) </span><span class="cov8" title="1">{
                        it.Stop()
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func equivalent(be1 Element, hl1 *Transaction, be2 Element, hl2 *Transaction, printExceptions ...bool) bool <span class="cov8" title="1">{
        var print bool
        if len(printExceptions) &gt; 0 </span><span class="cov8" title="1">{
                print = printExceptions[0]
        }</span>
        <span class="cov8" title="1">if reflect.TypeOf(be1) != reflect.TypeOf(be2) </span><span class="cov0" title="0">{
                if print </span><span class="cov0" title="0">{
                        log.Printf("In equivalent, element types do not match")
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">switch be1.(type) </span>{
        case *element:<span class="cov8" title="1">
                return be1.(*element).isEquivalent(hl1, be2.(*element), hl2, print)</span>
        case *reference:<span class="cov8" title="1">
                return be1.(*reference).isEquivalent(hl1, be2.(*reference), hl2, print)</span>
        case *literal:<span class="cov8" title="1">
                return be1.(*literal).isEquivalent(hl1, be2.(*literal), hl2, print)</span>
        case *refinement:<span class="cov8" title="1">
                return be1.(*refinement).isEquivalent(hl1, be2.(*refinement), hl2, print)</span>
        // case *UniverseOfDiscourse:
        //         return be1.(*UniverseOfDiscourse).element.isEquivalent(hl1, &amp;be2.(*UniverseOfDiscourse).element, hl2, print)
        default:<span class="cov0" title="0">
                log.Printf("Equivalent default case entered for object: \n")
                Print(be1, "   ", hl1)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Print prints the indicated element and its ownedConcepts, recursively
func Print(el Element, prefix string, hl *Transaction) <span class="cov8" title="1">{
        printElement(el, prefix, hl)
}</span>

func printElement(el Element, prefix string, hl *Transaction) <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">hl.ReadLockElement(el)
        serializedElement, _ := el.MarshalJSON()
        log.Printf("%s%s", prefix, string(serializedElement))
        ownedIDs := el.GetUniverseOfDiscourse(hl).ownedIDsMap.GetMappedValues(el.GetConceptID(hl))
        it := ownedIDs.Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                ownedElement := el.GetUniverseOfDiscourse(hl).GetElement(id.(string))
                printElement(ownedElement, prefix+"  ", hl)
        }</span>
}

// PrintURIIndex prints the URI index of the uOfD with full Element information
func PrintURIIndex(uOfD *UniverseOfDiscourse, hl *Transaction) <span class="cov0" title="0">{
        uOfD.uriUUIDMap.Print(hl)
}</span>

// func restoreValueOwningElementFieldsRecursively(el Element, hl *HeldLocks) {
// if hl == nil {
//         hl = NewHeldLocks(nil)
//         defer hl.ReleaseLocks()
// }
// for _, child := range el.GetOwnedConcepts(hl) {
//         switch child.(type) {
//         //@TODO add reference to case
//         case *element:
//                 restoreValueOwningElementFieldsRecursively(child.(*element), hl)
//         case *reference:
//                 restoreValueOwningElementFieldsRecursively(child.(*reference), hl)
//         case *literal:
//                 child.(*literal).internalSetOwningElement(el, hl)
//         case *refinement:
//                 restoreValueOwningElementFieldsRecursively(child.(*refinement), hl)
//         default:
//                 log.Printf("No case for %T in restoreValueOwningElementFieldsRecursively \n", child)
//         }
// }
// }
</pre>
		
		<pre class="file" id="file22" style="display: none">package core

import (
        "sync"
)

// versionCounter is simply a lockable way of counting versions
type versionCounter struct {
        sync.Mutex
        counter int
}

func newVersionCounter() *versionCounter <span class="cov8" title="1">{
        var vc versionCounter
        return &amp;vc
}</span>

func (vCtr *versionCounter) getVersion() int <span class="cov8" title="1">{
        vCtr.Lock()
        defer vCtr.Unlock()
        return vCtr.counter
}</span>

func (vCtr *versionCounter) incrementVersion() int <span class="cov8" title="1">{
        vCtr.Lock()
        defer vCtr.Unlock()
        vCtr.counter++
        return vCtr.counter
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package crldatastructuresdomain

import (
        "github.com/pbrown12303/activeCRL/core"
)

// CrlDataStructuresDomainURI is the uri for the concept space that defines the Crl Data Structures
var CrlDataStructuresDomainURI = "http://activeCRL.com/crldatastructuresdomain/CrlDataStructuresDomain"

// BuildCrlDataStructuresDomain constructs the concept space for CRL data structures
func BuildCrlDataStructuresDomain(uOfD *core.UniverseOfDiscourse, hl *core.Transaction) <span class="cov8" title="1">{
        crlDataStructures, _ := uOfD.NewElement(hl, CrlDataStructuresDomainURI)
        crlDataStructures.SetLabel("CrlDataStructuresDomain", hl)
        BuildCrlSetsConcepts(uOfD, crlDataStructures, hl)
        BuildCrlListsConcepts(uOfD, crlDataStructures, hl)
        BuildCrlStringListsConcepts(uOfD, crlDataStructures, hl)
        crlDataStructures.SetIsCoreRecursively(hl)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package crldatastructuresdomain

import (
        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
)

// CrlListURI is the URI that identifies the prototype for list
var CrlListURI = CrlDataStructuresDomainURI + "/List"

// CrlListReferenceToFirstMemberReferenceURI is the URI that identifies the prototype for the first member reference
var CrlListReferenceToFirstMemberReferenceURI = CrlListURI + "/ListReferenceToFirstMemberReference"

// CrlListReferenceToLastMemberReferenceURI is the URI that identifies the prototype for a the last member reference
var CrlListReferenceToLastMemberReferenceURI = CrlListURI + "/ListReferenceToLastMemberReference"

// CrlListMemberReferenceURI is the URI that identifies the prototype for a list member reference
var CrlListMemberReferenceURI = CrlListURI + "/ListMemberReference"

// CrlListReferenceToNextMemberReferenceURI is the URI that identifies a member reference's next member reference
var CrlListReferenceToNextMemberReferenceURI = CrlListURI + "/ReferenceToNextMemberReference"

// CrlListReferenceToPriorMemberReferenceURI is the URI that identifies a member reference's prior member reference
var CrlListReferenceToPriorMemberReferenceURI = CrlListURI + "/ReferenceToPriorMemberReference"

// CrlListTypeReferenceURI is the URI that identifies the prototype for a list type reference
var CrlListTypeReferenceURI = CrlListURI + "/ListTypeReference"

// NewList creates an instance of a list
func NewList(uOfD *core.UniverseOfDiscourse, setType core.Element, hl *core.Transaction, newURI ...string) (core.Element, error) <span class="cov8" title="1">{
        if setType == nil </span><span class="cov8" title="1">{
                return nil, errors.New("No type specified for list")
        }</span>
        <span class="cov8" title="1">newList, err := uOfD.CreateReplicateAsRefinementFromURI(CrlListURI, hl, newURI...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">typeReference := newList.GetFirstOwnedReferenceRefinedFromURI(CrlListTypeReferenceURI, hl)
        if typeReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In Lists.go, NewList failed to find a type reference")
        }</span>
        <span class="cov8" title="1">typeReference.SetReferencedConcept(setType, core.NoAttribute, hl)
        return newList, nil</span>
}

// AddListMemberAfter adds a member to the list after the priorMemberReference and returns the newMemberReference.
// If the priorMemberReference is nil, the member is added to the beginning of the list. An error is returned if the
// supplied list is not a list, the newElement is nil, or the priorElementReference is not a CrlListMemberReference in this list.
func AddListMemberAfter(list core.Element, priorMemberReference core.Reference, newMember core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberAfter, supplied Element is not a CRL List")
        }</span>
        <span class="cov8" title="1">if newMember == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberAfter, newMember is nil: nil members are not allowed in CRL Lists")
        }</span>
        // validate prior member reference
        <span class="cov8" title="1">if priorMemberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberAfter, priorMemberReference is nil: this is a required value")
        }</span>
        <span class="cov8" title="1">if priorMemberReference != nil </span><span class="cov8" title="1">{
                if !priorMemberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) </span><span class="cov0" title="0">{
                        return nil, errors.New("In AddListMemberAfter, supplied priorElementReference is not a CrlListMemberReference")
                }</span>
                <span class="cov8" title="1">if priorMemberReference.GetOwningConcept(hl) != list </span><span class="cov0" title="0">{
                        return nil, errors.New("In AddListMemberAfter, supplied priorMemberReference does not belong to this list")
                }</span>
        }
        <span class="cov8" title="1">listType, _ := GetListType(list, hl)
        if !newMember.IsRefinementOf(listType, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberAfter, newMember is of wrong type")
        }</span>
        <span class="cov8" title="1">var newPostMemberReference core.Reference
        referenceToPostMemberReference, err := getReferenceToNextMemberReference(priorMemberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">referencedPostMemberReference := referenceToPostMemberReference.GetReferencedConcept(hl)
        if referencedPostMemberReference != nil </span><span class="cov8" title="1">{
                newPostMemberReference = referencedPostMemberReference.(core.Reference)
        }</span>
        <span class="cov8" title="1">newMemberReference, _ := uOfD.CreateReplicateReferenceAsRefinementFromURI(CrlListMemberReferenceURI, hl)
        newMemberReference.SetOwningConcept(list, hl)
        newMemberReference.SetReferencedConcept(newMember, core.NoAttribute, hl)
        // Wire up prior references
        setNextMemberReference(priorMemberReference, newMemberReference, hl)

        setPriorMemberReference(newMemberReference, priorMemberReference, hl)
        // Wire up next references
        if newPostMemberReference == nil </span><span class="cov8" title="1">{
                referenceToLastMemberReference, err2 := getListReferenceToLastMemberReference(list, hl)
                if err2 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "AddListMemberAfter failed")
                }</span>
                <span class="cov8" title="1">if referenceToLastMemberReference != nil </span><span class="cov8" title="1">{
                        referenceToLastMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                }</span>
        } else<span class="cov8" title="1"> {
                setPriorMemberReference(newPostMemberReference, newMemberReference, hl)
                setNextMemberReference(newMemberReference, newPostMemberReference, hl)
        }</span>

        <span class="cov8" title="1">return newMemberReference, nil</span>
}

// AddListMemberBefore adds a member to the list before the postMember.
// If the postMember is nil, the member is added at the end of the list.
func AddListMemberBefore(list core.Element, postMemberReference core.Reference, newMember core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied Element is not a CRL List")
        }</span>
        <span class="cov8" title="1">if newMember == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied Element is nil: nil members are not allowed in CRL Lists")
        }</span>
        // Check to ensure that the postMemberReference is valid
        <span class="cov8" title="1">if postMemberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("AddListMemberBefore called with nil postMemberReference")
        }</span>
        <span class="cov8" title="1">if !postMemberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied postMemberReference is not a CrlListMemberReference")
        }</span>
        <span class="cov8" title="1">if postMemberReference.GetOwningConcept(hl) != list </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied postMemberReference does not belong to this list")
        }</span>
        <span class="cov8" title="1">listType, _ := GetListType(list, hl)
        if !newMember.IsRefinementOf(listType, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, NewMember is of wrong type")
        }</span>
        <span class="cov8" title="1">var newPriorMemberReference core.Reference
        // If the postMemberReference exists, then its priorMemberReference should point to the newMemberReference
        referenceToPriorMemberReference, err := getReferenceToPriorMemberReference(postMemberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AddListMemberBefore failed")
        }</span>
        <span class="cov8" title="1">referencedPriorMemberReference := referenceToPriorMemberReference.GetReferencedConcept(hl)
        if referencedPriorMemberReference != nil </span><span class="cov8" title="1">{
                newPriorMemberReference = referencedPriorMemberReference.(core.Reference)
        }</span>
        // Create the newMemberReference
        <span class="cov8" title="1">newMemberReference, _ := uOfD.CreateReplicateReferenceAsRefinementFromURI(CrlListMemberReferenceURI, hl)
        newMemberReference.SetOwningConcept(list, hl)
        newMemberReference.SetReferencedConcept(newMember, core.NoAttribute, hl)
        // Wire up post references - be careful if inserting at the end
        setPriorMemberReference(postMemberReference, newMemberReference, hl)
        setNextMemberReference(newMemberReference, postMemberReference, hl)
        // Wire up prior references
        if newPriorMemberReference == nil </span><span class="cov8" title="1">{
                // The new member is the only member of the list
                referenceToFirstMemberReference, _ := getListReferenceToFirstMemberReference(list, hl)
                if referenceToFirstMemberReference != nil </span><span class="cov8" title="1">{
                        referenceToFirstMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                }</span>
        } else<span class="cov8" title="1"> {
                setNextMemberReference(newPriorMemberReference, newMemberReference, hl)
                setPriorMemberReference(newMemberReference, newPriorMemberReference, hl)
        }</span>
        <span class="cov8" title="1">return newMemberReference, nil</span>
}

// AppendListMember adds a member to the end of the list
func AppendListMember(list core.Element, newMember core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied Element is not a CRL List")
        }</span>
        <span class="cov8" title="1">if newMember == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, Supplied Element is nil: nil members are not allowed in CRL Lists")
        }</span>
        <span class="cov8" title="1">listType, _ := GetListType(list, hl)
        if !newMember.IsRefinementOf(listType, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddListMemberBefore, NewMember is of wrong type")
        }</span>
        <span class="cov8" title="1">oldLastMemberReference, err := GetLastMemberReference(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendListMember failed")
        }</span>
        // Create the newMemberReference
        <span class="cov8" title="1">newMemberReference, err2 := uOfD.CreateReplicateReferenceAsRefinementFromURI(CrlListMemberReferenceURI, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "AppendListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberReference.SetOwningConcept(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberReference.SetReferencedConcept(newMember, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendListMember failed")
        }</span>
        // Wire up references - be careful if inserting at the end
        <span class="cov8" title="1">referenceToLastMemberReference, err3 := getListReferenceToLastMemberReference(list, hl)
        if err3 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "AppendListMember failed")
        }</span>
        <span class="cov8" title="1">if referenceToLastMemberReference != nil </span><span class="cov8" title="1">{
                err = referenceToLastMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendListMember failed")
                }</span>
        }
        <span class="cov8" title="1">if oldLastMemberReference == nil </span><span class="cov8" title="1">{
                referenceToFirstMemberReference, err4 := getListReferenceToFirstMemberReference(list, hl)
                if err4 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "AppendListMember failed")
                }</span>
                <span class="cov8" title="1">err = referenceToFirstMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendListMember failed")
                }</span>
        } else<span class="cov8" title="1"> {
                err = setNextMemberReference(oldLastMemberReference, newMemberReference, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendListMember failed")
                }</span>
                <span class="cov8" title="1">err = setPriorMemberReference(newMemberReference, oldLastMemberReference, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendListMember failed")
                }</span>
        }
        <span class="cov8" title="1">return newMemberReference, nil</span>
}

// ClearList removes all members from the list
func ClearList(list core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) </span><span class="cov8" title="1">{
                        uOfD.DeleteElement(memberReference, hl)
                }</span>
        }
}

// GetFirstMemberReference returns the reference to the first member of the list. It returns an error if the
// list is not a list. It returns nil if the list is empty
func GetFirstMemberReference(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        refRef, err := getListReferenceToFirstMemberReference(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if refRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In List GetFirstMemberReference, No reference to first member reference found")
        }</span>
        <span class="cov8" title="1">firstMemberReference := refRef.GetReferencedConcept(hl)
        if firstMemberReference == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return firstMemberReference.(core.Reference), nil</span>
}

// GetFirstReferenceForMember returns the first reference to the given member. It returns an error if the list is not a list.
// It returns nil if the element it is not found in the list.
func GetFirstReferenceForMember(list core.Element, member core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp;
                        memberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) &amp;&amp;
                        memberReference.GetReferencedConcept(hl) == member </span><span class="cov8" title="1">{
                        it.Stop()
                        return memberReference, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// GetLastMemberReference returns the reference to the last member of the list. It returns an error if list is not a list.
// It returns nil if the list is empty
func GetLastMemberReference(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        refRef, err := getListReferenceToLastMemberReference(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if refRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("No reference to last member reference found")
        }</span>
        <span class="cov8" title="1">lastMemberReference := refRef.GetReferencedConcept(hl)
        if lastMemberReference == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return lastMemberReference.(core.Reference), nil</span>
}

// getListReferenceToFirstMemberReference returns the reference to the first member reference. It returns an error if list is not a List
func getListReferenceToFirstMemberReference(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Argument is not a CrlDataStructures.List")
        }</span>
        <span class="cov8" title="1">refToRef := list.GetFirstOwnedReferenceRefinedFromURI(CrlListReferenceToFirstMemberReferenceURI, hl)
        if refToRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In getListReferenceToFirstMemberReference, the reference was not found")
        }</span>
        <span class="cov8" title="1">return refToRef, nil</span>
}

// getListReferenceToLastMemberReference returns the reference to the last member reference. It returns an error if list is not a List
func getListReferenceToLastMemberReference(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Argument is not a CrlDataStructures.List")
        }</span>
        <span class="cov8" title="1">return list.GetFirstOwnedReferenceRefinedFromURI(CrlListReferenceToLastMemberReferenceURI, hl), nil</span>
}

// GetListType returns the element that should be an abstraction of every member. It returns an error if the argument is not a list
func GetListType(list core.Element, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        if !list.IsRefinementOfURI(CrlListURI, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Argument is not a list")
        }</span>
        <span class="cov8" title="1">typeReference := list.GetFirstOwnedReferenceRefinedFromURI(CrlListTypeReferenceURI, hl)
        return typeReference.GetReferencedConcept(hl), nil</span>
}

// GetNextMemberReference returns the successor member reference in the list
func GetNextMemberReference(memberReference core.Reference, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsListMemberReference(memberReference, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberReference is not a refinement of CrlListMemberReference")
        }</span>
        <span class="cov8" title="1">referenceToNextMemberReference, err := getReferenceToNextMemberReference(memberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nextMemberReference := referenceToNextMemberReference.GetReferencedConcept(hl)
        if nextMemberReference == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nextMemberReference.(core.Reference), nil</span>
}

// GetPriorMemberReference returns the predecessor member reference in the list
func GetPriorMemberReference(memberReference core.Reference, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsListMemberReference(memberReference, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberReference is not a refinement of CrlListMemberReference")
        }</span>
        <span class="cov8" title="1">referenceToPriorMemberReference, err := getReferenceToPriorMemberReference(memberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">priorMemberReference := referenceToPriorMemberReference.GetReferencedConcept(hl)
        if priorMemberReference == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return priorMemberReference.(core.Reference), nil</span>
}

// getReferenceToNextMemberReference returns the reference to the next member of the list.
// It returns nil if the reference is the last member of the list
func getReferenceToNextMemberReference(memberReference core.Reference, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if memberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetNextMemberReference called with nil memberReference")
        }</span>
        <span class="cov8" title="1">if !IsListMemberReference(memberReference, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberReference is not a refinement of CrlListMemberReference")
        }</span>
        <span class="cov8" title="1">nextMemberReference := memberReference.GetFirstOwnedReferenceRefinedFromURI(CrlListReferenceToNextMemberReferenceURI, hl)
        if nextMemberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In GetNextMemberReference, memberReference does not ave a NextMemberReferenceReference")
        }</span>
        <span class="cov8" title="1">return nextMemberReference, nil</span>
}

// getReferenceToPriorMemberReference returns the reference to the previous member of the list. It returns an error if the memberReference
// is either nil or is not a refinement of CrlListMemberReference
// It returns nil if the reference is the first member of the list
func getReferenceToPriorMemberReference(memberReference core.Reference, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if memberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getReferenceToPriorMemberReference called with nil memberReference")
        }</span>
        <span class="cov8" title="1">if !IsListMemberReference(memberReference, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In getReferenceToPriorMemberReference, supplied memberReference is not a refinement of CrlListMemberReference")
        }</span>
        <span class="cov8" title="1">priorMemberReference := memberReference.GetFirstOwnedReferenceRefinedFromURI(CrlListReferenceToPriorMemberReferenceURI, hl)
        if priorMemberReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In getReferenceToPriorMemberReference, memberReference does not have a PriorMemberReferenceReference")
        }</span>
        <span class="cov8" title="1">return priorMemberReference, nil</span>
}

// IsList returns true if the supplied Element is a refinement of List
func IsList(list core.Element, hl *core.Transaction) bool <span class="cov8" title="1">{
        return list.IsRefinementOfURI(CrlListURI, hl)
}</span>

// IsListMember returns true if the element is a memeber of the given list
func IsListMember(list core.Element, el core.Element, hl *core.Transaction) bool <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) &amp;&amp; memberReference.GetReferencedConcept(hl) == el </span><span class="cov8" title="1">{
                        it.Stop()
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsListMemberReference returns true if the supplied Reference is a refinement of ListMemberReference
func IsListMemberReference(memberReference core.Reference, hl *core.Transaction) bool <span class="cov8" title="1">{
        return memberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl)
}</span>

// PrependListMember adds a member to the end of the list
func PrependListMember(list core.Element, newMember core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In PrependListMember, Supplied Element is not a CRL List")
        }</span>
        <span class="cov8" title="1">if newMember == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In PrependListMember, Supplied Element is nil: nil members are not allowed in CRL Lists")
        }</span>
        <span class="cov8" title="1">listType, _ := GetListType(list, hl)
        if !newMember.IsRefinementOf(listType, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In PrependListMember, NewMember is of wrong type")
        }</span>
        <span class="cov8" title="1">oldFirstMemberReference, err := GetFirstMemberReference(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependListMember failed")
        }</span>
        // Create the newMemberReference
        <span class="cov8" title="1">newMemberReference, err2 := uOfD.CreateReplicateReferenceAsRefinementFromURI(CrlListMemberReferenceURI, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "PrependListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberReference.SetOwningConcept(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberReference.SetReferencedConcept(newMember, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependListMember failed")
        }</span>
        // Wire up references - be careful if inserting at the end
        <span class="cov8" title="1">referenceToFirstMemberReference, err3 := getListReferenceToFirstMemberReference(list, hl)
        if err3 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "PrependListMember failed")
        }</span>
        <span class="cov8" title="1">if referenceToFirstMemberReference != nil </span><span class="cov8" title="1">{
                err = referenceToFirstMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependListMember failed")
                }</span>
        }
        <span class="cov8" title="1">if oldFirstMemberReference == nil </span><span class="cov8" title="1">{
                referenceToLastMemberReference, err4 := getListReferenceToLastMemberReference(list, hl)
                if err4 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "PrependListMember failed")
                }</span>
                <span class="cov8" title="1">err = referenceToLastMemberReference.SetReferencedConcept(newMemberReference, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependListMember failed")
                }</span>
        } else<span class="cov8" title="1"> {
                err = setPriorMemberReference(oldFirstMemberReference, newMemberReference, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependListMember failed")
                }</span>
        }
        <span class="cov8" title="1">err = setNextMemberReference(newMemberReference, oldFirstMemberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependListMember failed")
        }</span>
        <span class="cov8" title="1">return newMemberReference, nil</span>
}

// RemoveListMember removes the first occurrance of an element from the given list
func RemoveListMember(list core.Element, el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlListMemberReferenceURI, hl) &amp;&amp; memberReference.GetReferencedConcept(hl) == el </span><span class="cov8" title="1">{
                        // Modify previous and next pointers
                        priorMemberReference, _ := GetPriorMemberReference(memberReference, hl)
                        nextMemberReference, _ := GetNextMemberReference(memberReference, hl)
                        if priorMemberReference != nil </span><span class="cov8" title="1">{
                                setNextMemberReference(priorMemberReference, nextMemberReference, hl)
                        }</span> else<span class="cov8" title="1"> {
                                referenceToFirstMemberReference, _ := getListReferenceToFirstMemberReference(list, hl)
                                referenceToFirstMemberReference.SetReferencedConcept(nextMemberReference, core.NoAttribute, hl)
                        }</span>
                        <span class="cov8" title="1">if nextMemberReference != nil </span><span class="cov8" title="1">{
                                setPriorMemberReference(nextMemberReference, priorMemberReference, hl)
                        }</span> else<span class="cov8" title="1"> {
                                referenceToLastMemberReference, _ := getListReferenceToLastMemberReference(list, hl)
                                referenceToLastMemberReference.SetReferencedConcept(priorMemberReference, core.NoAttribute, hl)
                        }</span>
                        // Now delete the member reference
                        <span class="cov8" title="1">uOfD.DeleteElement(memberReference, hl)
                        it.Stop()
                        return nil</span>
                }
        }
        <span class="cov8" title="1">return errors.New("element not member of list")</span>
}

// SetListType sets the element that should be an abstraction of every member. It is only valid on a list that
// does not already have a list type assigned, i.e. you can't change the type of a list once it has been set.
// It returns an error if the argument is not a list or if the list already has a type assigned
func SetListType(list core.Element, listType core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        if !list.IsRefinementOfURI(CrlListURI, hl) </span><span class="cov8" title="1">{
                return errors.New("Argument is not a list")
        }</span>
        <span class="cov0" title="0">typeReference := list.GetFirstOwnedReferenceRefinedFromURI(CrlListTypeReferenceURI, hl)
        if typeReference == nil </span><span class="cov0" title="0">{
                return errors.New("ListTypeReference not found")
        }</span>
        <span class="cov0" title="0">if typeReference.GetReferencedConcept(hl) != nil </span><span class="cov0" title="0">{
                return errors.New("List already has an assigned type")
        }</span>
        <span class="cov0" title="0">return typeReference.SetReferencedConcept(listType, core.NoAttribute, hl)</span>
}

// setNextMemberReference takes a memberReference and sets its next reference
func setNextMemberReference(memberReference core.Reference, nextReference core.Reference, hl *core.Transaction) error <span class="cov8" title="1">{
        // since this is an internal function we assume that the references are refinements of CrlListMemberReference
        nextReferenceReference, err := getReferenceToNextMemberReference(memberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberReference failed")
        }</span>
        <span class="cov8" title="1">err = nextReferenceReference.SetReferencedConcept(nextReference, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberReference failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// setPriorMemberReference takes a memberReference and sets its prior reference
func setPriorMemberReference(memberReference core.Reference, priorReference core.Reference, hl *core.Transaction) error <span class="cov8" title="1">{
        // since this is an internal function we assume that the references are refinements of CrlListMemberReference
        priorReferenceReference, err := getReferenceToPriorMemberReference(memberReference, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberReference failed")
        }</span>
        <span class="cov8" title="1">err = priorReferenceReference.SetReferencedConcept(priorReference, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberReference failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BuildCrlListsConcepts builds the CrlList concept and adds it as a child of the provided parent concept space
func BuildCrlListsConcepts(uOfD *core.UniverseOfDiscourse, parentSpace core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        crlList, _ := uOfD.NewElement(hl, CrlListURI)
        crlList.SetLabel("CrlList", hl)
        crlList.SetOwningConcept(parentSpace, hl)

        crlFirstMemberReference, _ := uOfD.NewReference(hl, CrlListReferenceToFirstMemberReferenceURI)
        crlFirstMemberReference.SetLabel("FirstMemberReference", hl)
        crlFirstMemberReference.SetOwningConcept(crlList, hl)

        crlLastMemberReference, _ := uOfD.NewReference(hl, CrlListReferenceToLastMemberReferenceURI)
        crlLastMemberReference.SetLabel("LastMemberReference", hl)
        crlLastMemberReference.SetOwningConcept(crlList, hl)

        CrlListTypeReference, _ := uOfD.NewReference(hl, CrlListTypeReferenceURI)
        CrlListTypeReference.SetLabel("TypeReference", hl)
        CrlListTypeReference.SetOwningConcept(crlList, hl)

        crlListMemberReference, _ := uOfD.NewReference(hl, CrlListMemberReferenceURI)
        crlListMemberReference.SetLabel("MemberReference", hl)
        crlListMemberReference.SetOwningConcept(parentSpace, hl)

        crlNextMemberReference, _ := uOfD.NewReference(hl, CrlListReferenceToNextMemberReferenceURI)
        crlNextMemberReference.SetLabel("NextMemberReference", hl)
        crlNextMemberReference.SetOwningConcept(crlListMemberReference, hl)

        crlPriorMemberReference, _ := uOfD.NewReference(hl, CrlListReferenceToPriorMemberReferenceURI)
        crlPriorMemberReference.SetLabel("PriorMemberReference", hl)
        crlPriorMemberReference.SetOwningConcept(crlListMemberReference, hl)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package crldatastructuresdomain

import (
        "errors"

        "github.com/pbrown12303/activeCRL/core"
)

// CrlSetURI is the URI that identifies the prototype for sets
var CrlSetURI = CrlDataStructuresDomainURI + "/Set"

// CrlSetMemberReferenceURI is the URI that identifies the prototype for a set member reference
var CrlSetMemberReferenceURI = CrlSetURI + "/SetMemberReference"

// CrlSetTypeReferenceURI is the URI that identifies the prototype for a set type reference
var CrlSetTypeReferenceURI = CrlSetURI + "/SetTypeReference"

// NewSet creates an instance of a set
func NewSet(uOfD *core.UniverseOfDiscourse, setType core.Element, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        if setType == nil </span><span class="cov8" title="1">{
                return nil, errors.New("no type specified for set")
        }</span>
        <span class="cov8" title="1">newSet, _ := uOfD.CreateReplicateAsRefinementFromURI(CrlSetURI, hl)
        typeReference := newSet.GetFirstOwnedReferenceRefinedFromURI(CrlSetTypeReferenceURI, hl)
        typeReference.SetReferencedConcept(setType, core.NoAttribute, hl)
        return newSet, nil</span>
}

// AddSetMember adds a member to the set
func AddSetMember(set core.Element, newMember core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := set.GetUniverseOfDiscourse(hl)
        if IsSetMember(set, newMember, hl) </span><span class="cov8" title="1">{
                return errors.New("newMember is already a member of the set")
        }</span>
        <span class="cov8" title="1">setType, _ := GetSetType(set, hl)
        if !newMember.IsRefinementOf(setType, hl) </span><span class="cov8" title="1">{
                return errors.New("NewMember is of wrong type")
        }</span>
        <span class="cov8" title="1">newMemberReference, _ := uOfD.CreateReplicateReferenceAsRefinementFromURI(CrlSetMemberReferenceURI, hl)
        newMemberReference.SetOwningConcept(set, hl)
        newMemberReference.SetReferencedConcept(newMember, core.NoAttribute, hl)
        return nil</span>
}

// ClearSet removes all members from the set
func ClearSet(set core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        uOfD := set.GetUniverseOfDiscourse(hl)
        it := set.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlSetMemberReferenceURI, hl) </span><span class="cov8" title="1">{
                        uOfD.DeleteElement(memberReference, hl)
                }</span>
        }
}

// GetSetType returns the element that should be an abstraction of every member. It returns an error if the argument is not a set
func GetSetType(set core.Element, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        if !set.IsRefinementOfURI(CrlSetURI, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("argument is not a set")
        }</span>
        <span class="cov8" title="1">typeReference := set.GetFirstOwnedReferenceRefinedFromURI(CrlSetTypeReferenceURI, hl)
        return typeReference.GetReferencedConcept(hl), nil</span>
}

// IsSetMember returns true if the element is a memeber of the given set
func IsSetMember(set core.Element, el core.Element, hl *core.Transaction) bool <span class="cov8" title="1">{
        uOfD := set.GetUniverseOfDiscourse(hl)
        it := set.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlSetMemberReferenceURI, hl) &amp;&amp; memberReference.GetReferencedConcept(hl) == el </span><span class="cov8" title="1">{
                        it.Stop()
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RemoveSetMember removes the element from the given set
func RemoveSetMember(set core.Element, el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := set.GetUniverseOfDiscourse(hl)
        it := set.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberReference := uOfD.GetReference(id.(string))
                if memberReference != nil &amp;&amp; memberReference.IsRefinementOfURI(CrlSetMemberReferenceURI, hl) &amp;&amp; memberReference.GetReferencedConcept(hl) == el </span><span class="cov8" title="1">{
                        uOfD.DeleteElement(memberReference, hl)
                        it.Stop()
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return errors.New("element not member of set")</span>
}

// BuildCrlSetsConcepts builds the CrlSets concept space and adds it as a child of the provided parent concept space
func BuildCrlSetsConcepts(uOfD *core.UniverseOfDiscourse, parentSpace core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        crlSet, _ := uOfD.NewElement(hl, CrlSetURI)
        crlSet.SetLabel("CrlSet", hl)
        crlSet.SetOwningConcept(parentSpace, hl)

        crlSetMemberReference, _ := uOfD.NewReference(hl, CrlSetMemberReferenceURI)
        crlSetMemberReference.SetLabel("MemberReference", hl)
        crlSetMemberReference.SetOwningConcept(parentSpace, hl)

        CrlSetTypeReference, _ := uOfD.NewReference(hl, CrlSetTypeReferenceURI)
        CrlSetTypeReference.SetLabel("TypeReference", hl)
        CrlSetTypeReference.SetOwningConcept(crlSet, hl)

}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package crldatastructuresdomain

import (
        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
)

// CrlStringListURI is the URI that identifies the prototype for list
var CrlStringListURI = CrlDataStructuresDomainURI + "/StringList"

// CrlStringListReferenceToFirstMemberLiteralURI is the URI that identifies the prototype for the first member literal
var CrlStringListReferenceToFirstMemberLiteralURI = CrlStringListURI + "/StringListReferenceToFirstMemberLiteral"

// CrlStringListReferenceToLastMemberLiteralURI is the URI that identifies the prototype for a the last member literal
var CrlStringListReferenceToLastMemberLiteralURI = CrlStringListURI + "/StringListReferenceToLastMemberLiteral"

// CrlStringListMemberLiteralURI is the URI that identifies the prototype for a list member literal
var CrlStringListMemberLiteralURI = CrlStringListURI + "/StringListMemberLiteral"

// CrlStringListReferenceToNextMemberLiteralURI is the URI that identifies a member literal's next member literal
var CrlStringListReferenceToNextMemberLiteralURI = CrlStringListURI + "/ReferenceToNextMemberLiteral"

// CrlStringListReferenceToPriorMemberLiteralURI is the URI that identifies a member literal's prior member literal
var CrlStringListReferenceToPriorMemberLiteralURI = CrlStringListURI + "/ReferenceToPriorMemberLiteral"

// NewStringList creates an instance of a list
func NewStringList(uOfD *core.UniverseOfDiscourse, hl *core.Transaction, newURI ...string) (core.Element, error) <span class="cov8" title="1">{
        newStringList, err := uOfD.CreateReplicateAsRefinementFromURI(CrlStringListURI, hl, newURI...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "StringLists.go NewStringList failed")
        }</span>
        <span class="cov8" title="1">return newStringList, nil</span>
}

// AddStringListMemberAfter adds a string to the list after the priorMemberLiteral and returns the newMemberLiteral.
// If the priorMemberLiteral is nil, the string is added to the beginning of the list. An error is returned if the
// supplied list is not a list, the newMember is the empty string, or the priorMemberLiteral is not a CrlStringListMemberLiteral in this list.
func AddStringListMemberAfter(list core.Element, priorMemberLiteral core.Literal, newMember string, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberAfter, supplied Element is not a CRL StringList")
        }</span>
        <span class="cov8" title="1">if newMember == "" </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberAfter, newMember is the emply string: empty strings are not allowed in CRL StringLists")
        }</span>
        // validate prior member literal
        <span class="cov8" title="1">if priorMemberLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberAfter, priorMemberLiteral is nil: this is a required value")
        }</span>
        <span class="cov8" title="1">if priorMemberLiteral != nil </span><span class="cov8" title="1">{
                if !priorMemberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) </span><span class="cov0" title="0">{
                        return nil, errors.New("In AddStringListMemberAfter, supplied priorMemberLiteral is not a CrlStringListMemberLiteral")
                }</span>
                <span class="cov8" title="1">if priorMemberLiteral.GetOwningConcept(hl) != list </span><span class="cov0" title="0">{
                        return nil, errors.New("In AddStringListMemberAfter, supplied priorMemberLiteral does not belong to this list")
                }</span>
        }
        <span class="cov8" title="1">var newPostMemberLiteral core.Literal
        referenceToPostMemberLiteral, err := getReferenceToNextMemberLiteral(priorMemberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">referencedPostMemberLiteral := referenceToPostMemberLiteral.GetReferencedConcept(hl)
        if referencedPostMemberLiteral != nil </span><span class="cov8" title="1">{
                newPostMemberLiteral = referencedPostMemberLiteral.(core.Literal)
        }</span>
        <span class="cov8" title="1">newMemberLiteral, _ := uOfD.CreateReplicateLiteralAsRefinementFromURI(CrlStringListMemberLiteralURI, hl)
        newMemberLiteral.SetOwningConcept(list, hl)
        newMemberLiteral.SetLiteralValue(newMember, hl)
        // Wire up prior references
        setNextMemberLiteral(priorMemberLiteral, newMemberLiteral, hl)

        setPriorMemberLiteral(newMemberLiteral, priorMemberLiteral, hl)
        // Wire up next references
        if newPostMemberLiteral == nil </span><span class="cov8" title="1">{
                referenceToLastMemberLiteral, err2 := getStringListReferenceToLastMemberLiteral(list, hl)
                if err2 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "AddStringListMemberAfter failed")
                }</span>
                <span class="cov8" title="1">if referenceToLastMemberLiteral != nil </span><span class="cov8" title="1">{
                        referenceToLastMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                }</span>
        } else<span class="cov8" title="1"> {
                setPriorMemberLiteral(newPostMemberLiteral, newMemberLiteral, hl)
                setNextMemberLiteral(newMemberLiteral, newPostMemberLiteral, hl)
        }</span>

        <span class="cov8" title="1">return newMemberLiteral, nil</span>
}

// AddStringListMemberBefore adds a member to the list before the postMember.
// If the postMember is nil, the member is added at the end of the list.
func AddStringListMemberBefore(list core.Element, postMemberLiteral core.Literal, newMember string, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied Element is not a CRL StringList")
        }</span>
        <span class="cov8" title="1">if newMember == "" </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied string is empty: empty strings are not allowed in CRL StringLists")
        }</span>
        // Check to ensure that the postMemberLiteral is valid
        <span class="cov8" title="1">if postMemberLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("AddStringListMemberBefore called with nil postMemberLiteral")
        }</span>
        <span class="cov8" title="1">if !postMemberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied postMemberLiteral is not a CrlStringListMemberLiteral")
        }</span>
        <span class="cov8" title="1">if postMemberLiteral.GetOwningConcept(hl) != list </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied postMemberLiteral does not belong to this list")
        }</span>
        <span class="cov8" title="1">var newPriorMemberLiteral core.Literal
        // If the postMemberLiteral exists, then its priorMemberLiteral should point to the newMemberLiteral
        referenceToPriorMemberLiteral, err := getReferenceToPriorMemberLiteral(postMemberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AddStringListMemberBefore failed")
        }</span>
        <span class="cov8" title="1">referencedPriorMemberLiteral := referenceToPriorMemberLiteral.GetReferencedConcept(hl)
        if referencedPriorMemberLiteral != nil </span><span class="cov8" title="1">{
                newPriorMemberLiteral = referencedPriorMemberLiteral.(core.Literal)
        }</span>
        // Create the newMemberLiteral
        <span class="cov8" title="1">newMemberLiteral, _ := uOfD.CreateReplicateLiteralAsRefinementFromURI(CrlStringListMemberLiteralURI, hl)
        newMemberLiteral.SetOwningConcept(list, hl)
        newMemberLiteral.SetLiteralValue(newMember, hl)
        // Wire up post references - be careful if inserting at the end
        setPriorMemberLiteral(postMemberLiteral, newMemberLiteral, hl)
        setNextMemberLiteral(newMemberLiteral, postMemberLiteral, hl)
        // Wire up prior references
        if newPriorMemberLiteral == nil </span><span class="cov8" title="1">{
                // The new member is the only member of the list
                referenceToFirstMemberLiteral, _ := getStringListReferenceToFirstMemberLiteral(list, hl)
                if referenceToFirstMemberLiteral != nil </span><span class="cov8" title="1">{
                        referenceToFirstMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                }</span>
        } else<span class="cov8" title="1"> {
                setNextMemberLiteral(newPriorMemberLiteral, newMemberLiteral, hl)
                setPriorMemberLiteral(newMemberLiteral, newPriorMemberLiteral, hl)
        }</span>
        <span class="cov8" title="1">return newMemberLiteral, nil</span>
}

// AppendStringListMember adds a string to the end of the list
func AppendStringListMember(list core.Element, value string, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied Element is not a CRL StringList")
        }</span>
        <span class="cov8" title="1">if value == "" </span><span class="cov0" title="0">{
                return nil, errors.New("In AddStringListMemberBefore, Supplied string is empty: empty strings are not allowed in CRL StringLists")
        }</span>
        <span class="cov8" title="1">oldLastMemberLiteral, err := GetLastMemberLiteral(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendStringListMember failed")
        }</span>
        // Create the newMemberLiteral
        <span class="cov8" title="1">newMemberLiteral, err2 := uOfD.CreateReplicateLiteralAsRefinementFromURI(CrlStringListMemberLiteralURI, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "AppendStringListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberLiteral.SetOwningConcept(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendStringListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberLiteral.SetLiteralValue(value, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "AppendStringListMember failed")
        }</span>
        // Wire up references - be careful if inserting at the end
        <span class="cov8" title="1">referenceToLastMemberLiteral, err3 := getStringListReferenceToLastMemberLiteral(list, hl)
        if err3 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "AppendStringListMember failed")
        }</span>
        <span class="cov8" title="1">if referenceToLastMemberLiteral != nil </span><span class="cov8" title="1">{
                err = referenceToLastMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendStringListMember failed")
                }</span>
        }
        <span class="cov8" title="1">if oldLastMemberLiteral == nil </span><span class="cov8" title="1">{
                referenceToFirstMemberLiteral, err4 := getStringListReferenceToFirstMemberLiteral(list, hl)
                if err4 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "AppendStringListMember failed")
                }</span>
                <span class="cov8" title="1">err = referenceToFirstMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendStringListMember failed")
                }</span>
        } else<span class="cov8" title="1"> {
                err = setNextMemberLiteral(oldLastMemberLiteral, newMemberLiteral, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendStringListMember failed")
                }</span>
                <span class="cov8" title="1">err = setPriorMemberLiteral(newMemberLiteral, oldLastMemberLiteral, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "AppendStringListMember failed")
                }</span>
        }
        <span class="cov8" title="1">return newMemberLiteral, nil</span>
}

// ClearStringList removes all members from the list
func ClearStringList(list core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberLiteral := uOfD.GetLiteral(id.(string))
                if memberLiteral != nil &amp;&amp; memberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) </span><span class="cov8" title="1">{
                        uOfD.DeleteElement(memberLiteral, hl)
                }</span>
        }
}

// GetFirstMemberLiteral returns the reference to the first member of the list. It returns an error if the
// list is not a list. It returns nil if the list is empty
func GetFirstMemberLiteral(list core.Element, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        refRef, err := getStringListReferenceToFirstMemberLiteral(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "GetFirstMemberLiteral failed")
        }</span>
        <span class="cov8" title="1">if refRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In StringList GetFirstMemberLiteral, No reference to first member literal found")
        }</span>
        <span class="cov8" title="1">firstMemberLiteral := refRef.GetReferencedConcept(hl)
        if firstMemberLiteral == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return firstMemberLiteral.(core.Literal), nil</span>
}

// GetFirstLiteralForString returns the first Literal whose value is the given string. It returns an error if the list is not a list.
// It returns nil if the string it is not found in the list.
func GetFirstLiteralForString(list core.Element, value string, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberLiteral := uOfD.GetLiteral(id.(string))
                if memberLiteral != nil &amp;&amp;
                        memberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) &amp;&amp;
                        memberLiteral.GetLiteralValue(hl) == value </span><span class="cov8" title="1">{
                        it.Stop()
                        return memberLiteral, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// GetLastMemberLiteral returns the reference to the last member of the list. It returns an error if list is not a list.
// It returns nil if the list is empty
func GetLastMemberLiteral(list core.Element, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        refRef, err := getStringListReferenceToLastMemberLiteral(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if refRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("No reference to last member literal found")
        }</span>
        <span class="cov8" title="1">lastMemberLiteral := refRef.GetReferencedConcept(hl)
        if lastMemberLiteral == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return lastMemberLiteral.(core.Literal), nil</span>
}

// getStringListReferenceToFirstMemberLiteral returns the reference to the first member literal. It returns an error if list is not a StringList
func getStringListReferenceToFirstMemberLiteral(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Argument is not a CrlDataStructures.StringList")
        }</span>
        <span class="cov8" title="1">refToLiteral := list.GetFirstOwnedReferenceRefinedFromURI(CrlStringListReferenceToFirstMemberLiteralURI, hl)
        if refToLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In getStringListReferenceToFirstMemberLiteral, the reference was not found")
        }</span>
        <span class="cov8" title="1">return refToLiteral, nil</span>
}

// getStringListReferenceToLastMemberLiteral returns the reference to the last member literal. It returns an error if list is not a StringList
func getStringListReferenceToLastMemberLiteral(list core.Element, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Argument is not a CrlDataStructures.StringList")
        }</span>
        <span class="cov8" title="1">return list.GetFirstOwnedReferenceRefinedFromURI(CrlStringListReferenceToLastMemberLiteralURI, hl), nil</span>
}

// GetNextMemberLiteral returns the successor member literal in the list
func GetNextMemberLiteral(memberLiteral core.Literal, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        if !IsStringListMemberLiteral(memberLiteral, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberLiteral is not a refinement of CrlStringListMemberLiteral")
        }</span>
        <span class="cov8" title="1">referenceToNextMemberLiteral, err := getReferenceToNextMemberLiteral(memberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nextMemberLiteral := referenceToNextMemberLiteral.GetReferencedConcept(hl)
        if nextMemberLiteral == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return nextMemberLiteral.(core.Literal), nil</span>
}

// GetPriorMemberLiteral returns the predecessor member literal in the list
func GetPriorMemberLiteral(memberLiteral core.Literal, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        if !IsStringListMemberLiteral(memberLiteral, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberLiteral is not a refinement of CrlStringListMemberLiteral")
        }</span>
        <span class="cov8" title="1">referenceToPriorMemberLiteral, err := getReferenceToPriorMemberLiteral(memberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">priorMemberLiteral := referenceToPriorMemberLiteral.GetReferencedConcept(hl)
        if priorMemberLiteral == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return priorMemberLiteral.(core.Literal), nil</span>
}

// getReferenceToNextMemberLiteral returns the reference to the next member of the list.
// It returns nil if the reference is the last member of the list
func getReferenceToNextMemberLiteral(memberLiteral core.Literal, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if memberLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetNextMemberLiteral called with nil memberLiteral")
        }</span>
        <span class="cov8" title="1">if !IsStringListMemberLiteral(memberLiteral, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("Supplied memberLiteral is not a refinement of CrlStringListMemberLiteral")
        }</span>
        <span class="cov8" title="1">nextMemberLiteral := memberLiteral.GetFirstOwnedReferenceRefinedFromURI(CrlStringListReferenceToNextMemberLiteralURI, hl)
        if nextMemberLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In GetNextMemberLiteral, memberLiteral does not ave a NextMemberLiteralReference")
        }</span>
        <span class="cov8" title="1">return nextMemberLiteral, nil</span>
}

// getReferenceToPriorMemberLiteral returns the reference to the previous member of the list. It returns an error if the memberLiteral
// is either nil or is not a refinement of CrlStringListMemberLiteral
// It returns nil if the reference is the first member of the list
func getReferenceToPriorMemberLiteral(memberLiteral core.Literal, hl *core.Transaction) (core.Reference, error) <span class="cov8" title="1">{
        if memberLiteral == nil </span><span class="cov0" title="0">{
                return nil, errors.New("getReferenceToPriorMemberLiteral called with nil memberLiteral")
        }</span>
        <span class="cov8" title="1">if !IsStringListMemberLiteral(memberLiteral, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In getReferenceToPriorMemberLiteral, supplied memberLiteral is not a refinement of CrlStringListMemberLiteral")
        }</span>
        <span class="cov8" title="1">priorMemberLiteralReference := memberLiteral.GetFirstOwnedReferenceRefinedFromURI(CrlStringListReferenceToPriorMemberLiteralURI, hl)
        if priorMemberLiteralReference == nil </span><span class="cov0" title="0">{
                return nil, errors.New("In getReferenceToPriorMemberLiteral, memberLiteral does not have a PriorMemberLiteralReference")
        }</span>
        <span class="cov8" title="1">return priorMemberLiteralReference, nil</span>
}

// IsStringList returns true if the supplied Element is a refinement of StringList
func IsStringList(list core.Element, hl *core.Transaction) bool <span class="cov8" title="1">{
        return list.IsRefinementOfURI(CrlStringListURI, hl)
}</span>

// IsStringListMember returns true if the string is a memeber of the given list
func IsStringListMember(list core.Element, value string, hl *core.Transaction) bool <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberLiteral := uOfD.GetLiteral(id.(string))
                if memberLiteral != nil &amp;&amp; memberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) &amp;&amp; memberLiteral.GetLiteralValue(hl) == value </span><span class="cov8" title="1">{
                        it.Stop()
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsStringListMemberLiteral returns true if the supplied Reference is a refinement of StringListMemberLiteral
func IsStringListMemberLiteral(memberLiteral core.Literal, hl *core.Transaction) bool <span class="cov8" title="1">{
        return memberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl)
}</span>

// PrependStringListMember adds a string to the beginning of the list
func PrependStringListMember(list core.Element, value string, hl *core.Transaction) (core.Literal, error) <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        if !IsStringList(list, hl) </span><span class="cov0" title="0">{
                return nil, errors.New("In PrependStringListMember, Supplied Element is not a CRL StringList")
        }</span>
        <span class="cov8" title="1">if value == "" </span><span class="cov0" title="0">{
                return nil, errors.New("In PrependStringListMember, Supplied string is empty: empty strings are not allowed in CRL StringLists")
        }</span>
        <span class="cov8" title="1">oldFirstMemberLiteral, err := GetFirstMemberLiteral(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependStringListMember failed")
        }</span>
        // Create the newMemberLiteral
        <span class="cov8" title="1">newMemberLiteral, err2 := uOfD.CreateReplicateLiteralAsRefinementFromURI(CrlStringListMemberLiteralURI, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "PrependStringListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberLiteral.SetOwningConcept(list, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependStringListMember failed")
        }</span>
        <span class="cov8" title="1">err = newMemberLiteral.SetLiteralValue(value, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependStringListMember failed")
        }</span>
        // Wire up references - be careful if inserting at the end
        <span class="cov8" title="1">referenceToFirstMemberLiteral, err3 := getStringListReferenceToFirstMemberLiteral(list, hl)
        if err3 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "PrependStringListMember failed")
        }</span>
        <span class="cov8" title="1">if referenceToFirstMemberLiteral != nil </span><span class="cov8" title="1">{
                err = referenceToFirstMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependStringListMember failed")
                }</span>
        }
        <span class="cov8" title="1">if oldFirstMemberLiteral == nil </span><span class="cov8" title="1">{
                referenceToLastMemberLiteral, err4 := getStringListReferenceToLastMemberLiteral(list, hl)
                if err4 != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err2, "PrependStringListMember failed")
                }</span>
                <span class="cov8" title="1">err = referenceToLastMemberLiteral.SetReferencedConcept(newMemberLiteral, core.NoAttribute, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependStringListMember failed")
                }</span>
        } else<span class="cov8" title="1"> {
                err = setPriorMemberLiteral(oldFirstMemberLiteral, newMemberLiteral, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "PrependStringListMember failed")
                }</span>
        }
        <span class="cov8" title="1">err = setNextMemberLiteral(newMemberLiteral, oldFirstMemberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "PrependStringListMember failed")
        }</span>
        <span class="cov8" title="1">return newMemberLiteral, nil</span>
}

// RemoveStringListMember removes the first occurrance of an element from the given list
func RemoveStringListMember(list core.Element, value string, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := list.GetUniverseOfDiscourse(hl)
        it := list.GetOwnedConceptIDs(hl).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                memberLiteral := uOfD.GetLiteral(id.(string))
                if memberLiteral != nil &amp;&amp; memberLiteral.IsRefinementOfURI(CrlStringListMemberLiteralURI, hl) &amp;&amp; memberLiteral.GetLiteralValue(hl) == value </span><span class="cov8" title="1">{
                        // Modify previous and next pointers
                        priorMemberLiteral, _ := GetPriorMemberLiteral(memberLiteral, hl)
                        nextMemberLiteral, _ := GetNextMemberLiteral(memberLiteral, hl)
                        if priorMemberLiteral != nil </span><span class="cov8" title="1">{
                                setNextMemberLiteral(priorMemberLiteral, nextMemberLiteral, hl)
                        }</span> else<span class="cov8" title="1"> {
                                referenceToFirstMemberLiteral, _ := getStringListReferenceToFirstMemberLiteral(list, hl)
                                referenceToFirstMemberLiteral.SetReferencedConcept(nextMemberLiteral, core.NoAttribute, hl)
                        }</span>
                        <span class="cov8" title="1">if nextMemberLiteral != nil </span><span class="cov8" title="1">{
                                setPriorMemberLiteral(nextMemberLiteral, priorMemberLiteral, hl)
                        }</span> else<span class="cov8" title="1"> {
                                referenceToLastMemberLiteral, _ := getStringListReferenceToLastMemberLiteral(list, hl)
                                referenceToLastMemberLiteral.SetReferencedConcept(priorMemberLiteral, core.NoAttribute, hl)
                        }</span>
                        // Now delete the member literal
                        <span class="cov8" title="1">uOfD.DeleteElement(memberLiteral, hl)
                        it.Stop()
                        return nil</span>
                }
        }
        <span class="cov8" title="1">return errors.New("element not member of list")</span>
}

// setNextMemberLiteral takes a memberLiteral and sets its next reference
func setNextMemberLiteral(memberLiteral core.Literal, nextLiteral core.Literal, hl *core.Transaction) error <span class="cov8" title="1">{
        // since this is an internal function we assume that the references are refinements of CrlStringListMemberLiteral
        nextLiteralReference, err := getReferenceToNextMemberLiteral(memberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberLiteral failed")
        }</span>
        <span class="cov8" title="1">err = nextLiteralReference.SetReferencedConcept(nextLiteral, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberLiteral failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// setPriorMemberLiteral takes a memberLiteral and sets its prior reference
func setPriorMemberLiteral(memberLiteral core.Literal, priorLiteral core.Literal, hl *core.Transaction) error <span class="cov8" title="1">{
        // since this is an internal function we assume that the references are refinements of CrlStringListMemberLiteral
        priorLiteralReference, err := getReferenceToPriorMemberLiteral(memberLiteral, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberLiteral failed")
        }</span>
        <span class="cov8" title="1">err = priorLiteralReference.SetReferencedConcept(priorLiteral, core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "setNextMemberLiteral failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BuildCrlStringListsConcepts builds the CrlStringList concept and adds it as a child of the provided parent concept space
func BuildCrlStringListsConcepts(uOfD *core.UniverseOfDiscourse, parentSpace core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        crlStringList, _ := uOfD.NewElement(hl, CrlStringListURI)
        crlStringList.SetLabel("CrlStringList", hl)
        crlStringList.SetOwningConcept(parentSpace, hl)

        crlFirstMemberLiteral, _ := uOfD.NewReference(hl, CrlStringListReferenceToFirstMemberLiteralURI)
        crlFirstMemberLiteral.SetLabel("StringListFirstMemberLiteral", hl)
        crlFirstMemberLiteral.SetOwningConcept(crlStringList, hl)

        crlLastMemberLiteral, _ := uOfD.NewReference(hl, CrlStringListReferenceToLastMemberLiteralURI)
        crlLastMemberLiteral.SetLabel("StringListLastMemberLiteral", hl)
        crlLastMemberLiteral.SetOwningConcept(crlStringList, hl)

        crlStringListMemberLiteral, _ := uOfD.NewLiteral(hl, CrlStringListMemberLiteralURI)
        crlStringListMemberLiteral.SetLabel("StringListMemberLiteral", hl)
        crlStringListMemberLiteral.SetOwningConcept(parentSpace, hl)

        crlNextMemberLiteral, _ := uOfD.NewReference(hl, CrlStringListReferenceToNextMemberLiteralURI)
        crlNextMemberLiteral.SetLabel("StringListNextMemberLiteral", hl)
        crlNextMemberLiteral.SetOwningConcept(crlStringListMemberLiteral, hl)

        crlPriorMemberLiteral, _ := uOfD.NewReference(hl, CrlStringListReferenceToPriorMemberLiteralURI)
        crlPriorMemberLiteral.SetLabel("StringListPriorMemberLiteral", hl)
        crlPriorMemberLiteral.SetOwningConcept(crlStringListMemberLiteral, hl)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package crldatatypesdomain

import (
        "errors"

        "github.com/pbrown12303/activeCRL/core"
)

// CrlBooleanURI is the URI that defines the prototype for Boolean
var CrlBooleanURI = CrlDataTypesDomainURI + "/Boolean"

// NewBoolean creates an instance of a Boolean
func NewBoolean(uOfD *core.UniverseOfDiscourse, hl *core.Transaction) core.Literal <span class="cov8" title="1">{
        newBoolean, _ := uOfD.CreateReplicateLiteralAsRefinementFromURI(CrlBooleanURI, hl)
        SetBooleanValue(newBoolean, false, hl)
        return newBoolean
}</span>

// GetBooleanValue returns the Boolean value
func GetBooleanValue(literal core.Literal, hl *core.Transaction) (bool, error) <span class="cov8" title="1">{
        if !IsBoolean(literal, hl) </span><span class="cov8" title="1">{
                return false, errors.New("GetBooleanValue called with non-Boolean Literal")
        }</span>
        <span class="cov8" title="1">literalValue := literal.GetLiteralValue(hl)
        if literalValue == "true" </span><span class="cov8" title="1">{
                return true, nil
        }</span> else<span class="cov8" title="1"> if literalValue == "false" </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return false, errors.New("GetBooleanValue called with non-boolean value in Literal")</span>
}

// IsBoolean returns true if the Literal is a refinement of Boolean
func IsBoolean(literal core.Literal, hl *core.Transaction) bool <span class="cov8" title="1">{
        return literal.IsRefinementOfURI(CrlBooleanURI, hl)
}</span>

// SetBooleanValue sets the value of the Boolean Literal
func SetBooleanValue(literal core.Literal, value bool, hl *core.Transaction) error <span class="cov8" title="1">{
        if !IsBoolean(literal, hl) </span><span class="cov8" title="1">{
                return errors.New("GetBooleanValue called with non-Boolean Literal")
        }</span>
        <span class="cov8" title="1">if value == true </span><span class="cov8" title="1">{
                literal.SetLiteralValue("true", hl)
        }</span> else<span class="cov8" title="1"> {
                literal.SetLiteralValue("false", hl)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BuildCrlBooleanConcept builds the CrlBoolean concept and adds it to the parent space
func BuildCrlBooleanConcept(uOfD *core.UniverseOfDiscourse, parentSpace core.Element, hl *core.Transaction) <span class="cov8" title="1">{
        crlBoolean, _ := uOfD.NewLiteral(hl, CrlBooleanURI)
        crlBoolean.SetLabel("CrlBoolean", hl)
        crlBoolean.SetOwningConcept(parentSpace, hl)
        crlBoolean.SetIsCore(hl)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package crldatatypesdomain

import (
        "github.com/pbrown12303/activeCRL/core"
)

// CrlDataTypesDomainURI is the URI for the concpet space that defines the CRL Data Types
var CrlDataTypesDomainURI = "http://activeCRL.com/crldatastructuresdomain/CrlDataTypes"

// BuildCrlDataTypesDomain constructs the concept space for CRL data structures
func BuildCrlDataTypesDomain(uOfD *core.UniverseOfDiscourse, hl *core.Transaction) <span class="cov8" title="1">{
        crlDataTypes, _ := uOfD.NewElement(hl, CrlDataTypesDomainURI)
        crlDataTypes.SetLabel("CrlDataTypesDomain", hl)
        BuildCrlBooleanConcept(uOfD, crlDataTypes, hl)
        crlDataTypes.SetReadOnlyRecursively(true, hl)
        crlDataTypes.SetIsCoreRecursively(hl)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package crldiagramdomain defines the Diagram domain. This is a pre-defined domain that is, itself,
// represented as a CRLElement and identified with the CrlDiagramDomainURI. This concept space contains the prototypes of all Elements used to construct CrlDiagrams.
// Included are:
//
//                CrlDiagram: the diagram itself
//                CrlDiagramNode: a node in the diagram
//                CrlDiagramLink: a link in the diagram
//         CrlDiagramPointer: a pointer shown as a link in the diagram
//
// These classes are intended to hold all of the information about the diagram that is not specific to the rendering engine.
//
// Intended Usage
// CRL Elements, in general, can have functions associated with them. When refinements of the elements are created, modified, or deleted, these functions are
// called. The strategy used for diagrams is to place all rendering-specific code in functions associated with the prototypes.
// This is accomplished using the FunctionCallManager.AddFunctionCall() method. Note that this registration is NOT done in the core diagram package, but
// rather in the package providing the rendering engine linkage. For example, the crlEditor package provides the linkages to JavaScript code that does
// the rendering in a browser.
//
// Instances of the prototpes can be conveniently instantiated using the core.CreateReplicateAsRefinementFromURI() function. This clones the prototype
// and, on an element-by-element basis, establishes a refinement relation between the instance elements and thier corresponding prototype elements.
// One essential side-effect of this is that changes that are made to the instnaces then trigger the execution of functions associated with the prototypes.
package crldiagramdomain

import (
        "log"
        "math"
        "strconv"

        "github.com/pkg/errors"

        "golang.org/x/image/math/fixed"

        "github.com/golang/freetype/truetype"
        "github.com/pbrown12303/activeCRL/core"

        mapset "github.com/deckarep/golang-set"
        "golang.org/x/image/font"
        "golang.org/x/image/font/gofont/gobold"
        "golang.org/x/image/font/gofont/goitalic"
        "golang.org/x/image/font/gofont/goregular"
)

// IconSize defines the height and width of icons
const IconSize = 16.0

// NodeLineWidth is the width of the line bordering the node image
const NodeLineWidth = 2.0

// NodePadWidth is the width of the padding surrounding the icon, displayLabel, and abstractionDisplayLabel
const NodePadWidth = 1.0

var goRegularFont *truetype.Font
var goBoldFont *truetype.Font

var go12PtRegularFace font.Face
var go12PtBoldFace font.Face

var go10PtRegularFace font.Face
var go10PtItalicFace font.Face

// CrlDiagramPrefix is the prefix for all URIs related to CrlDiagram
var CrlDiagramPrefix = "http://activeCrl.com"

// CrlDiagramDomainURI identifies concept space containing all concepts related to the CrlDiagram
var CrlDiagramDomainURI = CrlDiagramPrefix + "/CrlDiagramDomain"

// CrlDiagramURI identifies the CrlDiagram concept
var CrlDiagramURI = CrlDiagramDomainURI + "/" + "CrlDiagram"

// CrlDiagramWidthURI identifies the CrlDiagramWidth concept
var CrlDiagramWidthURI = CrlDiagramURI + "/" + "Width"

// CrlDiagramHeightURI identifies the CrlDiagramHeight concept
var CrlDiagramHeightURI = CrlDiagramURI + "/" + "Height"

// CrlDiagramElementURI identifies the CrlDiagramElement concept
var CrlDiagramElementURI = CrlDiagramDomainURI + "/" + "CrlDiagramElement"

// CrlDiagramElementModelReferenceURI identifies the reference to the model element represented by the element
var CrlDiagramElementModelReferenceURI = CrlDiagramElementURI + "/" + "ModelReference"

// CrlDiagramElementDisplayLabelURI identifies the display label concept to be used when displaying the element
var CrlDiagramElementDisplayLabelURI = CrlDiagramElementURI + "/" + "DisplayLabel"

// CrlDiagramElementAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the element
var CrlDiagramElementAbstractionDisplayLabelURI = CrlDiagramElementURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramElementLineColorURI identifies the line color to be used when displaying the element
var CrlDiagramElementLineColorURI = CrlDiagramElementURI + "/" + "LineColor"

// CrlDiagramElementBGColorURI identifies the background color to be used when displaying the element
var CrlDiagramElementBGColorURI = CrlDiagramElementURI + "/" + "BGColor"

// CrlDiagramLinkURI identifies the CrlDiagramLink concept
var CrlDiagramLinkURI = CrlDiagramDomainURI + "/" + "CrlDiagramLink"

// CrlDiagramLinkSourceURI identifies the concept that is the source of the link
var CrlDiagramLinkSourceURI = CrlDiagramLinkURI + "/" + "Source"

// CrlDiagramLinkTargetURI identifies the concept that is the target of the link
var CrlDiagramLinkTargetURI = CrlDiagramLinkURI + "/" + "Target"

// CrlDiagramNodeURI identifies the CrlDiagramNode concept
var CrlDiagramNodeURI = CrlDiagramDomainURI + "/" + "CrlDiagramNode"

// CrlDiagramNodeModelReferenceURI identifies the reference to the model element represented by the node
var CrlDiagramNodeModelReferenceURI = CrlDiagramNodeURI + "/" + "ModelReference"

// CrlDiagramNodeDisplayLabelURI identifies the display label concept to be used when displaying the node
var CrlDiagramNodeDisplayLabelURI = CrlDiagramNodeURI + "/" + "DisplayLabel"

// CrlDiagramNodeAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the node
var CrlDiagramNodeAbstractionDisplayLabelURI = CrlDiagramNodeURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramNodeLineColorURI identifies the line color to be used when displaying the element
var CrlDiagramNodeLineColorURI = CrlDiagramNodeURI + "/" + "LineColor"

// CrlDiagramNodeBGColorURI identifies the background color to be used when displaying the element
var CrlDiagramNodeBGColorURI = CrlDiagramNodeURI + "/" + "BGColor"

// CrlDiagramNodeXURI identifies the X coordinate of the node
var CrlDiagramNodeXURI = CrlDiagramNodeURI + "/" + "X"

// CrlDiagramNodeYURI identifies the Y coordinate of the node
var CrlDiagramNodeYURI = CrlDiagramNodeURI + "/" + "Y"

// CrlDiagramNodeHeightURI identifies the height of the node
var CrlDiagramNodeHeightURI = CrlDiagramNodeURI + "/" + "Height"

// CrlDiagramNodeWidthURI identifies the width of the node
var CrlDiagramNodeWidthURI = CrlDiagramNodeURI + "/" + "Width"

// CrlDiagramNodeDisplayLabelYOffsetURI identifies the Y offset for the display label within the node
var CrlDiagramNodeDisplayLabelYOffsetURI = CrlDiagramNodeURI + "/" + "DisplayLabelYOffset"

// CrlDiagramPointerURI identifies a pointer represented as a link
var CrlDiagramPointerURI = CrlDiagramDomainURI + "/" + "Pointer"

// CrlDiagramAbstractPointerURI identifies the Abstract of an Element represented as a link
var CrlDiagramAbstractPointerURI = CrlDiagramDomainURI + "/" + "AbstractPointer"

// CrlDiagramAbstractPointerModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramAbstractPointerModelReferenceURI = CrlDiagramAbstractPointerURI + "/" + "ModelReference"

// CrlDiagramAbstractPointerDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramAbstractPointerDisplayLabelURI = CrlDiagramAbstractPointerURI + "/" + "DisplayLabel"

// CrlDiagramAbstractPointerAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramAbstractPointerAbstractionDisplayLabelURI = CrlDiagramAbstractPointerURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramAbstractPointerSourceURI identifies the concept that is the source of the link
var CrlDiagramAbstractPointerSourceURI = CrlDiagramAbstractPointerURI + "/" + "Source"

// CrlDiagramAbstractPointerTargetURI identifies the concept that is the target of the link
var CrlDiagramAbstractPointerTargetURI = CrlDiagramAbstractPointerURI + "/" + "Target"

// CrlDiagramElementPointerURI identifies the element pointer of a Reference represented as a link
var CrlDiagramElementPointerURI = CrlDiagramDomainURI + "/" + "ElementPointer"

// CrlDiagramElementPointerModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramElementPointerModelReferenceURI = CrlDiagramElementPointerURI + "/" + "ModelReference"

// CrlDiagramElementPointerDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramElementPointerDisplayLabelURI = CrlDiagramElementPointerURI + "/" + "DisplayLabel"

// CrlDiagramElementPointerAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramElementPointerAbstractionDisplayLabelURI = CrlDiagramElementPointerURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramElementPointerSourceURI identifies the concept that is the source of the link
var CrlDiagramElementPointerSourceURI = CrlDiagramElementPointerURI + "/" + "Source"

// CrlDiagramElementPointerTargetURI identifies the concept that is the target of the link
var CrlDiagramElementPointerTargetURI = CrlDiagramElementPointerURI + "/" + "Target"

// CrlDiagramOwnerPointerURI identifies the owner of an Element represented as a link
var CrlDiagramOwnerPointerURI = CrlDiagramDomainURI + "/" + "OwnerPointer"

// CrlDiagramOwnerPointerModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramOwnerPointerModelReferenceURI = CrlDiagramOwnerPointerURI + "/" + "ModelReference"

// CrlDiagramOwnerPointerDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramOwnerPointerDisplayLabelURI = CrlDiagramOwnerPointerURI + "/" + "DisplayLabel"

// CrlDiagramOwnerPointerAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramOwnerPointerAbstractionDisplayLabelURI = CrlDiagramOwnerPointerURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramOwnerPointerSourceURI identifies the concept that is the source of the link
var CrlDiagramOwnerPointerSourceURI = CrlDiagramOwnerPointerURI + "/" + "Source"

// CrlDiagramOwnerPointerTargetURI identifies the concept that is the target of the link
var CrlDiagramOwnerPointerTargetURI = CrlDiagramOwnerPointerURI + "/" + "Target"

// CrlDiagramRefinedPointerURI identifies the refined element of a Refinement represented as a link
var CrlDiagramRefinedPointerURI = CrlDiagramDomainURI + "/" + "RefinedPointer"

// CrlDiagramRefinedPointerModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramRefinedPointerModelReferenceURI = CrlDiagramRefinedPointerURI + "/" + "ModelReference"

// CrlDiagramRefinedPointerDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramRefinedPointerDisplayLabelURI = CrlDiagramRefinedPointerURI + "/" + "DisplayLabel"

// CrlDiagramRefinedPointerAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramRefinedPointerAbstractionDisplayLabelURI = CrlDiagramRefinedPointerURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramRefinedPointerSourceURI identifies the concept that is the source of the link
var CrlDiagramRefinedPointerSourceURI = CrlDiagramRefinedPointerURI + "/" + "Source"

// CrlDiagramRefinedPointerTargetURI identifies the concept that is the target of the link
var CrlDiagramRefinedPointerTargetURI = CrlDiagramRefinedPointerURI + "/" + "Target"

// CrlDiagramReferenceLinkURI identifies the Reference represented as a link in the diagram
var CrlDiagramReferenceLinkURI = CrlDiagramDomainURI + "/" + "ReferenceLink"

// CrlDiagramReferenceLinkModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramReferenceLinkModelReferenceURI = CrlDiagramReferenceLinkURI + "/" + "ModelReference"

// CrlDiagramReferenceLinkDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramReferenceLinkDisplayLabelURI = CrlDiagramReferenceLinkURI + "/" + "DisplayLabel"

// CrlDiagramReferenceLinkAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramReferenceLinkAbstractionDisplayLabelURI = CrlDiagramReferenceLinkURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramReferenceLinkSourceURI identifies the concept that is the source of the link
var CrlDiagramReferenceLinkSourceURI = CrlDiagramReferenceLinkURI + "/" + "Source"

// CrlDiagramReferenceLinkTargetURI identifies the concept that is the target of the link
var CrlDiagramReferenceLinkTargetURI = CrlDiagramReferenceLinkURI + "/" + "Target"

// CrlDiagramRefinementLinkURI identifies the Refinement represented as a link in the diagram
var CrlDiagramRefinementLinkURI = CrlDiagramDomainURI + "/" + "RefinementLink"

// CrlDiagramRefinementLinkModelReferenceURI identifies the reference to the model element represented by the link
var CrlDiagramRefinementLinkModelReferenceURI = CrlDiagramRefinementLinkURI + "/" + "ModelReference"

// CrlDiagramRefinementLinkDisplayLabelURI identifies the display label concept to be used when displaying the link
var CrlDiagramRefinementLinkDisplayLabelURI = CrlDiagramRefinementLinkURI + "/" + "DisplayLabel"

// CrlDiagramRefinementLinkAbstractionDisplayLabelURI identifies the abstraction display label concept to be used when displaying the link
var CrlDiagramRefinementLinkAbstractionDisplayLabelURI = CrlDiagramRefinementLinkURI + "/" + "AbstractionDisplayLabel"

// CrlDiagramRefinementLinkSourceURI identifies the concept that is the source of the link
var CrlDiagramRefinementLinkSourceURI = CrlDiagramRefinementLinkURI + "/" + "Source"

// CrlDiagramRefinementLinkTargetURI identifies the concept that is the target of the link
var CrlDiagramRefinementLinkTargetURI = CrlDiagramRefinementLinkURI + "/" + "Target"

// GetDisplayLabel is a convenience function for getting the DisplayLabel value of a DiagramElement
func GetDisplayLabel(diagramElement core.Element, trans *core.Transaction) string <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">displayLabelLiteral := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementDisplayLabelURI, trans)
        if displayLabelLiteral != nil </span><span class="cov8" title="1">{
                return displayLabelLiteral.GetLiteralValue(trans)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetAbstractionDisplayLabel is a convenience function for getting the DisplayLabel value of a node's position
func GetAbstractionDisplayLabel(diagramElement core.Element, trans *core.Transaction) string <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">abstractionDisplayLabelLiteral := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementAbstractionDisplayLabelURI, trans)
        if abstractionDisplayLabelLiteral != nil </span><span class="cov8" title="1">{
                return abstractionDisplayLabelLiteral.GetLiteralValue(trans)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetLineColor is a convenience function for getting the LineColor value of a DiagramElement
func GetLineColor(diagramElement core.Element, trans *core.Transaction) string <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">lineColorLiteral := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementLineColorURI, trans)
        if lineColorLiteral != nil </span><span class="cov8" title="1">{
                return lineColorLiteral.GetLiteralValue(trans)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetBGColor is a convenience function for getting the backgound color value of a DiagramElement
func GetBGColor(diagramElement core.Element, trans *core.Transaction) string <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">BGColorLiteral := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementBGColorURI, trans)
        if BGColorLiteral != nil </span><span class="cov8" title="1">{
                return BGColorLiteral.GetLiteralValue(trans)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetFirstElementRepresentingConcept returns the first diagram element that represents the indicated concept
func GetFirstElementRepresentingConcept(diagram core.Element, concept core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if diagram == nil || !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConcept called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov8" title="1">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramElementURI, trans) </span><span class="cov8" title="1">{
                if GetReferencedModelElement(el, trans) == concept &amp;&amp; !el.IsRefinementOfURI(CrlDiagramPointerURI, trans) </span><span class="cov8" title="1">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptID returns the first diagram element that represents the indicated concept
func GetFirstElementRepresentingConceptID(diagram core.Element, conceptID string, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptID called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramElementURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans).GetConceptID(trans) == conceptID &amp;&amp; !el.IsRefinementOfURI(CrlDiagramPointerURI, trans) </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptOwnerPointer returns the first diagram element that represents the indicated concept's OwnerPointer
func GetFirstElementRepresentingConceptOwnerPointer(diagram core.Element, concept core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptOwnerPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov8" title="1">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramOwnerPointerURI, trans) </span><span class="cov8" title="1">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov8" title="1">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptIDOwnerPointer returns the first diagram element that represents the indicated concept's OwnerPointer
func GetFirstElementRepresentingConceptIDOwnerPointer(diagram core.Element, conceptID string, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptIDOwnerPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramOwnerPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans).GetConceptID(trans) == conceptID </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptElementPointer returns the first diagram element that represents the indicated concept's ElementPointer
func GetFirstElementRepresentingConceptElementPointer(diagram core.Element, concept core.Reference, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptElementPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov8" title="1">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramElementPointerURI, trans) </span><span class="cov8" title="1">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov8" title="1">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptIDElementPointer returns the first diagram element that represents the indicated concept's ElementPointer
func GetFirstElementRepresentingConceptIDElementPointer(diagram core.Element, conceptID string, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptIDElementPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramElementPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans).GetConceptID(trans) == conceptID </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptAbstractPointer returns the first diagram element that represents the indicated concept's AbstractPointer
func GetFirstElementRepresentingConceptAbstractPointer(diagram core.Element, concept core.Refinement, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptAbstractPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov8" title="1">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramAbstractPointerURI, trans) </span><span class="cov8" title="1">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov8" title="1">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptIDAbstractPointer returns the first diagram element that represents the indicated concept's AbstractPointer
func GetFirstElementRepresentingConceptIDAbstractPointer(diagram core.Element, conceptID string, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptIDAbstractPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramAbstractPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans).GetConceptID(trans) == conceptID </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptRefinedPointer returns the first diagram element that represents the indicated concept's RefinedPointer
func GetFirstElementRepresentingConceptRefinedPointer(diagram core.Element, concept core.Refinement, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptRefinedPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov8" title="1">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramRefinedPointerURI, trans) </span><span class="cov8" title="1">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov8" title="1">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetFirstElementRepresentingConceptIDRefinedPointer returns the first diagram element that represents the indicated concept's RefinedPointer
func GetFirstElementRepresentingConceptIDRefinedPointer(diagram core.Element, conceptID string, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetFirstElementRepresentingConceptIDRefinedPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramRefinedPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans).GetConceptID(trans) == conceptID </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetLinkSource is a convenience function for getting the source concept of a link
func GetLinkSource(diagramLink core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if diagramLink == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">sourceReference := diagramLink.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkSourceURI, trans)
        if sourceReference != nil </span><span class="cov8" title="1">{
                return sourceReference.GetReferencedConcept(trans)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetLinkTarget is a convenience function for getting the target concept of a link
func GetLinkTarget(diagramLink core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if diagramLink == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">targetReference := diagramLink.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkTargetURI, trans)
        if targetReference != nil </span><span class="cov8" title="1">{
                return targetReference.GetReferencedConcept(trans)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetNodeHeight is a convenience function for getting the Height value of a node's position
func GetNodeHeight(diagramNode core.Element, trans *core.Transaction) float64 <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">heightLiteral := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeHeightURI, trans)
        if heightLiteral != nil </span><span class="cov8" title="1">{
                value := heightLiteral.GetLiteralValue(trans)
                numericValue, err := strconv.ParseFloat(value, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return numericValue
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

// GetNodeWidth is a convenience function for getting the Width value of a node's position
func GetNodeWidth(diagramNode core.Element, trans *core.Transaction) float64 <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">widthLiteral := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeWidthURI, trans)
        if widthLiteral != nil </span><span class="cov8" title="1">{
                value := widthLiteral.GetLiteralValue(trans)
                numericValue, err := strconv.ParseFloat(value, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return numericValue
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

// GetNodeX is a convenience function for getting the X value of a node's position
func GetNodeX(diagramNode core.Element, trans *core.Transaction) float64 <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">xLiteral := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeXURI, trans)
        if xLiteral != nil </span><span class="cov8" title="1">{
                value := xLiteral.GetLiteralValue(trans)
                numericValue, err := strconv.ParseFloat(value, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return numericValue
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

// GetNodeY is a convenience function for getting the X value of a node's position
func GetNodeY(diagramNode core.Element, trans *core.Transaction) float64 <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">yLiteral := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeYURI, trans)
        if yLiteral != nil </span><span class="cov8" title="1">{
                value := yLiteral.GetLiteralValue(trans)
                numericValue, err := strconv.ParseFloat(value, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return numericValue
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

// GetDisplayLabelYOffset is a convenience function for getting the Display Label's Y offset within the node
func GetDisplayLabelYOffset(diagramNode core.Element, trans *core.Transaction) float64 <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">yOffsetLiteral := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeDisplayLabelYOffsetURI, trans)
        if yOffsetLiteral != nil </span><span class="cov8" title="1">{
                value := yOffsetLiteral.GetLiteralValue(trans)
                numericValue, err := strconv.ParseFloat(value, 64)
                if err == nil </span><span class="cov8" title="1">{
                        return numericValue
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}

// GetOwnerPointer returns the ownerPointer for the concept if one exists
func GetOwnerPointer(diagram core.Element, concept core.Element, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetOwnerPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramOwnerPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetElementPointer returns the elementPointer for the concept if one exists
func GetElementPointer(diagram core.Element, concept core.Element, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if !diagram.IsRefinementOfURI(CrlDiagramURI, trans) </span><span class="cov0" title="0">{
                log.Printf("GetElementPointer called with diagram of incorrect type")
                return nil
        }</span>
        <span class="cov0" title="0">for _, el := range diagram.GetOwnedConceptsRefinedFromURI(CrlDiagramElementPointerURI, trans) </span><span class="cov0" title="0">{
                if GetReferencedModelElement(el, trans) == concept </span><span class="cov0" title="0">{
                        return el
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetReferencedModelElement is a function on a CrlDiagramNode that returns the model element represented by the
// diagram node
func GetReferencedModelElement(diagramElement core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">reference := diagramElement.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramElementModelReferenceURI, trans)
        if reference != nil </span><span class="cov8" title="1">{
                return reference.GetReferencedConcept(trans)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func init() <span class="cov8" title="1">{
        var err error

        // Set up fonts and faces
        goRegularFont, err = truetype.Parse(goregular.TTF)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
        }</span>
        <span class="cov8" title="1">goBoldFont, err = truetype.Parse(gobold.TTF)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
        }</span>

        <span class="cov8" title="1">goItalicFont, err := truetype.Parse(goitalic.TTF)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
        }</span>

        <span class="cov8" title="1">options12Pt := truetype.Options{Size: 12.0}
        go12PtRegularFace = truetype.NewFace(goRegularFont, &amp;options12Pt)
        go12PtBoldFace = truetype.NewFace(goBoldFont, &amp;options12Pt)

        options10Pt := truetype.Options{Size: 10.0}
        go10PtRegularFace = truetype.NewFace(goRegularFont, &amp;options10Pt)
        go10PtItalicFace = truetype.NewFace(goItalicFont, &amp;options10Pt)</span>
}

// Int26_6ToFloat converts a fixed point 26_6 integer to a floating point number
func Int26_6ToFloat(val fixed.Int26_6) float64 <span class="cov8" title="1">{
        return float64(val) / 64.0
}</span>

// IsDiagram returns true if the supplied element is a CrlDiagram
func IsDiagram(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        switch el.(type) </span>{
        case core.Element:<span class="cov8" title="1">
                return el.IsRefinementOfURI(CrlDiagramURI, trans)</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsDiagramAbstractPointer returns true if the supplied element is a CrlDiagramAbstractPointer
func IsDiagramAbstractPointer(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        return el.IsRefinementOfURI(CrlDiagramAbstractPointerURI, trans)
}</span>

// IsDiagramElement returns true if the supplied element is a CrlDiagramElement
func IsDiagramElement(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        return el.IsRefinementOfURI(CrlDiagramElementURI, trans)
}</span>

// IsDiagramElementPointer returns true if the supplied element is a CrlDiagramElementPointer
func IsDiagramElementPointer(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramElementPointerURI, trans)
}</span>

// IsDiagramLink returns true if the supplied element is a CrlDiagramLink
func IsDiagramLink(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramLinkURI, trans)
}</span>

// IsDiagramNode returns true if the supplied element is a CrlDiagramNode
func IsDiagramNode(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramNodeURI, trans)
}</span>

// IsDiagramOwnerPointer returns true if the supplied element is a CrlDiagramOwnerPointer
func IsDiagramOwnerPointer(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        return el.IsRefinementOfURI(CrlDiagramOwnerPointerURI, trans)
}</span>

// IsDiagramPointer returns true if the supplied element is a CrlDiagramPointer
func IsDiagramPointer(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramPointerURI, trans)
}</span>

// IsDiagramRefinedPointer returns true if the supplied element is a CrlDiagramRefinedPointer
func IsDiagramRefinedPointer(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        return el.IsRefinementOfURI(CrlDiagramRefinedPointerURI, trans)
}</span>

// IsDiagramReferenceLink returns true if the supplied element is a CrlDiagramReferenceLink
func IsDiagramReferenceLink(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramReferenceLinkURI, trans)
}</span>

// IsDiagramRefinementLink returns true if the supplied element is a CrlDiagramRefinementLink
func IsDiagramRefinementLink(el core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return el.IsRefinementOfURI(CrlDiagramRefinementLinkURI, trans)
}</span>

// IsModelReference returns true if the supplied element is a ModelReference
func IsModelReference(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        return el.IsRefinementOfURI(CrlDiagramElementModelReferenceURI, trans)
}</span>

// IsDisplayLabel returns true if the supplied Literal is the DisplayLabel
func IsDisplayLabel(el core.Element, trans *core.Transaction) bool <span class="cov0" title="0">{
        if el == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return el.IsRefinementOfURI(CrlDiagramNodeDisplayLabelURI, trans)</span>
}

// NewDiagram creates a new diagram
func NewDiagram(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramURI, trans)
}</span>

// NewDiagramReferenceLink creates a new diagram link to represent a reference
func NewDiagramReferenceLink(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramReferenceLinkURI, trans)
}</span>

// NewDiagramRefinementLink creates a new diagram link
func NewDiagramRefinementLink(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramRefinementLinkURI, trans)
}</span>

// NewDiagramNode creates a new diagram node
func NewDiagramNode(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        newNode, err := uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramNodeURI, trans)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Diagram.go NewDiagramNode failed")
        }</span>
        <span class="cov8" title="1">SetLineColor(newNode, "#000000", trans)
        return newNode, nil</span>
}

// NewDiagramOwnerPointer creates a new DiagramOwnerPointer
func NewDiagramOwnerPointer(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramOwnerPointerURI, trans)
}</span>

// NewDiagramElementPointer creates a new DiagramElementPointer
func NewDiagramElementPointer(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramElementPointerURI, trans)
}</span>

// NewDiagramAbstractPointer creates a new DiagramAbstractPointer
func NewDiagramAbstractPointer(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramAbstractPointerURI, trans)
}</span>

// NewDiagramRefinedPointer creates a new DiagramRefinedPointer
func NewDiagramRefinedPointer(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        return uOfD.CreateReplicateAsRefinementFromURI(CrlDiagramRefinedPointerURI, trans)
}</span>

// SetAbstractionDisplayLabel is a function on a CrlDiagramNode that sets the display label of the diagram node
func SetAbstractionDisplayLabel(diagramElement core.Element, value string, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementAbstractionDisplayLabelURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(value, trans)
        updateNodeSize(diagramElement, trans)</span>
}

// SetDisplayLabel is a function on a CrlDiagramNode that sets the display label of the diagram element.
// If the diagram element is a pointer, the value is ignored and the label is set to the empty string
func SetDisplayLabel(diagramElement core.Element, value string, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementDisplayLabelURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if IsDiagramPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                literal.SetLiteralValue("", trans)
        }</span> else<span class="cov8" title="1"> {
                literal.SetLiteralValue(value, trans)
        }</span>
        <span class="cov8" title="1">updateNodeSize(diagramElement, trans)</span>
}

// SetLineColor is a function on a CrlDiagramElement that sets the line color for the diagram element.
func SetLineColor(diagramElement core.Element, value string, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementLineColorURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(value, trans)</span>
}

// SetBGColor is a function on a CrlDiagramNode that sets the background color for the diagram element.
// If the diagram element is a pointer, the value is ignored and the label is set to the empty string
func SetBGColor(diagramElement core.Element, value string, trans *core.Transaction) <span class="cov0" title="0">{
        if diagramElement == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">literal := diagramElement.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramElementBGColorURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsDiagramPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                literal.SetLiteralValue("", trans)
        }</span> else<span class="cov0" title="0"> {
                literal.SetLiteralValue(value, trans)
        }</span>
}

// SetLinkSource is a convenience function for setting the source concept of a link
func SetLinkSource(diagramLink core.Element, source core.Element, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramLink == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sourceReference := diagramLink.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkSourceURI, trans)
        if sourceReference != nil </span><span class="cov8" title="1">{
                sourceReference.SetReferencedConcept(source, core.NoAttribute, trans)
        }</span>
}

// SetLinkTarget is a convenience function for setting the target concept of a link
func SetLinkTarget(diagramLink core.Element, target core.Element, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramLink == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">targetReference := diagramLink.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkTargetURI, trans)
        if targetReference != nil </span><span class="cov8" title="1">{
                targetReference.SetReferencedConcept(target, core.NoAttribute, trans)
        }</span>
}

// SetNodeHeight is a function on a CrlDiagramNode that sets the height of the diagram node
func SetNodeHeight(diagramNode core.Element, value float64, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeHeightURI, trans)
        if literal == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(strconv.FormatFloat(value, 'f', -1, 64), trans)</span>
}

// SetNodeWidth is a function on a CrlDiagramNode that sets the width of the diagram node
func SetNodeWidth(diagramNode core.Element, value float64, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeWidthURI, trans)
        if literal == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(strconv.FormatFloat(value, 'f', -1, 64), trans)</span>
}

// SetNodeX is a function on a CrlDiagramNode that sets the x of the diagram node
func SetNodeX(diagramNode core.Element, value float64, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeXURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(strconv.FormatFloat(value, 'f', -1, 64), trans)</span>
}

// SetNodeY is a function on a CrlDiagramNode that sets the y of the diagram node
func SetNodeY(diagramNode core.Element, value float64, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeYURI, trans)
        if literal == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(strconv.FormatFloat(value, 'f', -1, 64), trans)</span>
}

// SetNodeDisplayLabelYOffset is a function on a CrlDiagramNode that sets the y offset of the display label within the node
func SetNodeDisplayLabelYOffset(diagramNode core.Element, value float64, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramNode == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">literal := diagramNode.GetFirstOwnedLiteralRefinementOfURI(CrlDiagramNodeDisplayLabelYOffsetURI, trans)
        if literal == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">literal.SetLiteralValue(strconv.FormatFloat(value, 'f', -1, 64), trans)</span>
}

// SetReferencedModelElement is a function on a CrlDiagramNode that sets the model element represented by the
// diagram node
func SetReferencedModelElement(diagramElement core.Element, el core.Element, trans *core.Transaction) <span class="cov8" title="1">{
        if diagramElement == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">reference := diagramElement.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramElementModelReferenceURI, trans)
        if reference == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">reference.SetReferencedConcept(el, core.NoAttribute, trans)</span>
}

// BuildCrlDiagramDomain builds the CrlDiagram concept space and adds it to the uOfD
func BuildCrlDiagramDomain(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        // CrlDiagramDomain
        crlDiagramDomain, _ := uOfD.NewElement(trans, CrlDiagramDomainURI)
        crlDiagramDomain.SetLabel("CrlDiagramDomain", trans)

        //
        // CrlDiagram
        //
        crlDiagram, _ := uOfD.NewElement(trans, CrlDiagramURI)
        crlDiagram.SetLabel("CrlDiagram", trans)
        crlDiagram.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramWidth, _ := uOfD.NewLiteral(trans, CrlDiagramWidthURI)
        crlDiagramWidth.SetLabel("Width", trans)
        crlDiagramWidth.SetOwningConcept(crlDiagram, trans)

        crlDiagramHeight, _ := uOfD.NewLiteral(trans, CrlDiagramHeightURI)
        crlDiagramHeight.SetLabel("Height", trans)
        crlDiagramHeight.SetOwningConcept(crlDiagram, trans)

        //
        // CrlDiagramElement
        //
        crlDiagramElement, _ := uOfD.NewElement(trans, CrlDiagramElementURI)
        crlDiagramElement.SetLabel("CrlDiagramElement", trans)
        crlDiagramElement.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramElementModelReference, _ := uOfD.NewReference(trans, CrlDiagramElementModelReferenceURI)
        crlDiagramElementModelReference.SetLabel("ModelReference", trans)
        crlDiagramElementModelReference.SetOwningConcept(crlDiagramElement, trans)

        crlDiagramElementDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramElementDisplayLabelURI)
        crlDiagramElementDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramElementDisplayLabel.SetOwningConcept(crlDiagramElement, trans)

        crlDiagramElementAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramElementAbstractionDisplayLabelURI)
        crlDiagramElementAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramElementAbstractionDisplayLabel.SetOwningConcept(crlDiagramElement, trans)

        crlDiagramElementLineColor, _ := uOfD.NewOwnedLiteral(crlDiagramElement, "LineColor", trans, CrlDiagramElementLineColorURI)
        crlDiagramElementBGColor, _ := uOfD.NewOwnedLiteral(crlDiagramElement, "BGColor", trans, CrlDiagramElementBGColorURI)

        //
        // CrlDiagramNode
        //
        crlDiagramNode, _ := uOfD.NewElement(trans, CrlDiagramNodeURI)
        crlDiagramNode.SetLabel("CrlDiagramNode", trans)
        crlDiagramNode.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramNodeRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramNodeRefinement.SetOwningConcept(crlDiagramNode, trans)
        crlDiagramNodeRefinement.SetAbstractConcept(crlDiagramElement, trans)
        crlDiagramNodeRefinement.SetRefinedConcept(crlDiagramNode, trans)

        crlDiagramNodeModelReference, _ := uOfD.NewReference(trans, CrlDiagramNodeModelReferenceURI)
        crlDiagramNodeModelReference.SetLabel("ModelReference", trans)
        crlDiagramNodeModelReference.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramNodeModelReferenceRefinement.SetOwningConcept(crlDiagramNodeModelReference, trans)
        crlDiagramNodeModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramNodeModelReferenceRefinement.SetRefinedConcept(crlDiagramNodeModelReference, trans)

        crlDiagramNodeDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramNodeDisplayLabelURI)
        crlDiagramNodeDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramNodeDisplayLabel.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramNodeDisplayLabelRefinement.SetOwningConcept(crlDiagramNodeDisplayLabel, trans)
        crlDiagramNodeDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramNodeDisplayLabelRefinement.SetRefinedConcept(crlDiagramNodeDisplayLabel, trans)

        crlDiagramNodeAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramNodeAbstractionDisplayLabelURI)
        crlDiagramNodeAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramNodeAbstractionDisplayLabel.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramNodeAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramNodeAbstractionDisplayLabel, trans)
        crlDiagramNodeAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramNodeAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramNodeAbstractionDisplayLabel, trans)

        crlDiagramNodeLineColor, _ := uOfD.NewOwnedLiteral(crlDiagramNode, "LineColor", trans, CrlDiagramNodeLineColorURI)
        crlDiagramNodeLineColor.SetLiteralValue("#000000", trans)
        uOfD.NewCompleteRefinement(crlDiagramElementLineColor, crlDiagramNodeLineColor, "LineColorRefinement", trans)

        crlDiagramNodeBGColor, _ := uOfD.NewOwnedLiteral(crlDiagramNode, "BGColor", trans, CrlDiagramNodeBGColorURI)
        uOfD.NewCompleteRefinement(crlDiagramElementBGColor, crlDiagramNodeBGColor, "BGColorRefinement", trans)

        crlDiagramNodeX, _ := uOfD.NewLiteral(trans, CrlDiagramNodeXURI)
        crlDiagramNodeX.SetLabel("X", trans)
        crlDiagramNodeX.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeY, _ := uOfD.NewLiteral(trans, CrlDiagramNodeYURI)
        crlDiagramNodeY.SetLabel("Y", trans)
        crlDiagramNodeY.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeHeight, _ := uOfD.NewLiteral(trans, CrlDiagramNodeHeightURI)
        crlDiagramNodeHeight.SetLabel("Height", trans)
        crlDiagramNodeHeight.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeWidth, _ := uOfD.NewLiteral(trans, CrlDiagramNodeWidthURI)
        crlDiagramNodeWidth.SetLabel("Width", trans)
        crlDiagramNodeWidth.SetOwningConcept(crlDiagramNode, trans)

        crlDiagramNodeDisplayLabelYOffset, _ := uOfD.NewLiteral(trans, CrlDiagramNodeDisplayLabelYOffsetURI)
        crlDiagramNodeDisplayLabelYOffset.SetLabel("DisplayLabelYOffset", trans)
        crlDiagramNodeDisplayLabelYOffset.SetOwningConcept(crlDiagramNode, trans)

        //
        // CrlDiagramLink
        //
        crlDiagramLink, _ := uOfD.NewElement(trans, CrlDiagramLinkURI)
        crlDiagramLink.SetLabel("CrlDiagramLink", trans)
        crlDiagramLink.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramLinkRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramLinkRefinement.SetOwningConcept(crlDiagramLink, trans)
        crlDiagramLinkRefinement.SetAbstractConcept(crlDiagramElement, trans)
        crlDiagramLinkRefinement.SetRefinedConcept(crlDiagramLink, trans)

        crlDiagramLinkSource, _ := uOfD.NewReference(trans, CrlDiagramLinkSourceURI)
        crlDiagramLinkSource.SetLabel("Source", trans)
        crlDiagramLinkSource.SetOwningConcept(crlDiagramLink, trans)

        crlDiagramLinkTarget, _ := uOfD.NewReference(trans, CrlDiagramLinkTargetURI)
        crlDiagramLinkTarget.SetLabel("Target", trans)
        crlDiagramLinkTarget.SetOwningConcept(crlDiagramLink, trans)

        //
        // Pointer
        //
        crlDiagramPointer, _ := uOfD.NewElement(trans, CrlDiagramPointerURI)
        crlDiagramPointer.SetLabel("Pointer", trans)
        crlDiagramPointer.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramPointerRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramPointerRefinement.SetOwningConcept(crlDiagramPointer, trans)
        crlDiagramPointerRefinement.SetAbstractConcept(crlDiagramLink, trans)
        crlDiagramPointerRefinement.SetRefinedConcept(crlDiagramPointer, trans)

        //
        // AbstractPointer
        //
        crlDiagramAbstractPointer, _ := uOfD.NewElement(trans, CrlDiagramAbstractPointerURI)
        crlDiagramAbstractPointer.SetLabel("AbstractPointer", trans)
        crlDiagramAbstractPointer.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramAbstractPointerRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerRefinement.SetOwningConcept(crlDiagramAbstractPointer, trans)
        crlDiagramAbstractPointerRefinement.SetAbstractConcept(crlDiagramPointer, trans)
        crlDiagramAbstractPointerRefinement.SetRefinedConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerModelReference, _ := uOfD.NewReference(trans, CrlDiagramAbstractPointerModelReferenceURI)
        crlDiagramAbstractPointerModelReference.SetLabel("ModelReference", trans)
        crlDiagramAbstractPointerModelReference.SetOwningConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerModelReferenceRefinement.SetOwningConcept(crlDiagramAbstractPointerModelReference, trans)
        crlDiagramAbstractPointerModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramAbstractPointerModelReferenceRefinement.SetRefinedConcept(crlDiagramAbstractPointerModelReference, trans)

        crlDiagramAbstractPointerDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramAbstractPointerDisplayLabelURI)
        crlDiagramAbstractPointerDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramAbstractPointerDisplayLabel.SetOwningConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerDisplayLabelRefinement.SetOwningConcept(crlDiagramAbstractPointerDisplayLabel, trans)
        crlDiagramAbstractPointerDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramAbstractPointerDisplayLabelRefinement.SetRefinedConcept(crlDiagramAbstractPointerDisplayLabel, trans)

        crlDiagramAbstractPointerAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramAbstractPointerAbstractionDisplayLabelURI)
        crlDiagramAbstractPointerAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramAbstractPointerAbstractionDisplayLabel.SetOwningConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramAbstractPointerAbstractionDisplayLabel, trans)
        crlDiagramAbstractPointerAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramAbstractPointerAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramAbstractPointerAbstractionDisplayLabel, trans)

        crlDiagramAbstractPointerSource, _ := uOfD.NewReference(trans, CrlDiagramAbstractPointerSourceURI)
        crlDiagramAbstractPointerSource.SetLabel("Source", trans)
        crlDiagramAbstractPointerSource.SetOwningConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerSourceRefinement.SetOwningConcept(crlDiagramAbstractPointerSource, trans)
        crlDiagramAbstractPointerSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramAbstractPointerSourceRefinement.SetRefinedConcept(crlDiagramAbstractPointerSource, trans)

        crlDiagramAbstractPointerTarget, _ := uOfD.NewReference(trans, CrlDiagramAbstractPointerTargetURI)
        crlDiagramAbstractPointerTarget.SetLabel("Target", trans)
        crlDiagramAbstractPointerTarget.SetOwningConcept(crlDiagramAbstractPointer, trans)

        crlDiagramAbstractPointerTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramAbstractPointerTargetRefinement.SetOwningConcept(crlDiagramAbstractPointerTarget, trans)
        crlDiagramAbstractPointerTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramAbstractPointerTargetRefinement.SetRefinedConcept(crlDiagramAbstractPointerTarget, trans)

        //
        // ElementPointer
        //
        crlDiagramElementPointer, _ := uOfD.NewElement(trans, CrlDiagramElementPointerURI)
        crlDiagramElementPointer.SetLabel("ElementPointer", trans)
        crlDiagramElementPointer.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramElementPointerRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerRefinement.SetOwningConcept(crlDiagramElementPointer, trans)
        crlDiagramElementPointerRefinement.SetAbstractConcept(crlDiagramPointer, trans)
        crlDiagramElementPointerRefinement.SetRefinedConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerModelReference, _ := uOfD.NewReference(trans, CrlDiagramElementPointerModelReferenceURI)
        crlDiagramElementPointerModelReference.SetLabel("ModelReference", trans)
        crlDiagramElementPointerModelReference.SetOwningConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerModelReferenceRefinement.SetOwningConcept(crlDiagramElementPointerModelReference, trans)
        crlDiagramElementPointerModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramElementPointerModelReferenceRefinement.SetRefinedConcept(crlDiagramElementPointerModelReference, trans)

        crlDiagramElementPointerDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramElementPointerDisplayLabelURI)
        crlDiagramElementPointerDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramElementPointerDisplayLabel.SetOwningConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerDisplayLabelRefinement.SetOwningConcept(crlDiagramElementPointerDisplayLabel, trans)
        crlDiagramElementPointerDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramElementPointerDisplayLabelRefinement.SetRefinedConcept(crlDiagramElementPointerDisplayLabel, trans)

        crlDiagramElementPointerAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramElementPointerAbstractionDisplayLabelURI)
        crlDiagramElementPointerAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramElementPointerAbstractionDisplayLabel.SetOwningConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramElementPointerAbstractionDisplayLabel, trans)
        crlDiagramElementPointerAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramElementPointerAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramElementPointerAbstractionDisplayLabel, trans)

        crlDiagramElementPointerSource, _ := uOfD.NewReference(trans, CrlDiagramElementPointerSourceURI)
        crlDiagramElementPointerSource.SetLabel("Source", trans)
        crlDiagramElementPointerSource.SetOwningConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerSourceRefinement.SetOwningConcept(crlDiagramElementPointerSource, trans)
        crlDiagramElementPointerSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramElementPointerSourceRefinement.SetRefinedConcept(crlDiagramElementPointerSource, trans)

        crlDiagramElementPointerTarget, _ := uOfD.NewReference(trans, CrlDiagramElementPointerTargetURI)
        crlDiagramElementPointerTarget.SetLabel("Target", trans)
        crlDiagramElementPointerTarget.SetOwningConcept(crlDiagramElementPointer, trans)

        crlDiagramElementPointerTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramElementPointerTargetRefinement.SetOwningConcept(crlDiagramElementPointerTarget, trans)
        crlDiagramElementPointerTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramElementPointerTargetRefinement.SetRefinedConcept(crlDiagramElementPointerTarget, trans)

        //
        // OwnerPointer
        //
        crlDiagramOwnerPointer, _ := uOfD.NewElement(trans, CrlDiagramOwnerPointerURI)
        crlDiagramOwnerPointer.SetLabel("OwnerPointer", trans)
        crlDiagramOwnerPointer.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramOwnerPointerRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerRefinement.SetOwningConcept(crlDiagramOwnerPointer, trans)
        crlDiagramOwnerPointerRefinement.SetAbstractConcept(crlDiagramPointer, trans)
        crlDiagramOwnerPointerRefinement.SetRefinedConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerModelReference, _ := uOfD.NewReference(trans, CrlDiagramOwnerPointerModelReferenceURI)
        crlDiagramOwnerPointerModelReference.SetLabel("ModelReference", trans)
        crlDiagramOwnerPointerModelReference.SetOwningConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerModelReferenceRefinement.SetOwningConcept(crlDiagramOwnerPointerModelReference, trans)
        crlDiagramOwnerPointerModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramOwnerPointerModelReferenceRefinement.SetRefinedConcept(crlDiagramOwnerPointerModelReference, trans)

        crlDiagramOwnerPointerDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramOwnerPointerDisplayLabelURI)
        crlDiagramOwnerPointerDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramOwnerPointerDisplayLabel.SetOwningConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerDisplayLabelRefinement.SetOwningConcept(crlDiagramOwnerPointerDisplayLabel, trans)
        crlDiagramOwnerPointerDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramOwnerPointerDisplayLabelRefinement.SetRefinedConcept(crlDiagramOwnerPointerDisplayLabel, trans)

        crlDiagramOwnerPointerAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramOwnerPointerAbstractionDisplayLabelURI)
        crlDiagramOwnerPointerAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramOwnerPointerAbstractionDisplayLabel.SetOwningConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramOwnerPointerAbstractionDisplayLabel, trans)
        crlDiagramOwnerPointerAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramOwnerPointerAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramOwnerPointerAbstractionDisplayLabel, trans)

        crlDiagramOwnerPointerSource, _ := uOfD.NewReference(trans, CrlDiagramOwnerPointerSourceURI)
        crlDiagramOwnerPointerSource.SetLabel("Source", trans)
        crlDiagramOwnerPointerSource.SetOwningConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerSourceRefinement.SetOwningConcept(crlDiagramOwnerPointerSource, trans)
        crlDiagramOwnerPointerSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramOwnerPointerSourceRefinement.SetRefinedConcept(crlDiagramOwnerPointerSource, trans)

        crlDiagramOwnerPointerTarget, _ := uOfD.NewReference(trans, CrlDiagramOwnerPointerTargetURI)
        crlDiagramOwnerPointerTarget.SetLabel("Target", trans)
        crlDiagramOwnerPointerTarget.SetOwningConcept(crlDiagramOwnerPointer, trans)

        crlDiagramOwnerPointerTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramOwnerPointerTargetRefinement.SetOwningConcept(crlDiagramOwnerPointerTarget, trans)
        crlDiagramOwnerPointerTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramOwnerPointerTargetRefinement.SetRefinedConcept(crlDiagramOwnerPointerTarget, trans)

        //
        // RefinedPointer
        //
        crlDiagramRefinedPointer, _ := uOfD.NewElement(trans, CrlDiagramRefinedPointerURI)
        crlDiagramRefinedPointer.SetLabel("RefinedPointer", trans)
        crlDiagramRefinedPointer.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramRefinedPointerRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerRefinement.SetOwningConcept(crlDiagramRefinedPointer, trans)
        crlDiagramRefinedPointerRefinement.SetAbstractConcept(crlDiagramPointer, trans)
        crlDiagramRefinedPointerRefinement.SetRefinedConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerModelReference, _ := uOfD.NewReference(trans, CrlDiagramRefinedPointerModelReferenceURI)
        crlDiagramRefinedPointerModelReference.SetLabel("ModelReference", trans)
        crlDiagramRefinedPointerModelReference.SetOwningConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerModelReferenceRefinement.SetOwningConcept(crlDiagramRefinedPointerModelReference, trans)
        crlDiagramRefinedPointerModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramRefinedPointerModelReferenceRefinement.SetRefinedConcept(crlDiagramRefinedPointerModelReference, trans)

        crlDiagramRefinedPointerDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramRefinedPointerDisplayLabelURI)
        crlDiagramRefinedPointerDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramRefinedPointerDisplayLabel.SetOwningConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerDisplayLabelRefinement.SetOwningConcept(crlDiagramRefinedPointerDisplayLabel, trans)
        crlDiagramRefinedPointerDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramRefinedPointerDisplayLabelRefinement.SetRefinedConcept(crlDiagramRefinedPointerDisplayLabel, trans)

        crlDiagramRefinedPointerAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramRefinedPointerAbstractionDisplayLabelURI)
        crlDiagramRefinedPointerAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramRefinedPointerAbstractionDisplayLabel.SetOwningConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramRefinedPointerAbstractionDisplayLabel, trans)
        crlDiagramRefinedPointerAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramRefinedPointerAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramRefinedPointerAbstractionDisplayLabel, trans)

        crlDiagramRefinedPointerSource, _ := uOfD.NewReference(trans, CrlDiagramRefinedPointerSourceURI)
        crlDiagramRefinedPointerSource.SetLabel("Source", trans)
        crlDiagramRefinedPointerSource.SetOwningConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerSourceRefinement.SetOwningConcept(crlDiagramRefinedPointerSource, trans)
        crlDiagramRefinedPointerSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramRefinedPointerSourceRefinement.SetRefinedConcept(crlDiagramRefinedPointerSource, trans)

        crlDiagramRefinedPointerTarget, _ := uOfD.NewReference(trans, CrlDiagramRefinedPointerTargetURI)
        crlDiagramRefinedPointerTarget.SetLabel("Target", trans)
        crlDiagramRefinedPointerTarget.SetOwningConcept(crlDiagramRefinedPointer, trans)

        crlDiagramRefinedPointerTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinedPointerTargetRefinement.SetOwningConcept(crlDiagramRefinedPointerTarget, trans)
        crlDiagramRefinedPointerTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramRefinedPointerTargetRefinement.SetRefinedConcept(crlDiagramRefinedPointerTarget, trans)

        //
        // ReferenceLink
        //
        crlDiagramReferenceLink, _ := uOfD.NewElement(trans, CrlDiagramReferenceLinkURI)
        crlDiagramReferenceLink.SetLabel("ReferenceLink", trans)
        crlDiagramReferenceLink.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramReferenceLinkRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkRefinement.SetOwningConcept(crlDiagramReferenceLink, trans)
        crlDiagramReferenceLinkRefinement.SetAbstractConcept(crlDiagramLink, trans)
        crlDiagramReferenceLinkRefinement.SetRefinedConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkModelReference, _ := uOfD.NewReference(trans, CrlDiagramReferenceLinkModelReferenceURI)
        crlDiagramReferenceLinkModelReference.SetLabel("ModelReference", trans)
        crlDiagramReferenceLinkModelReference.SetOwningConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkModelReferenceRefinement.SetOwningConcept(crlDiagramReferenceLinkModelReference, trans)
        crlDiagramReferenceLinkModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramReferenceLinkModelReferenceRefinement.SetRefinedConcept(crlDiagramReferenceLinkModelReference, trans)

        crlDiagramReferenceLinkDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramReferenceLinkDisplayLabelURI)
        crlDiagramReferenceLinkDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramReferenceLinkDisplayLabel.SetOwningConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkDisplayLabelRefinement.SetOwningConcept(crlDiagramReferenceLinkDisplayLabel, trans)
        crlDiagramReferenceLinkDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramReferenceLinkDisplayLabelRefinement.SetRefinedConcept(crlDiagramReferenceLinkDisplayLabel, trans)

        crlDiagramReferenceLinkAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramReferenceLinkAbstractionDisplayLabelURI)
        crlDiagramReferenceLinkAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramReferenceLinkAbstractionDisplayLabel.SetOwningConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramReferenceLinkAbstractionDisplayLabel, trans)
        crlDiagramReferenceLinkAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramReferenceLinkAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramReferenceLinkAbstractionDisplayLabel, trans)

        crlDiagramReferenceLinkSource, _ := uOfD.NewReference(trans, CrlDiagramReferenceLinkSourceURI)
        crlDiagramReferenceLinkSource.SetLabel("Source", trans)
        crlDiagramReferenceLinkSource.SetOwningConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkSourceRefinement.SetOwningConcept(crlDiagramReferenceLinkSource, trans)
        crlDiagramReferenceLinkSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramReferenceLinkSourceRefinement.SetRefinedConcept(crlDiagramReferenceLinkSource, trans)

        crlDiagramReferenceLinkTarget, _ := uOfD.NewReference(trans, CrlDiagramReferenceLinkTargetURI)
        crlDiagramReferenceLinkTarget.SetLabel("Target", trans)
        crlDiagramReferenceLinkTarget.SetOwningConcept(crlDiagramReferenceLink, trans)

        crlDiagramReferenceLinkTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramReferenceLinkTargetRefinement.SetOwningConcept(crlDiagramReferenceLinkTarget, trans)
        crlDiagramReferenceLinkTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramReferenceLinkTargetRefinement.SetRefinedConcept(crlDiagramReferenceLinkTarget, trans)

        //
        // RefinementLink
        //
        crlDiagramRefinementLink, _ := uOfD.NewElement(trans, CrlDiagramRefinementLinkURI)
        crlDiagramRefinementLink.SetLabel("RefinementLink", trans)
        crlDiagramRefinementLink.SetOwningConcept(crlDiagramDomain, trans)

        crlDiagramRefinementLinkRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkRefinement.SetOwningConcept(crlDiagramRefinementLink, trans)
        crlDiagramRefinementLinkRefinement.SetAbstractConcept(crlDiagramLink, trans)
        crlDiagramRefinementLinkRefinement.SetRefinedConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkModelReference, _ := uOfD.NewReference(trans, CrlDiagramRefinementLinkModelReferenceURI)
        crlDiagramRefinementLinkModelReference.SetLabel("ModelReference", trans)
        crlDiagramRefinementLinkModelReference.SetOwningConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkModelReferenceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkModelReferenceRefinement.SetOwningConcept(crlDiagramRefinementLinkModelReference, trans)
        crlDiagramRefinementLinkModelReferenceRefinement.SetAbstractConcept(crlDiagramElementModelReference, trans)
        crlDiagramRefinementLinkModelReferenceRefinement.SetRefinedConcept(crlDiagramRefinementLinkModelReference, trans)

        crlDiagramRefinementLinkDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramRefinementLinkDisplayLabelURI)
        crlDiagramRefinementLinkDisplayLabel.SetLabel("DisplayLabel", trans)
        crlDiagramRefinementLinkDisplayLabel.SetOwningConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkDisplayLabelRefinement.SetOwningConcept(crlDiagramRefinementLinkDisplayLabel, trans)
        crlDiagramRefinementLinkDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementDisplayLabel, trans)
        crlDiagramRefinementLinkDisplayLabelRefinement.SetRefinedConcept(crlDiagramRefinementLinkDisplayLabel, trans)

        crlDiagramRefinementLinkAbstractionDisplayLabel, _ := uOfD.NewLiteral(trans, CrlDiagramRefinementLinkAbstractionDisplayLabelURI)
        crlDiagramRefinementLinkAbstractionDisplayLabel.SetLabel("AbstractionDisplayLabel", trans)
        crlDiagramRefinementLinkAbstractionDisplayLabel.SetOwningConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkAbstractionDisplayLabelRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkAbstractionDisplayLabelRefinement.SetOwningConcept(crlDiagramRefinementLinkAbstractionDisplayLabel, trans)
        crlDiagramRefinementLinkAbstractionDisplayLabelRefinement.SetAbstractConcept(crlDiagramElementAbstractionDisplayLabel, trans)
        crlDiagramRefinementLinkAbstractionDisplayLabelRefinement.SetRefinedConcept(crlDiagramRefinementLinkAbstractionDisplayLabel, trans)

        crlDiagramRefinementLinkSource, _ := uOfD.NewReference(trans, CrlDiagramRefinementLinkSourceURI)
        crlDiagramRefinementLinkSource.SetLabel("Source", trans)
        crlDiagramRefinementLinkSource.SetOwningConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkSourceRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkSourceRefinement.SetOwningConcept(crlDiagramRefinementLinkSource, trans)
        crlDiagramRefinementLinkSourceRefinement.SetAbstractConcept(crlDiagramLinkSource, trans)
        crlDiagramRefinementLinkSourceRefinement.SetRefinedConcept(crlDiagramRefinementLinkSource, trans)

        crlDiagramRefinementLinkTarget, _ := uOfD.NewReference(trans, CrlDiagramRefinementLinkTargetURI)
        crlDiagramRefinementLinkTarget.SetLabel("Target", trans)
        crlDiagramRefinementLinkTarget.SetOwningConcept(crlDiagramRefinementLink, trans)

        crlDiagramRefinementLinkTargetRefinement, _ := uOfD.NewRefinement(trans)
        crlDiagramRefinementLinkTargetRefinement.SetOwningConcept(crlDiagramRefinementLinkTarget, trans)
        crlDiagramRefinementLinkTargetRefinement.SetAbstractConcept(crlDiagramLinkTarget, trans)
        crlDiagramRefinementLinkTargetRefinement.SetRefinedConcept(crlDiagramRefinementLinkTarget, trans)

        uOfD.AddFunction(CrlDiagramElementURI, updateDiagramElement)
        uOfD.AddFunction(CrlDiagramOwnerPointerURI, updateDiagramOwnerPointer)

        crlDiagramDomain.SetIsCoreRecursively(trans)
        return crlDiagramDomain
}</span>

// updateDiagramElement updates the diagram element based on changes to the modelElement it represents
func updateDiagramElement(diagramElement core.Element, notification *core.ChangeNotification, trans *core.Transaction) error <span class="cov8" title="1">{
        uOfD := trans.GetUniverseOfDiscourse()
        trans.WriteLockElement(diagramElement)
        // core Elements should always be ignored
        if diagramElement.GetIsCore(trans) </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Suppress circular notifications
        <span class="cov8" title="1">underlyingChange := notification.GetUnderlyingChange()
        if underlyingChange != nil &amp;&amp; underlyingChange.IsReferenced(diagramElement) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // There are several notifications of interest here:
        //   - the deletion of the referenced model element
        //   - the label of the referenced model element
        //   - the list of immediate abstractions of the referenced model element.
        // First, determine whether it is the referenced model element that has changed
        <span class="cov8" title="1">diagramElementModelReference := diagramElement.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramElementModelReferenceURI, trans)
        if diagramElementModelReference == nil </span><span class="cov8" title="1">{
                // Without a model reference, there is nothing to do. This scenario can occur during diagramElement deletion.
                return nil
        }</span>
        <span class="cov8" title="1">modelElement := GetReferencedModelElement(diagramElement, trans)
        switch notification.GetNatureOfChange() </span>{
        case core.OwnedConceptChanged:<span class="cov8" title="1">
                switch underlyingChange.GetNatureOfChange() </span>{
                case core.ConceptChanged:<span class="cov8" title="1">
                        if underlyingChange.GetReportingElementID() == diagramElementModelReference.GetConceptID(trans) </span><span class="cov0" title="0">{
                                // The underlying change is from the model reference
                                updateDiagramElementForModelElementChange(diagramElement, modelElement, trans)
                        }</span>
                case core.ReferencedConceptChanged:<span class="cov8" title="1">
                        if underlyingChange.GetReportingElementID() == diagramElementModelReference.GetConceptID(trans) </span><span class="cov8" title="1">{
                                // The underlying change is from the model reference
                                if IsDiagramNode(diagramElement, trans) </span><span class="cov8" title="1">{
                                        currentModelElement := underlyingChange.GetAfterConceptState()
                                        previousModelElement := underlyingChange.GetBeforeConceptState()
                                        if currentModelElement != nil &amp;&amp; previousModelElement != nil </span><span class="cov8" title="1">{
                                                if currentModelElement.ReferencedConceptID == "" &amp;&amp; previousModelElement.ReferencedConceptID != "" </span><span class="cov0" title="0">{
                                                        uOfD.DeleteElement(diagramElement, trans)
                                                }</span> else<span class="cov8" title="1"> {
                                                        updateDiagramElementForModelElementChange(diagramElement, modelElement, trans)
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> if IsDiagramLink(diagramElement, trans) </span><span class="cov8" title="1">{
                                        diagram := diagramElement.GetOwningConcept(trans)
                                        if diagram == nil </span><span class="cov8" title="1">{
                                                // There is nothing to do
                                                return nil
                                        }</span>
                                        <span class="cov8" title="1">oldLinkTarget := GetLinkTarget(diagramElement, trans)
                                        oldTargetModelElement := GetReferencedModelElement(oldLinkTarget, trans)
                                        switch typedModelElement := modelElement.(type) </span>{
                                        case core.Reference:<span class="cov8" title="1">
                                                if IsDiagramElementPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                                                        newTargetModelElement := typedModelElement.GetReferencedConcept(trans)
                                                        if oldTargetModelElement != newTargetModelElement </span><span class="cov0" title="0">{
                                                                if newTargetModelElement == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        newTargetDiagramElement := GetFirstElementRepresentingConcept(diagram, newTargetModelElement, trans)
                                                                        SetLinkTarget(diagramElement, newTargetDiagramElement, trans)
                                                                }</span>
                                                        }
                                                } else<span class="cov8" title="1"> if IsDiagramReferenceLink(diagramElement, trans) </span><span class="cov8" title="1">{
                                                        updateDiagramElementForModelElementChange(diagramElement, typedModelElement, trans)
                                                        SetDisplayLabel(diagramElement, typedModelElement.GetLabel(trans), trans)
                                                        newModelTarget := typedModelElement.GetReferencedConcept(trans)
                                                        newModelSource := typedModelElement.GetOwningConcept(trans)
                                                        if newModelSource == nil || newModelTarget == nil </span><span class="cov0" title="0">{
                                                                uOfD.DeleteElement(diagramElement, trans)
                                                                return nil
                                                        }</span>
                                                        <span class="cov8" title="1">currentDiagramSource := GetLinkSource(diagramElement, trans)
                                                        currentModelSource := GetReferencedModelElement(currentDiagramSource, trans)
                                                        currentDiagramTarget := GetLinkTarget(diagramElement, trans)
                                                        currentModelTarget := GetReferencedModelElement(currentDiagramTarget, trans)
                                                        if currentModelSource != newModelSource </span><span class="cov8" title="1">{
                                                                newDiagramSource := GetFirstElementRepresentingConcept(diagram, newModelSource, trans)
                                                                if newDiagramSource == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                        return nil
                                                                }</span>
                                                                <span class="cov8" title="1">SetLinkSource(diagramElement, newDiagramSource, trans)</span>
                                                        }
                                                        <span class="cov8" title="1">if currentModelTarget != newModelTarget </span><span class="cov8" title="1">{
                                                                newDiagramTarget := GetFirstElementRepresentingConcept(diagram, newModelTarget, trans)
                                                                if newDiagramTarget == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                        return nil
                                                                }</span>
                                                                <span class="cov8" title="1">SetLinkTarget(diagramElement, newDiagramTarget, trans)</span>
                                                        }
                                                }
                                        case core.Refinement:<span class="cov8" title="1">
                                                refinement := modelElement.(core.Refinement)
                                                if IsDiagramPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                                                        var newTargetModelElement core.Element
                                                        if IsDiagramAbstractPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                                                                newTargetModelElement = refinement.GetAbstractConcept(trans)
                                                        }</span> else<span class="cov0" title="0"> if IsDiagramRefinedPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                                                                newTargetModelElement = refinement.GetRefinedConcept(trans)
                                                        }</span> else<span class="cov0" title="0"> if IsDiagramOwnerPointer(diagramElement, trans) </span><span class="cov0" title="0">{
                                                                newTargetModelElement = refinement.GetOwningConcept(trans)
                                                        }</span>
                                                        <span class="cov0" title="0">if oldTargetModelElement != newTargetModelElement </span><span class="cov0" title="0">{
                                                                if newTargetModelElement == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        newTargetDiagramElement := GetFirstElementRepresentingConcept(diagram, newTargetModelElement, trans)
                                                                        SetLinkTarget(diagramElement, newTargetDiagramElement, trans)
                                                                }</span>
                                                        }
                                                } else<span class="cov8" title="1"> if IsDiagramRefinementLink(diagramElement, trans) </span><span class="cov8" title="1">{
                                                        updateDiagramElementForModelElementChange(diagramElement, modelElement, trans)
                                                        SetDisplayLabel(diagramElement, refinement.GetLabel(trans), trans)
                                                        newModelTarget := refinement.GetAbstractConcept(trans)
                                                        newModelSource := refinement.GetRefinedConcept(trans)
                                                        if newModelTarget == nil || newModelSource == nil </span><span class="cov0" title="0">{
                                                                uOfD.DeleteElement(diagramElement, trans)
                                                                return nil
                                                        }</span>
                                                        <span class="cov8" title="1">currentDiagramTarget := GetLinkTarget(diagramElement, trans)
                                                        currentModelTarget := GetReferencedModelElement(currentDiagramTarget, trans)
                                                        currentDiagramSource := GetLinkSource(diagramElement, trans)
                                                        currentModelSource := GetReferencedModelElement(currentDiagramSource, trans)
                                                        if currentModelTarget != newModelTarget </span><span class="cov8" title="1">{
                                                                newDiagramTarget := GetFirstElementRepresentingConcept(diagram, newModelTarget, trans)
                                                                if newDiagramTarget == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                        return nil
                                                                }</span>
                                                                <span class="cov8" title="1">SetLinkTarget(diagramElement, newDiagramTarget, trans)</span>
                                                        }
                                                        <span class="cov8" title="1">if currentModelSource != newModelSource </span><span class="cov8" title="1">{
                                                                newDiagramSource := GetFirstElementRepresentingConcept(diagram, newModelSource, trans)
                                                                if newDiagramSource == nil </span><span class="cov0" title="0">{
                                                                        uOfD.DeleteElement(diagramElement, trans)
                                                                        return nil
                                                                }</span>
                                                                <span class="cov8" title="1">SetLinkSource(diagramElement, newDiagramSource, trans)</span>
                                                        }
                                                }
                                        }
                                }
                        }
                case core.IndicatedConceptChanged:<span class="cov8" title="1">
                        indicatedElementChange := underlyingChange.GetUnderlyingChange()
                        indicatedBeforeState := indicatedElementChange.GetBeforeConceptState()
                        indicatedAfterState := indicatedElementChange.GetAfterConceptState()
                        if indicatedBeforeState.Label != indicatedAfterState.Label </span><span class="cov0" title="0">{
                                SetDisplayLabel(diagramElement, indicatedAfterState.Label, trans)
                                diagramElement.SetLabel(indicatedAfterState.Label, trans)
                        }</span>
                }
        case core.ReferencedConceptChanged:<span class="cov0" title="0">
                // We are looking for the model diagramElementModelReference reporting a ConceptChanged which would be the result of setting the referencedConcept
                if notification.GetAfterConceptState().ConceptID != diagramElementModelReference.GetConceptID(trans) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if diagramElementModelReference.GetReferencedConceptID(trans) == "" </span><span class="cov0" title="0">{
                        uOfD.DeleteElement(diagramElement, trans)
                }</span> else<span class="cov0" title="0"> {
                        updateDiagramElementForModelElementChange(diagramElement, modelElement, trans)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// updateDiagramOwnerPointer updates the ownerPointer's target if the ownership of the represented modelElement changes
func updateDiagramOwnerPointer(diagramPointer core.Element, notification *core.ChangeNotification, trans *core.Transaction) error <span class="cov8" title="1">{
        // There is one change of interest here: the model element's owner has changed
        uOfD := trans.GetUniverseOfDiscourse()
        trans.WriteLockElement(diagramPointer)
        reportingElement := uOfD.GetElement(notification.GetReportingElementID())
        diagram := diagramPointer.GetOwningConcept(trans)
        modelElement := GetReferencedModelElement(diagramPointer, trans)
        switch notification.GetNatureOfChange() </span>{
        case core.OwnedConceptChanged:<span class="cov8" title="1">
                if reportingElement == modelElement </span><span class="cov0" title="0">{
                        underlyingNotification := notification.GetUnderlyingChange()
                        switch underlyingNotification.GetNatureOfChange() </span>{
                        case core.OwningConceptChanged:<span class="cov0" title="0">
                                if underlyingNotification.GetAfterConceptState().ConceptID == modelElement.GetConceptID(trans) </span><span class="cov0" title="0">{
                                        modelOwner := modelElement.GetOwningConcept(trans)
                                        var oldModelOwner core.Element
                                        diagramTarget := GetLinkTarget(diagramPointer, trans)
                                        if diagramTarget != nil </span><span class="cov0" title="0">{
                                                oldModelOwner = GetReferencedModelElement(diagramTarget, trans)
                                        }</span>
                                        <span class="cov0" title="0">if modelOwner != oldModelOwner </span><span class="cov0" title="0">{
                                                // Need to determine whether there is a view of the new owner in the diagram
                                                newDiagramTarget := GetFirstElementRepresentingConcept(diagram, modelOwner, trans)
                                                if newDiagramTarget == nil </span><span class="cov0" title="0">{
                                                        // There is no view, delete the modelElement
                                                        dEls := mapset.NewSet(diagramPointer.GetConceptID(trans))
                                                        uOfD.DeleteElements(dEls, trans)
                                                }</span> else<span class="cov0" title="0"> {
                                                        SetLinkTarget(diagramPointer, newDiagramTarget, trans)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">break</span>
                }
                // We are looking for a notification from either the source or target reference in the diagram
                // If either source or target are nil, delete the pointer
                <span class="cov8" title="1">sourceReference := diagramPointer.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkSourceURI, trans)
                targetReference := diagramPointer.GetFirstOwnedReferenceRefinedFromURI(CrlDiagramLinkTargetURI, trans)
                if reportingElement == sourceReference || reportingElement == targetReference </span><span class="cov0" title="0">{
                        underlyingNotification := notification.GetUnderlyingChange()
                        switch underlyingNotification.GetNatureOfChange() </span>{
                        case core.ReferencedConceptChanged:<span class="cov0" title="0">
                                switch typedElement := reportingElement.(type) </span>{
                                case core.Reference:<span class="cov0" title="0">
                                        if typedElement.GetReferencedConcept(trans) == nil </span><span class="cov0" title="0">{
                                                uOfD.DeleteElement(diagramPointer, trans)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func updateDiagramElementForModelElementChange(diagramElement core.Element, modelElement core.Element, trans *core.Transaction) <span class="cov8" title="1">{
        modelElementLabel := ""
        if modelElement != nil </span><span class="cov8" title="1">{
                modelElementLabel = modelElement.GetLabel(trans)
                if modelElementLabel != diagramElement.GetLabel(trans) </span><span class="cov8" title="1">{
                        diagramElement.SetLabel(modelElementLabel, trans)
                        if !IsDiagramPointer(diagramElement, trans) </span><span class="cov8" title="1">{
                                SetDisplayLabel(diagramElement, modelElementLabel, trans)
                        }</span>
                }
                <span class="cov8" title="1">abstractions := make(map[string]core.Element)
                modelElement.FindImmediateAbstractions(abstractions, trans)
                abstractionsLabel := ""
                for _, abs := range abstractions </span><span class="cov0" title="0">{
                        if len(abstractionsLabel) != 0 </span><span class="cov0" title="0">{
                                abstractionsLabel += "\n"
                        }</span>
                        <span class="cov0" title="0">abstractionsLabel += abs.GetLabel(trans)</span>
                }
                <span class="cov8" title="1">if GetAbstractionDisplayLabel(diagramElement, trans) != abstractionsLabel </span><span class="cov0" title="0">{
                        SetAbstractionDisplayLabel(diagramElement, abstractionsLabel, trans)
                }</span>
        }
}

// updateNodeSize recalcualtes the size of the node based on the string sizes for the display label and
// abstractions listed
func updateNodeSize(node core.Element, trans *core.Transaction) <span class="cov8" title="1">{
        displayLabel := GetDisplayLabel(node, trans)
        displayLabelBounds, _ := font.BoundString(go12PtBoldFace, displayLabel)
        displayLabelMaxHeight := Int26_6ToFloat(displayLabelBounds.Max.Y)
        displayLabelMaxWidth := Int26_6ToFloat(displayLabelBounds.Max.X)
        displayLabelMinHeight := Int26_6ToFloat(displayLabelBounds.Min.Y)
        displayLabelMinWidth := Int26_6ToFloat(displayLabelBounds.Min.X)
        displayLabelHeight := displayLabelMaxHeight - displayLabelMinHeight
        displayLabelWidth := displayLabelMaxWidth - displayLabelMinWidth
        abstractionDisplayLabel := GetAbstractionDisplayLabel(node, trans)
        abstractionDisplayLabelBounds, _ := font.BoundString(go10PtItalicFace, abstractionDisplayLabel)
        abstractionDisplayLabelMaxWidth := Int26_6ToFloat(abstractionDisplayLabelBounds.Max.X)
        abstractionDisplayLabelMaxHeight := Int26_6ToFloat(abstractionDisplayLabelBounds.Max.Y)
        abstractionDisplayLabelMinWidth := Int26_6ToFloat(abstractionDisplayLabelBounds.Min.X)
        abstractionDisplayLabelMinHeight := Int26_6ToFloat(abstractionDisplayLabelBounds.Min.Y)
        abstractionDisplayLabelHeight := abstractionDisplayLabelMaxHeight - abstractionDisplayLabelMinHeight
        abstractionDisplayLabelWidth := abstractionDisplayLabelMaxWidth - abstractionDisplayLabelMinWidth
        topHeight := math.Max(IconSize, abstractionDisplayLabelHeight)
        height := topHeight + displayLabelHeight + 2*NodeLineWidth + 3*NodePadWidth
        topWidth := IconSize + 1*NodePadWidth + abstractionDisplayLabelWidth
        width := math.Max(topWidth, displayLabelWidth) + 2*NodeLineWidth + 2*NodePadWidth
        displayLabelYOffset := topHeight + NodeLineWidth + 2*NodePadWidth
        SetNodeHeight(node, height, trans)
        SetNodeWidth(node, width, trans)
        SetNodeDisplayLabelYOffset(node, displayLabelYOffset, trans)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package crleditor

import (
        "encoding/json"
        "log"
        "os"
        "strconv"

        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldatastructuresdomain"
        "github.com/pbrown12303/activeCRL/crldatatypesdomain"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"
        "github.com/pbrown12303/activeCRL/crleditordomain"
        "github.com/pbrown12303/activeCRL/crlmapsdomain"

        "github.com/sqweek/dialog"
)

// UserPreferences are the user preferences for the editor
type UserPreferences struct {
        WorkspacePath               string
        DropDiagramReferenceAsLink  bool
        DropDiagramRefinementAsLink bool
}

// Editor manages one or more CrlEditors
type Editor struct {
        currentSelection            core.Element
        cutBuffer                   map[string]core.Element
        defaultDomainLabelCount     int
        defaultElementLabelCount    int
        defaultLiteralLabelCount    int
        defaultReferenceLabelCount  int
        defaultRefinementLabelCount int
        defaultDiagramLabelCount    int
        editorGUIs                  []EditorGUI
        exitRequested               bool
        home                        string
        settings                    core.Element
        uOfDManager                 *core.UofDManager
        userPreferences             *UserPreferences
        userFolder                  string
        workspaceManager            *CrlWorkspaceManager
}

// NewEditor returns an initialized Editor
func NewEditor(userFolderArg string) *Editor <span class="cov8" title="1">{
        editor := &amp;Editor{}
        var err error
        editor.home, err = os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("User home directory not found")
        }</span>
        <span class="cov8" title="1">editor.userPreferences = &amp;UserPreferences{}
        if userFolderArg == "" </span><span class="cov0" title="0">{
                editor.userFolder = editor.home
        }</span> else<span class="cov8" title="1"> {
                editor.userFolder = userFolderArg
        }</span>
        <span class="cov8" title="1">editor.uOfDManager = &amp;core.UofDManager{}
        editor.workspaceManager = NewCrlWorkspaceManager(editor)
        return editor</span>
}

// AddDiagramToDisplayedList adds the diagramID to the list of displayed diagrams
func (editor *Editor) AddDiagramToDisplayedList(diagramID string, hl *core.Transaction) error <span class="cov8" title="1">{
        if !editor.IsDiagramDisplayed(diagramID, hl) </span><span class="cov8" title="1">{
                openDiagrams := editor.settings.GetFirstOwnedConceptRefinedFromURI(crleditordomain.EditorOpenDiagramsURI, hl)
                _, err := crldatastructuresdomain.AppendStringListMember(openDiagrams, diagramID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "diagramManager.addDiagramToDisplayedList failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddEditorGUI adds an editor to the list of editorGUIs being managed by the
func (editor *Editor) AddEditorGUI(editorGUI EditorGUI) error <span class="cov8" title="1">{
        editor.editorGUIs = append(editor.editorGUIs, editorGUI)
        // err := editorGUI.RegisterUofDInitializationFunctions(editor.uOfDManager)
        // if err != nil {
        //         return errors.Wrap(err, "Editor.AddEditorGUI failed")
        // }
        // err := editorGUI.RegisterUofDPostInitializationFunctions(editor.uOfDManager)
        // if err != nil {
        //         return errors.Wrap(err, "Editor.AddEditorGUI failed")
        // }
        return nil
}</span>

// ClearWorkspace clears all files in the current workspace that correspond to uOfD root elements
// and then reinitializes all editorGUIs.
func (editor *Editor) ClearWorkspace(hl *core.Transaction) error <span class="cov8" title="1">{
        workspacePath := editor.userPreferences.WorkspacePath
        err := editor.workspaceManager.ClearWorkspace(workspacePath, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "crleditor.Editor.ClearWorkspace failed")
        }</span>

        <span class="cov8" title="1">err = editor.Initialize(workspacePath, false)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "crleditor.Editor.ClearWorkspace failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CloseDiagramView removes the diagram from the list of displayed diagrams and informs all GUIs
func (editor *Editor) CloseDiagramView(diagramID string, hl *core.Transaction) error <span class="cov0" title="0">{
        // If the diagram is in the list of displayed diagrams, remove it
        if editor.IsDiagramDisplayed(diagramID, hl) </span><span class="cov0" title="0">{
                editor.RemoveDiagramFromDisplayedList(diagramID, hl)
        }</span>
        <span class="cov0" title="0">for _, gui := range editor.editorGUIs </span><span class="cov0" title="0">{
                err := gui.CloseDiagramView(diagramID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.CloseDiagramView failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CloseWorkspace closes the current workspace, saving the root elements
func (editor *Editor) CloseWorkspace(hl *core.Transaction) error <span class="cov0" title="0">{
        var err error
        if editor.userPreferences.WorkspacePath != "" </span><span class="cov0" title="0">{
                err = editor.workspaceManager.CloseWorkspace(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlEditor.CloseWorkspace failed")
                }</span>
        }
        // The hl here is from the old UofD. Initialize will create a new one, so we first release the locks on the old one
        <span class="cov0" title="0">hl.ReleaseLocks()
        editor.SetWorkspacePath("")
        err = editor.Initialize("", false)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "crleditor.Editor.CloseWorkspace failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createSettings creates the concept space for settings and adds it to the workspace
func (editor *Editor) createSettings(hl *core.Transaction) error <span class="cov8" title="1">{
        newSettings, err := editor.GetUofD().CreateReplicateAsRefinementFromURI(crleditordomain.EditorSettingsURI, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.createSettings failed")
        }</span>
        <span class="cov8" title="1">editor.settings = newSettings
        openDiagrams := editor.settings.GetFirstOwnedConceptRefinedFromURI(crleditordomain.EditorOpenDiagramsURI, hl)
        diagram := editor.GetUofD().GetElementWithURI(crldiagramdomain.CrlDiagramURI)
        crldatastructuresdomain.SetListType(openDiagrams, diagram, hl)
        return nil</span>
}

// DeleteElement removes the element from the UniverseOfDiscourse
func (editor *Editor) DeleteElement(elID string, hl *core.Transaction) error <span class="cov0" title="0">{
        el := editor.GetUofD().GetElement(elID)
        if el != nil </span><span class="cov0" title="0">{
                // TODO: Populate cut buffer with full set of deleted elements
                // editor.cutBuffer = make(map[string]core.Element)
                // editor.cutBuffer[elID] = el
                err := editor.GetUofD().DeleteElement(el, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.DeleteElement failed")
                }</span>
                <span class="cov0" title="0">editor.SelectElement(nil, hl)</span>
        }
        <span class="cov0" title="0">for _, gui := range editor.editorGUIs </span><span class="cov0" title="0">{
                err := gui.ElementDeleted(elID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        errors.Wrap(err, "Editor.DeleteElement failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FileLoaded is used to inform the CrlEditor that a file has been loaded
func (editor *Editor) FileLoaded(el core.Element, hl *core.Transaction) <span class="cov0" title="0">{
        for _, editorGUI := range editor.editorGUIs </span><span class="cov0" title="0">{
                editorGUI.FileLoaded(el, hl)
        }</span>
}

// GetCurrentSelection returns the Element that is the current selection in the editor
func (editor *Editor) GetCurrentSelection() core.Element <span class="cov8" title="1">{
        return editor.currentSelection
}</span>

// GetCurrentSelectionID returns the ConceptID of the currently selected Element
func (editor *Editor) GetCurrentSelectionID(hl *core.Transaction) string <span class="cov0" title="0">{
        if editor.currentSelection == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return editor.currentSelection.GetConceptID(hl)</span>
}

// GetDefaultDomainLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultDomainLabel() string <span class="cov8" title="1">{
        editor.defaultDomainLabelCount++
        countString := strconv.Itoa(editor.defaultDomainLabelCount)
        return "Domain" + countString
}</span>

// GetDefaultDiagramLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultDiagramLabel() string <span class="cov8" title="1">{
        editor.defaultDiagramLabelCount++
        countString := strconv.Itoa(editor.defaultDiagramLabelCount)
        return "Diagram" + countString
}</span>

// GetDefaultElementLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultElementLabel() string <span class="cov8" title="1">{
        editor.defaultElementLabelCount++
        countString := strconv.Itoa(editor.defaultElementLabelCount)
        return "Element" + countString
}</span>

// GetDefaultLiteralLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultLiteralLabel() string <span class="cov8" title="1">{
        editor.defaultLiteralLabelCount++
        countString := strconv.Itoa(editor.defaultLiteralLabelCount)
        return "Literal" + countString
}</span>

// GetDefaultReferenceLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultReferenceLabel() string <span class="cov8" title="1">{
        editor.defaultReferenceLabelCount++
        countString := strconv.Itoa(editor.defaultReferenceLabelCount)
        return "Reference" + countString
}</span>

// GetDefaultRefinementLabel increments the default label count and returns a label containing the new count
func (editor *Editor) GetDefaultRefinementLabel() string <span class="cov8" title="1">{
        editor.defaultRefinementLabelCount++
        countString := strconv.Itoa(editor.defaultRefinementLabelCount)
        return "Refinement" + countString
}</span>

// GetDropDiagramReferenceAsLink returns true if dropped references are shown as links
func (editor *Editor) GetDropDiagramReferenceAsLink(hl *core.Transaction) bool <span class="cov8" title="1">{
        return editor.userPreferences.DropDiagramReferenceAsLink
}</span>

// GetDropDiagramRefinementAsLink returns true if dropped refinements are shown as links
func (editor *Editor) GetDropDiagramRefinementAsLink(hl *core.Transaction) bool <span class="cov8" title="1">{
        return editor.userPreferences.DropDiagramRefinementAsLink
}</span>

// GetExitRequested returns true if exit has been requested
func (editor *Editor) GetExitRequested() bool <span class="cov0" title="0">{
        return editor.exitRequested
}</span>

// getNoSaveDomains returns a map of the editor domains that should not be saved
func (editor *Editor) getNoSaveDomains(hl *core.Transaction) map[string]core.Element <span class="cov0" title="0">{
        noSaveDomains := make(map[string]core.Element)
        for _, editor := range editor.editorGUIs </span><span class="cov0" title="0">{
                editor.GetNoSaveDomains(noSaveDomains, hl)
        }</span>
        <span class="cov0" title="0">return noSaveDomains</span>
}

// GetSettings returns the editor settings
func (editor *Editor) GetSettings() core.Element <span class="cov8" title="1">{
        return editor.settings
}</span>

// GetUofD returns the current UniverseOfDiscourse
func (editor *Editor) GetUofD() *core.UniverseOfDiscourse <span class="cov8" title="1">{
        return editor.uOfDManager.UofD
}</span>

// GetUserPreferences returns the current user's preferences
func (editor *Editor) GetUserPreferences() *UserPreferences <span class="cov8" title="1">{
        return editor.userPreferences
}</span>

// getUserPreferencesPath returns the path to the user preferences
func (editor *Editor) getUserPreferencesPath() string <span class="cov8" title="1">{
        return editor.userFolder + "/.crleditoruserpreferences"
}</span>

// GetWorkspacePath return the path to the current workspace
func (editor *Editor) GetWorkspacePath() string <span class="cov0" title="0">{
        return editor.userPreferences.WorkspacePath
}</span>

// Initialize initializes the uOfD, workspace manager, and all registered editorGUIs
func (editor *Editor) Initialize(workspacePath string, promptWorkspaceSelection bool) error <span class="cov8" title="1">{
        editor.settings = nil
        editor.uOfDManager.Initialize()
        if editor.workspaceManager == nil </span><span class="cov0" title="0">{
                editor.workspaceManager = NewCrlWorkspaceManager(editor)
        }</span>
        <span class="cov8" title="1">editor.workspaceManager.Initialize()
        editor.workspaceManager.LoadUserPreferences(workspacePath)
        if workspacePath != "" &amp;&amp; editor.userPreferences.WorkspacePath != workspacePath </span><span class="cov0" title="0">{
                editor.SetWorkspacePath(workspacePath)
        }</span>
        <span class="cov8" title="1">if editor.userPreferences.WorkspacePath == "" &amp;&amp; promptWorkspaceSelection </span><span class="cov0" title="0">{
                workspacePath, err := editor.SelectWorkspace()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Initialize failed")
                }</span>
                <span class="cov0" title="0">err = editor.SetWorkspacePath(workspacePath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Initialize failed")
                }</span>
        }
        <span class="cov8" title="1">editor.cutBuffer = make(map[string]core.Element)
        hl := editor.uOfDManager.UofD.NewTransaction()
        defer hl.ReleaseLocks()
        editor.resetDefaultLabelCounts()

        crldatatypesdomain.BuildCrlDataTypesDomain(editor.GetUofD(), hl)
        crldatastructuresdomain.BuildCrlDataStructuresDomain(editor.GetUofD(), hl)
        crldiagramdomain.BuildCrlDiagramDomain(editor.GetUofD(), hl)
        crleditordomain.BuildEditorDomain(editor.GetUofD(), hl)
        err := crlmapsdomain.BuildCrlMapsDomain(editor.GetUofD(), hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.Initialize failed")
        }</span>

        <span class="cov8" title="1">for _, editorGUI := range editor.editorGUIs </span><span class="cov8" title="1">{
                err = editorGUI.Initialize(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Initialize failed")
                }</span>
        }

        <span class="cov8" title="1">if editor.userPreferences.WorkspacePath != "" </span><span class="cov8" title="1">{
                err = editor.workspaceManager.LoadWorkspace(hl)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.Initialize failed")
        }</span>
        <span class="cov8" title="1">if editor.settings == nil </span><span class="cov8" title="1">{
                err = editor.createSettings(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Initialize failed")
                }</span>
        }

        <span class="cov8" title="1">for _, editorGUI := range editor.editorGUIs </span><span class="cov8" title="1">{
                err = editorGUI.InitializeGUI(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Initialize failed")
                }</span>
        }

        <span class="cov8" title="1">editor.uOfDManager.UofD.SetRecordingUndo(true)
        return nil</span>
}

// InitializeGUI tells all GUIs to initialize their state
func (editor *Editor) InitializeGUI(hl *core.Transaction) error <span class="cov8" title="1">{
        for _, gui := range editor.editorGUIs </span><span class="cov8" title="1">{
                err := gui.InitializeGUI(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.InitializeGUI failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// IsDiagramDisplayed returns true if the diagram is in the list of displayed diagrams
func (editor *Editor) IsDiagramDisplayed(diagramID string, hl *core.Transaction) bool <span class="cov8" title="1">{
        openDiagrams := editor.settings.GetFirstOwnedConceptRefinedFromURI(crleditordomain.EditorOpenDiagramsURI, hl)
        return crldatastructuresdomain.IsStringListMember(openDiagrams, diagramID, hl)
}</span>

// LoadWorkspace tells the editor to load the workspace
func (editor *Editor) LoadWorkspace(hl *core.Transaction) error <span class="cov0" title="0">{
        err := editor.workspaceManager.LoadWorkspace(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.LoadWorkspace failed")
        }</span>
        <span class="cov0" title="0">if editor.settings == nil </span><span class="cov0" title="0">{
                err = editor.createSettings(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.LoadWorkspace failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// OpenWorkspace sets the path to the folder to be used as a workspace. It is the implementation of a request from the client.
func (editor *Editor) OpenWorkspace() error <span class="cov0" title="0">{
        if editor.userPreferences.WorkspacePath != "" </span><span class="cov0" title="0">{
                return errors.New("Cannot open another workspace in the same editor - close existing workspace first")
        }</span>
        <span class="cov0" title="0">path, err2 := editor.SelectWorkspace()
        if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>
        <span class="cov0" title="0">return editor.Initialize(path, false)</span>
}

// func (editor *Editor) openWorkspaceImpl(path string, hl *core.HeldLocks) error {
//         err := editor.Initialize(path, false)
//         if err != nil {
//                 return errors.Wrap(err, "Editor.openWorkspaceImpl failed")
//         }
//         return nil
// }

// // OpenWorkspaceProgrammatically is intended for use in automated testing scenarios
// func (editor *Editor) OpenWorkspaceProgrammatically(path string, hl *core.HeldLocks) error {
//         defer hl.ReleaseLocksAndWait()
//         if path == "" {
//                 return errors.New("OpenWorkspaceProgrammatically called with empty path")
//         }
//         return editor.openWorkspaceImpl(path, hl)
// }

// Redo performs an undo on the editor.editor.GetUofD() and refreshes the interface
func (editor *Editor) Redo(hl *core.Transaction) error <span class="cov8" title="1">{
        editor.GetUofD().Redo(hl)
        err := editor.InitializeGUI(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.Redo failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RemoveDiagramFromDisplayedList removes the diagramID from the list of displayed diagrams
func (editor *Editor) RemoveDiagramFromDisplayedList(diagramID string, hl *core.Transaction) <span class="cov0" title="0">{
        if editor.IsDiagramDisplayed(diagramID, hl) </span><span class="cov0" title="0">{
                openDiagrams := editor.settings.GetFirstOwnedConceptRefinedFromURI(crleditordomain.EditorOpenDiagramsURI, hl)
                crldatastructuresdomain.RemoveStringListMember(openDiagrams, diagramID, hl)
        }</span>
}

// ResetDefaultLabelCounts re-initializes the default counters for all new model elements
func (editor *Editor) resetDefaultLabelCounts() <span class="cov8" title="1">{
        editor.defaultDomainLabelCount = 0
        editor.defaultElementLabelCount = 0
        editor.defaultLiteralLabelCount = 0
        editor.defaultReferenceLabelCount = 0
        editor.defaultRefinementLabelCount = 0
        editor.defaultDiagramLabelCount = 0
}</span>

// SaveUserPreferences saves the current user preferences to the user's home directory
func (editor *Editor) SaveUserPreferences() error <span class="cov0" title="0">{
        f, err := os.OpenFile(editor.getUserPreferencesPath(), os.O_RDWR|os.O_CREATE, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">serializedUserPreferences, err2 := json.Marshal(editor.userPreferences)
        if err2 != nil </span><span class="cov0" title="0">{
                return err2
        }</span>
        <span class="cov0" title="0">_, err = f.Write(serializedUserPreferences)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = f.Truncate(int64(len(serializedUserPreferences)))
        if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SaveWorkspace saves the workspace
func (editor *Editor) SaveWorkspace(hl *core.Transaction) error <span class="cov0" title="0">{
        err := editor.workspaceManager.SaveWorkspace(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Editor.SaveWorkspace failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SelectElement selects the indicated Element in the tree, displays the Element in the Properties window, and selects it in the
// current diagram (if present).
func (editor *Editor) SelectElement(el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        editor.currentSelection = el
        for _, gui := range editor.editorGUIs </span><span class="cov8" title="1">{
                err := gui.ElementSelected(el, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.SelectElement failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SelectElementUsingIDString selects the Element whose ConceptID matches the supplied string
func (editor *Editor) SelectElementUsingIDString(id string, hl *core.Transaction) error <span class="cov8" title="1">{
        foundElement := editor.GetUofD().GetElement(id)
        if foundElement == nil &amp;&amp; id != "" </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.SelectElementUsingIDString, element was not found")
        }</span>
        <span class="cov8" title="1">return editor.SelectElement(foundElement, hl)</span>
}

// SelectWorkspace opens a dialog for the user to select a workspace
func (editor *Editor) SelectWorkspace() (string, error) <span class="cov0" title="0">{
        return dialog.Directory().Title("Select a directory for your workspace").Browse()
}</span>

func (editor *Editor) setSettings(settings core.Element, hl *core.Transaction) error <span class="cov0" title="0">{
        if settings == nil </span><span class="cov0" title="0">{
                return errors.New("Editor.setSettings called with nil settings")
        }</span>
        <span class="cov0" title="0">if settings.IsRefinementOfURI(crleditordomain.EditorSettingsURI, hl) == false </span><span class="cov0" title="0">{
                return errors.New("Editor.setSettings called with nil settings")
        }</span>
        <span class="cov0" title="0">if editor.settings != nil </span><span class="cov0" title="0">{
                err := editor.GetUofD().DeleteElement(editor.settings, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.setSettings failed")
                }</span>
        }
        <span class="cov0" title="0">editor.settings = settings
        return nil</span>
}

// SetDropDiagramReferenceAsLink returns true if dropped references are shown as links
func (editor *Editor) SetDropDiagramReferenceAsLink(value bool, hl *core.Transaction) <span class="cov0" title="0">{
        editor.userPreferences.DropDiagramReferenceAsLink = value
}</span>

// SetDropDiagramRefinementAsLink returns true if dropped refinements are shown as links
func (editor *Editor) SetDropDiagramRefinementAsLink(value bool, hl *core.Transaction) <span class="cov0" title="0">{
        editor.userPreferences.DropDiagramRefinementAsLink = value
}</span>

// SetExitRequested informs the Editor that exit has been requested. Intended to be used by the GUI
func (editor *Editor) SetExitRequested() <span class="cov0" title="0">{
        editor.exitRequested = true
}</span>

// SetSelectionDefinition is a convenience method for setting the Definition of the currently selected Element
func (editor *Editor) SetSelectionDefinition(definition string, hl *core.Transaction) <span class="cov0" title="0">{
        editor.currentSelection.SetDefinition(definition, hl)
}</span>

// SetSelectionLabel is a convenience method for setting the Label of the currently selected Element
func (editor *Editor) SetSelectionLabel(name string, hl *core.Transaction) <span class="cov0" title="0">{
        editor.currentSelection.SetLabel(name, hl)
}</span>

// SetSelectionURI is a convenience method for setting the URI of the curretly selected Element
func (editor *Editor) SetSelectionURI(uri string, hl *core.Transaction) <span class="cov0" title="0">{
        editor.currentSelection.SetURI(uri, hl)
}</span>

// SetWorkspacePath sets the user's preference WorkspacePath value.
func (editor *Editor) SetWorkspacePath(path string) error <span class="cov0" title="0">{
        editor.userPreferences.WorkspacePath = path
        return editor.SaveUserPreferences()
}</span>

// Undo performs an undo on the editor.GetUofD() and refreshes the interface
func (editor *Editor) Undo(hl *core.Transaction) error <span class="cov8" title="1">{
        editor.GetUofD().Undo(hl)
        for _, gui := range editor.editorGUIs </span><span class="cov8" title="1">{
                err := gui.InitializeGUI(hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Editor.Undo failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// EditorGUI is the interface for all CrlEditors, independent of implementation technology
type EditorGUI interface {
        CloseDiagramView(diagramID string, hl *core.Transaction) error
        ElementDeleted(elID string, hl *core.Transaction) error
        ElementSelected(el core.Element, hl *core.Transaction) error
        FileLoaded(el core.Element, hl *core.Transaction)
        GetNoSaveDomains(noSaveDomains map[string]core.Element, hl *core.Transaction)
        Initialize(hl *core.Transaction) error
        InitializeGUI(hl *core.Transaction) error
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package crleditor

import (
        "encoding/json"
        "io/ioutil"
        "os"
        "strings"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crleditordomain"
        "github.com/pkg/errors"
)

type workspaceFile struct {
        filename      string
        path          string
        File          *os.File
        LoadedVersion int
        Info          os.FileInfo
        Domain        core.Element
}

// CrlWorkspaceManager manages Crl Workspaces
type CrlWorkspaceManager struct {
        editor         *Editor
        workspaceFiles map[string]*workspaceFile
}

// NewCrlWorkspaceManager returns a configured CrlWorkspaceManager
func NewCrlWorkspaceManager(editor *Editor) *CrlWorkspaceManager <span class="cov8" title="1">{
        mgr := &amp;CrlWorkspaceManager{}
        mgr.editor = editor
        return mgr
}</span>

// Initialize initializes or re-initializes the workspace editor
func (mgr *CrlWorkspaceManager) Initialize() <span class="cov8" title="1">{
        mgr.workspaceFiles = make(map[string]*workspaceFile)

}</span>

// ClearWorkspace deletes all of the files in the workspace that correspond to uOfD root elements
// and removes the corresponding entry in workspaceFiles
func (mgr *CrlWorkspaceManager) ClearWorkspace(workspacePath string, hl *core.Transaction) error <span class="cov8" title="1">{
        var err error
        rootElements := mgr.editor.uOfDManager.UofD.GetRootElements(hl)
        for id, wf := range mgr.workspaceFiles </span><span class="cov0" title="0">{
                if rootElements[id] == nil </span><span class="cov0" title="0">{
                        err = mgr.deleteFile(wf)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlEditor.ClearWorkspace failed")
                        }</span>
                        <span class="cov0" title="0">delete(mgr.workspaceFiles, id)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// CloseWorkspace saves and closes all workspace files
func (mgr *CrlWorkspaceManager) CloseWorkspace(hl *core.Transaction) error <span class="cov0" title="0">{
        err := mgr.SaveWorkspace(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlWorkspaceManager.CloseWorkspace failed")
        }</span>
        <span class="cov0" title="0">for _, wsf := range mgr.workspaceFiles </span><span class="cov0" title="0">{
                err = wsf.File.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlWorkspaceManager.CloseWorkspace failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// deleteFile deletes the file from the os
func (mgr *CrlWorkspaceManager) deleteFile(wf *workspaceFile) error <span class="cov0" title="0">{
        err := wf.File.Close()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlEditor.delete file failed")
        }</span>
        <span class="cov0" title="0">err = os.Remove(wf.filename)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlEditor.delete file failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (mgr *CrlWorkspaceManager) generateFilename(el core.Element, hl *core.Transaction) string <span class="cov0" title="0">{
        return mgr.editor.userPreferences.WorkspacePath + "/" + el.GetLabel(hl) + "--" + el.GetConceptID(hl) + ".acrl"
}</span>

// GetUofD returns the current UniverseOfDiscourse
func (mgr *CrlWorkspaceManager) GetUofD() *core.UniverseOfDiscourse <span class="cov0" title="0">{
        return mgr.editor.GetUofD()
}</span>

// newFile creates a file with the name being the ConceptID of the supplied Element and returns the workspaceFile struct
func (mgr *CrlWorkspaceManager) newFile(el core.Element, hl *core.Transaction) (*workspaceFile, error) <span class="cov0" title="0">{
        if mgr.editor.userPreferences.WorkspacePath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("CrlBrowserEditor.NewFile called with no settings.WorkspacePath defined")
        }</span>
        <span class="cov0" title="0">filename := mgr.generateFilename(el, hl)
        file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, err2 := os.Stat(filename)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, err2
        }</span>
        <span class="cov0" title="0">var wf workspaceFile
        wf.filename = filename
        wf.Domain = el
        wf.File = file
        wf.LoadedVersion = el.GetVersion(hl)
        wf.Info = fileInfo
        return &amp;wf, nil</span>
}

// openFile opens the file and returns a workspaceFile struct
func (mgr *CrlWorkspaceManager) openFile(fileInfo os.FileInfo, hl *core.Transaction) (*workspaceFile, error) <span class="cov0" title="0">{
        writable := (fileInfo.Mode().Perm() &amp; 0200) &gt; 0
        mode := os.O_RDONLY
        if writable </span><span class="cov0" title="0">{
                mode = os.O_RDWR
        }</span>
        <span class="cov0" title="0">filename := mgr.editor.userPreferences.WorkspacePath + "/" + fileInfo.Name()
        file, err := os.OpenFile(filename, mode, fileInfo.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileContent := make([]byte, fileInfo.Size())
        _, err = file.Read(fileContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">element, err2 := mgr.GetUofD().RecoverDomain(fileContent, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, err2
        }</span>
        <span class="cov0" title="0">if !writable </span><span class="cov0" title="0">{
                element.SetReadOnlyRecursively(true, hl)
        }</span>
        <span class="cov0" title="0">var wf workspaceFile
        wf.filename = filename
        wf.Domain = element
        wf.Info = fileInfo
        wf.LoadedVersion = element.GetVersion(hl)
        wf.File = file
        return &amp;wf, nil</span>
}

// LoadUserPreferences loads the user preferences saved in the user's home directory
func (mgr *CrlWorkspaceManager) LoadUserPreferences(workspaceArg string) error <span class="cov8" title="1">{
        path := mgr.editor.getUserPreferencesPath()
        _, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                // it is OK to not find the file
                mgr.editor.userPreferences.WorkspacePath = workspaceArg
                return nil
        }</span>
        <span class="cov0" title="0">fileSettings, err2 := ioutil.ReadFile(path)
        if err2 != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(fileSettings, mgr.editor.userPreferences)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LoadWorkspace loads the workspace currently designated by the userPreferences.WorkspacePath. If the path is empty, it is a no-op.
func (mgr *CrlWorkspaceManager) LoadWorkspace(hl *core.Transaction) error <span class="cov8" title="1">{
        files, err := ioutil.ReadDir(mgr.editor.userPreferences.WorkspacePath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlWorkspaceManager.LoadWorkspace failed")
        }</span>

        <span class="cov8" title="1">for _, f := range files </span><span class="cov0" title="0">{
                if strings.HasSuffix(f.Name(), ".acrl") </span><span class="cov0" title="0">{
                        workspaceFile, err := mgr.openFile(f, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlWorkspaceManager.LoadWorkspace failed")
                        }</span>
                        <span class="cov0" title="0">mgr.workspaceFiles[workspaceFile.Domain.GetConceptID(hl)] = workspaceFile
                        if workspaceFile.Domain.IsRefinementOfURI(crleditordomain.EditorSettingsURI, hl) </span><span class="cov0" title="0">{
                                err = mgr.editor.setSettings(workspaceFile.Domain, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlWorkspaceManager.LoadWorkspace failed")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// saveFile saves the file and updates the fileInfo
func (mgr *CrlWorkspaceManager) saveFile(wf *workspaceFile, hl *core.Transaction) error <span class="cov0" title="0">{
        hl.ReadLockElement(wf.Domain)
        if wf.File == nil </span><span class="cov0" title="0">{
                return errors.New("CrlBrowserEditor.SaveFile called with nil file")
        }</span>
        <span class="cov0" title="0">byteArray, err := mgr.GetUofD().MarshalDomain(wf.Domain, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
        }</span>
        <span class="cov0" title="0">var length int
        length, err = wf.File.WriteAt(byteArray, 0)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
        }</span>
        <span class="cov0" title="0">err = wf.File.Truncate(int64(length))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
        }</span>
        <span class="cov0" title="0">err = wf.File.Sync()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
        }</span>
        <span class="cov0" title="0">oldFilename := wf.filename
        newFilename := mgr.generateFilename(wf.Domain, hl)
        if oldFilename != newFilename </span><span class="cov0" title="0">{
                err = wf.File.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
                }</span>
                <span class="cov0" title="0">err = os.Rename(oldFilename, newFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
                }</span>
                <span class="cov0" title="0">wf.filename = newFilename
                wf.File, err = os.OpenFile(newFilename, os.O_RDWR|os.O_CREATE, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
                }</span>
                <span class="cov0" title="0">wf.Info, err = os.Stat(newFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "CrlBrowserEditor.saveFile failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SaveWorkspace saves all top-level concepts whose versions are different than the last retrieved version.
func (mgr *CrlWorkspaceManager) SaveWorkspace(hl *core.Transaction) error <span class="cov0" title="0">{
        rootElements := mgr.editor.uOfDManager.UofD.GetRootElements(hl)
        var err error
        for id, el := range rootElements </span><span class="cov0" title="0">{
                noSaveDomains := mgr.editor.getNoSaveDomains(hl)
                if el.GetIsCore(hl) == false &amp;&amp; noSaveDomains[el.GetConceptID(hl)] == nil </span><span class="cov0" title="0">{
                        workspaceFile := mgr.workspaceFiles[id]
                        if workspaceFile != nil </span><span class="cov0" title="0">{
                                err = mgr.saveFile(workspaceFile, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlWorkspaceManager.SaveWorkspace failed")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                workspaceFile, err = mgr.newFile(el, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlWorkspaceManager.SaveWorkspace failed")
                                }</span>
                                <span class="cov0" title="0">mgr.workspaceFiles[id] = workspaceFile
                                err = mgr.saveFile(workspaceFile, hl)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "CrlWorkspaceManager.SaveWorkspace failed")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for id, wf := range mgr.workspaceFiles </span><span class="cov0" title="0">{
                if rootElements[id] == nil </span><span class="cov0" title="0">{
                        err = mgr.deleteFile(wf)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "CrlWorkspaceManager.SaveWorkspace failed")
                        }</span>
                        <span class="cov0" title="0">delete(mgr.workspaceFiles, id)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package browsergui

import (
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldatastructuresdomain"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"
        "github.com/pbrown12303/activeCRL/crleditor"

        // "github.com/pbrown12303/activeCRL/crleditorbrowserguidomain"
        "github.com/pbrown12303/activeCRL/crleditordomain"
)

// BrowserGUISingleton is the singleton instance of the BrowserGUI
var BrowserGUISingleton *BrowserGUI

// CrlLogClientNotifications enables logging of client notifications when set to true
var CrlLogClientNotifications = false

// CrlLogClientRequests enables the logging of client requests when set to true
var CrlLogClientRequests = false

// BrowserGUI is the browser gui for the CrlEditor. It manages the subordinate managers (Property, Tree, Diagram)
type BrowserGUI struct {
        editor                    *crleditor.Editor
        clientNotificationManager *ClientNotificationManager
        diagramManager            *diagramManager
        initialized               bool
        serverRunning             bool
        startBrowser              bool
        treeDragSelection         core.Element
        treeManager               *treeManager
        propertyManager           *propertyManager
        workingDomain             core.Element
}

// InitializeBrowserGUISingleton initializes the BrowserGUI singleton instance. It should be called once
// when the editor web page is created
func InitializeBrowserGUISingleton(editor *crleditor.Editor, startBrowser bool) <span class="cov8" title="1">{
        browserGUI := &amp;BrowserGUI{}
        browserGUI.editor = editor
        browserGUI.initialized = false
        browserGUI.startBrowser = startBrowser
        BrowserGUISingleton = browserGUI
}</span>

// CloseDiagramView closes the gui display of the diagram
func (bgPtr *BrowserGUI) CloseDiagramView(diagramID string, hl *core.Transaction) error <span class="cov0" title="0">{
        _, err := SendNotification("CloseDiagramView", diagramID, nil, map[string]string{})
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.CloseDiagramView failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createPropertyManager creates an instance of the propertyManager
func (bgPtr *BrowserGUI) createPropertyManager() error <span class="cov8" title="1">{
        pm := &amp;propertyManager{}
        pm.browserGUI = bgPtr
        bgPtr.propertyManager = pm
        return nil
}</span>

// createTreeManager creates an instance of the TreeManager
func (bgPtr *BrowserGUI) createTreeManager(treeID string) error <span class="cov8" title="1">{
        tm := &amp;treeManager{}
        tm.browserGUI = bgPtr
        tm.treeID = treeID
        bgPtr.treeManager = tm
        return nil
}</span>

// DisplayCallGraph opens a new tab and displays the selected graph
func (bgPtr *BrowserGUI) DisplayCallGraph(indexString string, hl *core.Transaction) error <span class="cov0" title="0">{
        index, err := strconv.ParseInt(indexString, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if index == -1 </span><span class="cov0" title="0">{
                // Display them all
                for _, functionCallGraph := range core.GetFunctionCallGraphs() </span><span class="cov0" title="0">{
                        err := bgPtr.displayCallGraph(functionCallGraph, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
                }
        }

        <span class="cov0" title="0">numberOfGraphs := len(core.GetFunctionCallGraphs())
        if index &lt; 0 || index &gt; int64(numberOfGraphs-1) </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.DisplayCallGraph, index is out of bounds")
        }</span>

        <span class="cov0" title="0">functionCallGraph := core.GetFunctionCallGraphs()[index]
        if functionCallGraph == nil </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.DisplayCallGraph, function call graph is nil for index " + indexString)
        }</span>
        <span class="cov0" title="0">return bgPtr.displayCallGraph(functionCallGraph, hl)</span>

}

func (bgPtr *BrowserGUI) displayCallGraph(functionCallGraph *core.FunctionCallGraph, hl *core.Transaction) error <span class="cov0" title="0">{
        graph := functionCallGraph.GetGraph()
        if graph == nil </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.displayCallGraph, graph is nil")
        }</span>
        <span class="cov0" title="0">graphString := graph.String()
        if strings.Contains(graphString, "error") </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.displayCallGraph the graph string contained an error: " + graphString)
        }</span>
        <span class="cov0" title="0">_, err := SendNotification("DisplayGraph", "", nil, map[string]string{"GraphString": graphString})
        return err</span>
}

// ElementDeleted is used to inform the gui that the element has been deleted
func (bgPtr *BrowserGUI) ElementDeleted(elID string, hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// ElementSelected selects the indicated Element in the tree, displays the Element in the Properties window, and selects it in the
// current diagram (if present).
func (bgPtr *BrowserGUI) ElementSelected(el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        elID := ""
        var conceptState *core.ConceptState
        var err error
        if el != nil </span><span class="cov8" title="1">{
                elID = el.GetConceptID(hl)
                conceptState, err = core.NewConceptState(el)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "BrowserGUI.ElementSelected failed")
                }</span>
        }
        <span class="cov8" title="1">_, err = SendNotification("ElementSelected", elID, conceptState, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "In BrowserGUI.SelectElement, SendNotification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FileLoaded informs the BrowserGUI that a file has been loaded
func (bgPtr *BrowserGUI) FileLoaded(el core.Element, hl *core.Transaction) <span class="cov0" title="0">{
        bgPtr.treeManager.addNodeRecursively(el, hl)
}</span>

// GetAdHocTrace returns the value of the AdHocTrace variable used in troubleshooting
func (bgPtr *BrowserGUI) GetAdHocTrace() bool <span class="cov0" title="0">{
        return core.AdHocTrace
}</span>

// GetAvailableGraphCount returns the number of available call graphs
func (bgPtr *BrowserGUI) GetAvailableGraphCount() int <span class="cov0" title="0">{
        return len(core.GetFunctionCallGraphs())
}</span>

// GetClientNotificationManager returns the ClientNotificationManager used to send notifications to the client
func (bgPtr *BrowserGUI) GetClientNotificationManager() *ClientNotificationManager <span class="cov8" title="1">{
        return bgPtr.clientNotificationManager
}</span>

// getDiagramManager returns the DiagramManager
func (bgPtr *BrowserGUI) getDiagramManager() *diagramManager <span class="cov8" title="1">{
        return bgPtr.diagramManager
}</span>

// GetNoSaveDomains reports gui-specific domains that should not be saved
func (bgPtr *BrowserGUI) GetNoSaveDomains(noSaveDomains map[string]core.Element, hl *core.Transaction) <span class="cov0" title="0">{
        if bgPtr.workingDomain != nil </span><span class="cov0" title="0">{
                noSaveDomains[bgPtr.workingDomain.GetConceptID(hl)] = bgPtr.workingDomain
        }</span>
}

// GetNumberOfFunctionCalls returns the number of function calls in the graph
func (bgPtr *BrowserGUI) GetNumberOfFunctionCalls() int <span class="cov0" title="0">{
        return len(core.GetFunctionCallGraphs())
}</span>

// GetOmitDiagramRelatedCalls returns the value of core.OmitDiagramRelatedCalls used in troubleshooting
func (bgPtr *BrowserGUI) GetOmitDiagramRelatedCalls() bool <span class="cov8" title="1">{
        return core.OmitDiagramRelatedCalls
}</span>

// GetOmitHousekeepingCalls returns the value of core.OmitHousekeepingCalls used in troubleshooting
func (bgPtr *BrowserGUI) GetOmitHousekeepingCalls() bool <span class="cov8" title="1">{
        return core.OmitHousekeepingCalls
}</span>

// GetOmitManageTreeNodesCalls returns the value of core.OmitManageTreeNodesCalls used in troubleshooting
func (bgPtr *BrowserGUI) GetOmitManageTreeNodesCalls() bool <span class="cov8" title="1">{
        return core.OmitManageTreeNodesCalls
}</span>

// GetTraceChange returns the value of the core.TraceChange variable used in troubleshooting
func (bgPtr *BrowserGUI) GetTraceChange() bool <span class="cov8" title="1">{
        return core.TraceChange
}</span>

// GetIconPath returns the path to the icon to be used in representing the given Element
func GetIconPath(el core.Element, hl *core.Transaction) string <span class="cov8" title="1">{
        isDiagram := crldiagramdomain.IsDiagram(el, hl)
        switch el.(type) </span>{
        case core.Reference:<span class="cov8" title="1">
                return "/icons/ReferenceIcon.svg"</span>
        case core.Literal:<span class="cov8" title="1">
                return "/icons/LiteralIcon.svg"</span>
        case core.Refinement:<span class="cov8" title="1">
                return "/icons/RefinementIcon.svg"</span>
        case core.Element:<span class="cov8" title="1">
                if isDiagram </span><span class="cov8" title="1">{
                        return "/icons/DiagramIcon.svg"
                }</span>
                <span class="cov8" title="1">return "/icons/ElementIcon.svg"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// GetTreeDragSelection returns the Element currently being dragged from the tree
func (bgPtr *BrowserGUI) GetTreeDragSelection() core.Element <span class="cov8" title="1">{
        return bgPtr.treeDragSelection
}</span>

// GetTreeDragSelectionID returns the ConceptID of the Element being dragged from the tree
func (bgPtr *BrowserGUI) GetTreeDragSelectionID(hl *core.Transaction) string <span class="cov8" title="1">{
        return bgPtr.treeDragSelection.GetConceptID(hl)
}</span>

// getTreeManager returns the TreeManager
func (bgPtr *BrowserGUI) getTreeManager() *treeManager <span class="cov8" title="1">{
        return bgPtr.treeManager
}</span>

// GetUofD returns the UniverseOfDiscourse being edited by this editor
func (bgPtr *BrowserGUI) GetUofD() *core.UniverseOfDiscourse <span class="cov8" title="1">{
        return bgPtr.editor.GetUofD()
}</span>

// Initialize must be called before any editor operation.
func (bgPtr *BrowserGUI) Initialize(hl *core.Transaction) error <span class="cov8" title="1">{
        if bgPtr.treeManager == nil </span><span class="cov8" title="1">{
                bgPtr.createTreeManager("#uOfD()")
        }</span>
        <span class="cov8" title="1">err := bgPtr.treeManager.initialize(hl)
        if err != nil </span><span class="cov0" title="0">{
                errors.Wrap(err, "BrowserGUI.Initialize failed")
        }</span>
        <span class="cov8" title="1">if bgPtr.diagramManager == nil </span><span class="cov8" title="1">{
                bgPtr.diagramManager = newDiagramManager(bgPtr)
        }</span>
        <span class="cov8" title="1">err = bgPtr.diagramManager.initialize()
        if err != nil </span><span class="cov0" title="0">{
                errors.Wrap(err, "BrowserGUI.Initialize failed")
        }</span>
        <span class="cov8" title="1">if bgPtr.clientNotificationManager == nil </span><span class="cov8" title="1">{
                bgPtr.clientNotificationManager = newClientNotificationManager()
        }</span>
        <span class="cov8" title="1">if bgPtr.propertyManager == nil </span><span class="cov8" title="1">{
                bgPtr.createPropertyManager()
        }</span>
        <span class="cov8" title="1">err = bgPtr.propertyManager.initialize(hl)
        if err != nil </span><span class="cov0" title="0">{
                errors.Wrap(err, "BrowserGUI.Initialize failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InitializeGUI sets the client state after a browser refresh.
func (bgPtr *BrowserGUI) InitializeGUI(hl *core.Transaction) error <span class="cov8" title="1">{
        if !bgPtr.serverRunning </span><span class="cov8" title="1">{
                go bgPtr.StartServer()
                for !bgPtr.IsInitialized() </span><span class="cov8" title="1">{
                        time.Sleep(100 * time.Millisecond)
                }</span>
                <span class="cov8" title="1">bgPtr.serverRunning = true</span>
        }
        <span class="cov8" title="1">err := bgPtr.initializeClientState(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Error in BrowserGUI.InitializeGUI")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// initializeClientState sets the client state at any desired time
func (bgPtr *BrowserGUI) initializeClientState(hl *core.Transaction) error <span class="cov8" title="1">{
        err := bgPtr.getTreeManager().initializeTree(hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.initializeClientState failed")
        }</span>
        <span class="cov8" title="1">bgPtr.SendUserPreferences(hl)
        bgPtr.SendDebugSettings()
        bgPtr.SendWorkspacePath()
        bgPtr.SendClearDiagrams()
        _, err = SendNotification("ElementSelected", "", nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.initializeClientState failed")
        }</span>
        <span class="cov8" title="1">openDiagrams := bgPtr.editor.GetSettings().GetFirstOwnedConceptRefinedFromURI(crleditordomain.EditorOpenDiagramsURI, hl)
        if openDiagrams == nil </span><span class="cov0" title="0">{
                return errors.New("In BrowserGUI.initializeClientState, openDiagrams is nil")
        }</span>
        <span class="cov8" title="1">openDiagramLiteral, err2 := crldatastructuresdomain.GetFirstMemberLiteral(openDiagrams, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "In BrowserGUI.initializeClientState getting first member literal failed")
        }</span>
        <span class="cov8" title="1">for openDiagramLiteral != nil </span><span class="cov8" title="1">{
                diagram := bgPtr.editor.GetUofD().GetElement(openDiagramLiteral.GetLiteralValue(hl))
                if diagram == nil </span><span class="cov0" title="0">{
                        log.Printf("In BrowserGui.initializeClientState: Failed to load diagram with ID: %s", openDiagramLiteral.GetLiteralValue(hl))
                        continue</span>
                }
                <span class="cov8" title="1">err2 = bgPtr.diagramManager.displayDiagram(diagram, hl)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "In BrowserGUI.initializeClientState diagram "+diagram.GetLabel(hl)+" did not display")
                }</span>
                <span class="cov8" title="1">openDiagramLiteral, _ = crldatastructuresdomain.GetNextMemberLiteral(openDiagramLiteral, hl)</span>
        }
        <span class="cov8" title="1">bgPtr.SendClientInitializationComplete()
        return nil</span>
}

// IsInitialized returns true if the editor's initialization is complete
func (bgPtr *BrowserGUI) IsInitialized() bool <span class="cov8" title="1">{
        return bgPtr.initialized
}</span>

func (bgPtr *BrowserGUI) nullifyReferencedConcept(refID string, hl *core.Transaction) error <span class="cov0" title="0">{
        ref := bgPtr.editor.GetUofD().GetReference(refID)
        if ref == nil </span><span class="cov0" title="0">{
                return errors.New("BrowserGUI.nullifyReferencedConcept called with refID not found in bgPtr.editor.GetUofD()")
        }</span>
        <span class="cov0" title="0">err := ref.SetReferencedConceptID("", core.NoAttribute, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.nullifyReferencedConcept failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RegisterUofDInitializationFunctions adds the functions required to initialize the UofD for
// BrowserEditor purposes
// func (bgPtr *BrowserGUI) RegisterUofDInitializationFunctions(uOfDMgr *core.UofDManager) error {
//         uOfDMgr.AddInitializationFunction(initializeUofDForBrowserGUI)
//         return nil
// }

// RegisterUofDPostInitializationFunctions adds the editor-specific functions to be executed
// after a bgPtr.editor.GetUofD() initialization
// func (bgPtr *BrowserGUI) RegisterUofDPostInitializationFunctions(uOfDMgr *core.UofDManager) error {
//         uOfDMgr.AddPostInitializationFunction(func(uOfD *core.UniverseOfDiscourse, hl *core.HeldLocks) error {
//                 // Create editor working concept space
//                 BrowserGUISingleton.workingDomain, _ = uOfD.NewElement(hl)
//                 BrowserGUISingleton.workingDomain.SetLabel("BrowserGUIWorkingCS", hl)
//                 // err := BrowserGUISingleton.Initialize(hl)
//                 // if err != nil {
//                 //         return errors.Wrap(err, "BrowserGUI post-initialization function failed")
//                 // }
//                 // err = BrowserGUISingleton.initializeClientState(hl)
//                 // if err != nil {
//                 //         return errors.Wrap(err, "BrowserGUI post-initialization function failed")
//                 // }
//                 registerDiagramViewMonitorFunctions(uOfD)
//                 // BrowserGUISingleton.initialized = true
//                 return nil
//         })
//         return nil
// }

// func initializeUofDForBrowserGUI(uOfD *core.UniverseOfDiscourse, hl *core.HeldLocks) error {
//         _, err := AddBrowserGUIDomain(uOfD, hl)
//         if err != nil {
//                 return errors.Wrap(err, "BrowserGUI PostInitializaton failed")
//         }
//         hl.ReleaseLocksAndWait()
//         return nil
// }

// SendClearDiagrams tells the client to close all displayed diagrams
func (bgPtr *BrowserGUI) SendClearDiagrams() <span class="cov8" title="1">{
        bgPtr.SendNotification("ClearDiagrams", "", nil, nil)
}</span>

// SendClientInitializationComplete tells the client that all initialization activities have been performed
func (bgPtr *BrowserGUI) SendClientInitializationComplete() <span class="cov8" title="1">{
        bgPtr.SendNotification("InitializationComplete", "", nil, nil)
}</span>

// SendDebugSettings sends the trace settings to the client so that they can be edited
func (bgPtr *BrowserGUI) SendDebugSettings() <span class="cov8" title="1">{
        params := make(map[string]string)
        params["EnableNotificationTracing"] = strconv.FormatBool(bgPtr.GetTraceChange())
        params["OmitHousekeepingCalls"] = strconv.FormatBool(bgPtr.GetOmitHousekeepingCalls())
        params["OmitManageTreeNodesCalls"] = strconv.FormatBool(bgPtr.GetOmitManageTreeNodesCalls())
        params["OmitDiagramRelatedCalls"] = strconv.FormatBool(bgPtr.GetOmitDiagramRelatedCalls())
        bgPtr.SendNotification("DebugSettings", "", nil, params)
}</span>

// SendUserPreferences sends the editor settings to the client so that they can be edited
func (bgPtr *BrowserGUI) SendUserPreferences(hl *core.Transaction) <span class="cov8" title="1">{
        params := make(map[string]string)
        params["DropReferenceAsLink"] = strconv.FormatBool(bgPtr.editor.GetDropDiagramReferenceAsLink(hl))
        params["DropRefinementAsLink"] = strconv.FormatBool(bgPtr.editor.GetDropDiagramRefinementAsLink(hl))
        bgPtr.SendNotification("UserPreferences", "", nil, params)
}</span>

// SendNotification calls the ClientNotificationManager method of the same name and returns the result.
func (bgPtr *BrowserGUI) SendNotification(notificationDescription string, id string, elState *core.ConceptState, additionalParameters map[string]string) (*NotificationResponse, error) <span class="cov8" title="1">{
        return bgPtr.GetClientNotificationManager().SendNotification(notificationDescription, id, elState, additionalParameters)
}</span>

// SendWorkspacePath sends the new workspace path to the client
func (bgPtr *BrowserGUI) SendWorkspacePath() <span class="cov8" title="1">{
        params := make(map[string]string)
        params["WorkspacePath"] = bgPtr.editor.GetUserPreferences().WorkspacePath
        bgPtr.SendNotification("WorkspacePath", "", nil, params)
}</span>

// SetAdHocTrace sets the value of the core.AdHocTrace variable used in troubleshooting
func (bgPtr *BrowserGUI) SetAdHocTrace(status bool) <span class="cov0" title="0">{
        core.AdHocTrace = status
}</span>

// SetInitialized tells the BrowserGUI that sockets have been initialized
func (bgPtr *BrowserGUI) SetInitialized() <span class="cov8" title="1">{
        bgPtr.initialized = true
}</span>

// SetTraceChange sets the value of the core.TraceChange variable used in troubleshooting
func (bgPtr *BrowserGUI) SetTraceChange(newValue bool, omitHousekeepingCalls bool, omitManageTreeNodesCalls bool, omitDiagramRelatedCalls bool) <span class="cov0" title="0">{
        core.TraceChange = newValue
        core.OmitHousekeepingCalls = omitHousekeepingCalls
        core.OmitManageTreeNodesCalls = omitManageTreeNodesCalls
        core.OmitDiagramRelatedCalls = omitDiagramRelatedCalls
        core.ClearFunctionCallGraphs()
}</span>

// SetTreeDragSelection identifies the Element as the one being dragged from the tree
func (bgPtr *BrowserGUI) SetTreeDragSelection(elID string) <span class="cov8" title="1">{
        bgPtr.treeDragSelection = bgPtr.GetUofD().GetElement(elID)
}</span>

// ShowConceptInTree shows the concept in the tree
func (bgPtr *BrowserGUI) ShowConceptInTree(concept core.Element, hl *core.Transaction) error <span class="cov0" title="0">{
        if concept == nil </span><span class="cov0" title="0">{
                return errors.New("BrowserGUI.ShowConceptInTree called with nil concept")
        }</span>
        <span class="cov0" title="0">conceptState, err := core.NewConceptState(concept)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.ShowConceptInTree failed")
        }</span>
        <span class="cov0" title="0">_, err2 := bgPtr.SendNotification("ShowTreeNode", concept.GetConceptID(hl), conceptState, nil)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "BrowserGUI.ShowConceptInTree failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateDebugSettings updates the debug-related settings and sends a notification to the client
func (bgPtr *BrowserGUI) UpdateDebugSettings(request *Request) <span class="cov0" title="0">{
        traceChange, err := strconv.ParseBool(request.AdditionalParameters["EnableNotificationTracing"])
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
                return
        }</span>
        <span class="cov0" title="0">omitHousekeeingCalls, err := strconv.ParseBool(request.AdditionalParameters["OmitHousekeepingCalls"])
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
                return
        }</span>
        <span class="cov0" title="0">omitManageTreeNodesCalls, err := strconv.ParseBool(request.AdditionalParameters["OmitManageTreeNodesCalls"])
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
                return
        }</span>
        <span class="cov0" title="0">omitDiagramRelatedCalls, err := strconv.ParseBool(request.AdditionalParameters["OmitDiagramRelatedCalls"])
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
                return
        }</span>
        <span class="cov0" title="0">bgPtr.SetTraceChange(traceChange, omitHousekeeingCalls, omitManageTreeNodesCalls, omitDiagramRelatedCalls)
        bgPtr.SendDebugSettings()</span>
}

// UpdateUserPreferences updates the values of the editor settings and sends a notification of the change to the client.
func (bgPtr *BrowserGUI) UpdateUserPreferences(request *Request, hl *core.Transaction) <span class="cov0" title="0">{
        value, _ := strconv.ParseBool(request.AdditionalParameters["DropReferenceAsLink"])
        bgPtr.editor.SetDropDiagramReferenceAsLink(value, hl)
        value, _ = strconv.ParseBool(request.AdditionalParameters["DropRefinementAsLink"])
        bgPtr.editor.SetDropDiagramRefinementAsLink(value, hl)
        bgPtr.editor.SaveUserPreferences()
        bgPtr.SendUserPreferences(hl)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package browsergui

import (
        "strconv"

        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"

        // "github.com/pbrown12303/activeCRL/crleditorbrowserguidomain"
        "log"
)

// func addDiagramViewFunctionsToUofD(uOfD *core.UniverseOfDiscourse) {
//         uOfD.AddFunction(crldiagramdomain.CrlDiagramURI, updateDiagramView)
//         uOfD.AddFunction(crldiagramdomain.CrlDiagramElementURI, updateDiagramElementView)
// }

// diagramElementManager manages the GUI display of diagram elements
type diagramElementManager struct {
        diagramManager  *diagramManager
        diagramElements map[string]core.Element
}

func newDiagramElementManager(diagramManager *diagramManager) *diagramElementManager <span class="cov8" title="1">{
        dem := &amp;diagramElementManager{}
        dem.diagramManager = diagramManager
        dem.diagramElements = map[string]core.Element{}
        return dem
}</span>

func getLinkAdditionalParameters(link core.Element, hl *core.Transaction) map[string]string <span class="cov8" title="1">{
        var linkType string
        var represents string
        if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramRefinementLinkURI, hl) </span><span class="cov8" title="1">{
                linkType = "RefinementLink"
                represents = "Refinement"
        }</span> else<span class="cov8" title="1"> if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramReferenceLinkURI, hl) </span><span class="cov8" title="1">{
                linkType = "ReferenceLink"
                represents = "Reference"
        }</span> else<span class="cov8" title="1"> if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramOwnerPointerURI, hl) </span><span class="cov8" title="1">{
                linkType = "OwnerPointer"
                represents = "OwnerPointer"
        }</span> else<span class="cov8" title="1"> if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramElementPointerURI, hl) </span><span class="cov8" title="1">{
                linkType = "ElementPointer"
                represents = "ElementPointer"
        }</span> else<span class="cov8" title="1"> if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramAbstractPointerURI, hl) </span><span class="cov8" title="1">{
                linkType = "AbstractPointer"
                represents = "AbstractPointer"
        }</span> else<span class="cov8" title="1"> if link.IsRefinementOfURI(crldiagramdomain.CrlDiagramRefinedPointerURI, hl) </span><span class="cov8" title="1">{
                linkType = "RefinedPointer"
                represents = "RefinedPointer"
        }</span>
        <span class="cov8" title="1">linkSource := crldiagramdomain.GetLinkSource(link, hl)
        linkSourceID := ""
        if linkSource != nil </span><span class="cov8" title="1">{
                linkSourceID = linkSource.GetConceptID(hl)
        }</span>
        <span class="cov8" title="1">linkTarget := crldiagramdomain.GetLinkTarget(link, hl)
        linkTargetID := ""
        if linkTarget != nil </span><span class="cov8" title="1">{
                linkTargetID = linkTarget.GetConceptID(hl)
        }</span>
        <span class="cov8" title="1">additionalParameters := map[string]string{
                "DisplayLabel": crldiagramdomain.GetDisplayLabel(link, hl),
                "Icon":         GetIconPath(crldiagramdomain.GetReferencedModelElement(link, hl), hl),
                "OwnerID":      link.GetOwningConceptID(hl),
                "Abstractions": crldiagramdomain.GetAbstractionDisplayLabel(link, hl),
                "LinkType":     linkType,
                "LinkSourceID": linkSourceID,
                "LinkTargetID": linkTargetID,
                "Represents":   represents}
        return additionalParameters</span>
}

func getNodeAdditionalParameters(node core.Element, hl *core.Transaction) map[string]string <span class="cov8" title="1">{
        var represents string
        referencedModelElement := crldiagramdomain.GetReferencedModelElement(node, hl)
        if referencedModelElement != nil </span><span class="cov8" title="1">{
                switch referencedModelElement.(type) </span>{
                case core.Literal:<span class="cov8" title="1">
                        represents = "Literal"</span>
                case core.Reference:<span class="cov8" title="1">
                        represents = "Reference"</span>
                case core.Refinement:<span class="cov8" title="1">
                        represents = "Refinement"</span>
                case core.Element:<span class="cov8" title="1">
                        represents = "Element"</span>
                }
        }
        <span class="cov8" title="1">additionalParameters := map[string]string{
                "DisplayLabel":        crldiagramdomain.GetDisplayLabel(node, hl),
                "DisplayLabelYOffset": strconv.FormatFloat(crldiagramdomain.GetDisplayLabelYOffset(node, hl), 'f', -1, 64),
                "NodeHeight":          strconv.FormatFloat(crldiagramdomain.GetNodeHeight(node, hl), 'f', -1, 64),
                "NodeWidth":           strconv.FormatFloat(crldiagramdomain.GetNodeWidth(node, hl), 'f', -1, 64),
                "NodeX":               strconv.FormatFloat(crldiagramdomain.GetNodeX(node, hl), 'f', -1, 64),
                "NodeY":               strconv.FormatFloat(crldiagramdomain.GetNodeY(node, hl), 'f', -1, 64),
                "Icon":                GetIconPath(referencedModelElement, hl),
                "OwnerID":             node.GetOwningConceptID(hl),
                "Abstractions":        crldiagramdomain.GetAbstractionDisplayLabel(node, hl),
                "Represents":          represents,
                "LineColor":           crldiagramdomain.GetLineColor(node, hl),
                "BGColor":             crldiagramdomain.GetBGColor(node, hl)}
        return additionalParameters</span>
}

// Update updates the client display of the diagram based on changes to the diagramElement
func (demPtr *diagramElementManager) Update(changeNotification *core.ChangeNotification, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := hl.GetUniverseOfDiscourse()
        if core.TraceChange </span><span class="cov0" title="0">{
                log.Printf("    diagramElementManager: Update called with notification: %s ", changeNotification.GetNatureOfChange().String())
        }</span>

        // if the reportingElementState is nil, this notification comes from the uOfD. We can ignore these (I think)
        <span class="cov8" title="1">if changeNotification.GetReportingElementState() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">diagramElement := uOfD.GetElement(changeNotification.GetReportingElementID())
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("In DiagramElementManager.Update, diagramElement not found in uOfD")
        }</span>
        <span class="cov8" title="1">hl.ReadLockElement(diagramElement)
        if diagramElement.GetUniverseOfDiscourse(hl) != uOfD </span><span class="cov0" title="0">{
                // The diagram element has been removed from the universe of discourse
                priorState := changeNotification.GetBeforeConceptState()
                if priorState != nil </span><span class="cov0" title="0">{
                        additionalParameters := map[string]string{"OwnerID": priorState.OwningConceptID}
                        SendNotification("DeleteDiagramElement", diagramElement.GetConceptID(hl), priorState, additionalParameters)
                }</span>
                <span class="cov0" title="0">diagramElement.Deregister(demPtr)
                delete(demPtr.diagramElements, diagramElement.GetConceptID(hl))
                return nil</span>
        }
        <span class="cov8" title="1">if crldiagramdomain.IsDiagramNode(diagramElement, hl) </span><span class="cov8" title="1">{
                switch changeNotification.GetNatureOfChange() </span>{
                case core.OwningConceptChanged:<span class="cov8" title="1">
                        additionalParameters := getNodeAdditionalParameters(diagramElement, hl)
                        conceptState, err := core.NewConceptState(diagramElement)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "DiagramView.go updateDiagrmElementView failed")
                        }</span>
                        <span class="cov8" title="1">SendNotification("AddDiagramNode", diagramElement.GetConceptID(hl), conceptState, additionalParameters)</span>
                case core.ConceptChanged:<span class="cov8" title="1">
                        currentConcept := changeNotification.GetAfterConceptState()
                        priorConcept := changeNotification.GetBeforeConceptState()
                        if currentConcept != nil &amp;&amp; priorConcept != nil &amp;&amp; currentConcept.Label != priorConcept.Label </span><span class="cov8" title="1">{
                                currentLabel := currentConcept.Label
                                diagramElement.SetLabel(currentLabel, hl)
                                crldiagramdomain.SetDisplayLabel(diagramElement, currentLabel, hl)
                                additionalParameters := getNodeAdditionalParameters(diagramElement, hl)
                                conceptState, err := core.NewConceptState(diagramElement)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "DiagramView.go updateDiagrmElementView failed")
                                }</span>
                                <span class="cov8" title="1">SendNotification("UpdateDiagramNode", diagramElement.GetConceptID(hl), conceptState, additionalParameters)</span>
                        }
                        // case core.OwnedConceptChanged:
                        //         underlyingChange := changeNotification.GetUnderlyingChange()
                        //         underlyingReportingElement := uOfD.GetElement(underlyingChange.GetReportingElementID())
                        //         if crldiagramdomain.IsDisplayLabel(underlyingReportingElement, hl) {
                        //                 underlyingBeforeState := underlyingChange.GetBeforeConceptState()
                        //                 underlyingAfterState := underlyingChange.GetAfterConceptState()
                        //                 beforeDisplayLabel := underlyingBeforeState.LiteralValue
                        //                 afterDisplayLabel := underlyingAfterState.LiteralValue
                        //                 if beforeDisplayLabel != afterDisplayLabel {
                        //                         diagramElement.SetLabel(afterDisplayLabel, hl)
                        //                         additionalParameters := getNodeAdditionalParameters(diagramElement, hl)
                        //                         conceptState, err := core.NewConceptState(diagramElement)
                        //                         if err != nil {
                        //                                 return errors.Wrap(err, "DiagramView.go updateDiagrmElementView failed")
                        //                         }
                        //                         SendNotification("UpdateDiagramNode", diagramElement.GetConceptID(hl), conceptState, additionalParameters)
                        //                 }
                        //         }
                }
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov8" title="1"> if crldiagramdomain.IsDiagramLink(diagramElement, hl) </span><span class="cov8" title="1">{
                // Make sure it actually exists (part of creation protocol)
                additionalParameters := getLinkAdditionalParameters(diagramElement, hl)
                reportingElementState := changeNotification.GetReportingElementState()
                booleanResponse, err := SendNotification("DoesLinkExist", reportingElementState.ConceptID, reportingElementState, additionalParameters)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "DiagramElemantManager.Update failed on DoesLinkExist call")
                }</span>
                <span class="cov8" title="1">if !booleanResponse.BooleanResult </span><span class="cov8" title="1">{
                        _, err := SendNotification("AddDiagramLink", reportingElementState.ConceptID, reportingElementState, additionalParameters)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "DiagramElementManager.Update failed on AddDiagramLink call")
                        }</span>
                }
                <span class="cov8" title="1">switch changeNotification.GetNatureOfChange() </span>{
                case core.OwningConceptChanged:<span class="cov8" title="1">
                        additionalParameters := getLinkAdditionalParameters(diagramElement, hl)
                        conceptState, err := core.NewConceptState(diagramElement)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "DiagramView.go updateDiagrmElementView failed")
                        }</span>
                        <span class="cov8" title="1">SendNotification("AddDiagramLink", diagramElement.GetConceptID(hl), conceptState, additionalParameters)</span>
                case core.ConceptChanged:<span class="cov8" title="1">
                        currentConcept := changeNotification.GetAfterConceptState()
                        priorConcept := changeNotification.GetBeforeConceptState()
                        if currentConcept != nil &amp;&amp; priorConcept != nil &amp;&amp; currentConcept.Label != priorConcept.Label </span><span class="cov8" title="1">{
                                currentLabel := currentConcept.Label
                                diagramElement.SetLabel(currentLabel, hl)
                                crldiagramdomain.SetDisplayLabel(diagramElement, currentLabel, hl)
                                additionalParameters := getLinkAdditionalParameters(diagramElement, hl)
                                conceptState, err := core.NewConceptState(diagramElement)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "DiagramView.go updateDiagrmElementView failed")
                                }</span>
                                <span class="cov8" title="1">SendNotification("UpdateDiagramLink", diagramElement.GetConceptID(hl), conceptState, additionalParameters)</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package browsergui

import (
        "strconv"

        "github.com/pkg/errors"

        //        "fmt"
        "log"

        mapset "github.com/deckarep/golang-set"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"
        // "github.com/pbrown12303/activeCRL/crleditorbrowserguidomain"
)

// diagramManager manages the diagram portion of the UI and all interactions with it
type diagramManager struct {
        browserGUI     *BrowserGUI
        diagrams       map[string]core.Element
        elementManager *diagramElementManager
}

func newDiagramManager(browserGUI *BrowserGUI) *diagramManager <span class="cov8" title="1">{
        dm := &amp;diagramManager{}
        dm.browserGUI = browserGUI
        dm.diagrams = map[string]core.Element{}
        dm.elementManager = newDiagramElementManager(dm)
        return dm
}</span>

func (dmPtr *diagramManager) abstractPointerChanged(linkID string, sourceID string, targetID string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.abstractPointerChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPoiabstractPointerChangednterChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">var modelRefinement core.Refinement
        switch typedModelSource := modelSource.(type) </span>{
        case core.Refinement:<span class="cov8" title="1">
                modelRefinement = typedModelSource</span>
        default:<span class="cov0" title="0">
                return "", errors.New("diagramManager.abstractPointerChanged called with source not being a Refinement")</span>
        }
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.abstractPointerChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.abstractPointerChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">var err error
        var diagramPointer core.Element
        if linkID == "" </span><span class="cov8" title="1">{
                // this is a new link
                diagramPointer, err = crldiagramdomain.NewDiagramAbstractPointer(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                modelRefinement.SetAbstractConcept(modelTarget, hl)
                diagramPointer.SetOwningConceptID(diagramSource.GetOwningConceptID(hl), hl)
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramPointer = uOfD.GetElement(linkID)
                if diagramPointer == nil </span><span class="cov0" title="0">{
                        return "", errors.New("diagramManager.abstractPointerChanged called with diagramPointer not found in diagram")
                }</span>
                <span class="cov0" title="0">if diagramSource != crldiagramdomain.GetLinkSource(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                }</span>
                <span class="cov0" title="0">if diagramTarget != crldiagramdomain.GetLinkTarget(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                }</span>
                <span class="cov0" title="0">if modelSource != crldiagramdomain.GetReferencedModelElement(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                }</span>
                <span class="cov0" title="0">if modelTarget != modelRefinement.GetAbstractConcept(hl) </span><span class="cov0" title="0">{
                        modelRefinement.SetAbstractConcept(modelTarget, hl)
                }</span>
        }

        <span class="cov8" title="1">return diagramPointer.GetConceptID(hl), nil</span>
}

func (dmPtr *diagramManager) addConceptView(request *Request, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramID := request.AdditionalParameters["DiagramID"]
        diagram := uOfD.GetElement(diagramID)
        el := uOfD.GetElement(dmPtr.browserGUI.GetTreeDragSelectionID(hl))
        if el == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Indicated model element not found in addNodeView, ID: " + request.RequestConceptID)
        }</span>
        <span class="cov8" title="1">var x, y float64
        var err error
        x, err = strconv.ParseFloat(request.AdditionalParameters["NodeX"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">y, err = strconv.ParseFloat(request.AdditionalParameters["NodeY"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dmPtr.addConceptViewImpl(uOfD, diagram, el, x, y, hl)</span>
}

// addConceptViewImpl creates the concept view and adds it to the diagram
func (dmPtr *diagramManager) addConceptViewImpl(uOfD *core.UniverseOfDiscourse, diagram core.Element, el core.Element, x float64, y float64, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{

        createAsLink := false
        switch el.(type) </span>{
        case core.Reference:<span class="cov0" title="0">
                createAsLink = dmPtr.browserGUI.editor.GetDropDiagramReferenceAsLink(hl)</span>
        case core.Refinement:<span class="cov0" title="0">
                createAsLink = dmPtr.browserGUI.editor.GetDropDiagramRefinementAsLink(hl)</span>
        }

        <span class="cov8" title="1">var newElement core.Element
        var err error
        if createAsLink </span><span class="cov0" title="0">{
                var modelSourceConcept core.Element
                var modelTargetConcept core.Element
                switch elTyped := el.(type) </span>{
                case core.Reference:<span class="cov0" title="0">
                        newElement, err = crldiagramdomain.NewDiagramReferenceLink(uOfD, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">reference := elTyped
                        modelSourceConcept = reference.GetOwningConcept(hl)
                        modelTargetConcept = reference.GetReferencedConcept(hl)</span>
                case core.Refinement:<span class="cov0" title="0">
                        newElement, err = crldiagramdomain.NewDiagramRefinementLink(uOfD, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">refinement := elTyped
                        modelSourceConcept = refinement.GetRefinedConcept(hl)
                        modelTargetConcept = refinement.GetAbstractConcept(hl)</span>
                }
                <span class="cov0" title="0">if modelSourceConcept == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("In addConceptView for link, modelSourceConcept is nil")
                }</span>
                <span class="cov0" title="0">if modelTargetConcept == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("In addConceptView for link, modelTargetConcept is nil")
                }</span>
                <span class="cov0" title="0">diagramSourceElement := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelSourceConcept, hl)
                if diagramSourceElement == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("In addConceptView for reference link, diagramSourceElement is nil")
                }</span>
                <span class="cov0" title="0">diagramTargetElement := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelTargetConcept, hl)
                if diagramTargetElement == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("In addConceptView for reference link, diagramTargetElement is nil")
                }</span>
                <span class="cov0" title="0">crldiagramdomain.SetLinkSource(newElement, diagramSourceElement, hl)
                crldiagramdomain.SetLinkTarget(newElement, diagramTargetElement, hl)</span>
        } else<span class="cov8" title="1"> {
                newElement, err = crldiagramdomain.NewDiagramNode(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetNodeX(newElement, x, hl)
                crldiagramdomain.SetNodeY(newElement, y, hl)
                crldiagramdomain.SetLineColor(newElement, "#000000", hl)</span>
        }

        <span class="cov8" title="1">err = newElement.SetLabel(el.GetLabel(hl), hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addConceptView failed")
        }</span>
        <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(newElement, el, hl)
        crldiagramdomain.SetDisplayLabel(newElement, el.GetLabel(hl), hl)

        err = newElement.SetOwningConceptID(diagram.GetConceptID(hl), hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addConceptView failed")
        }</span>
        <span class="cov8" title="1">err = newElement.Register(dmPtr.elementManager)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addConceptView failed")
        }</span>

        <span class="cov8" title="1">return newElement, nil</span>
}

// addCopyWithRefinement creates a copy with refinement of the selected item and places it in the diagram.
func (dmPtr *diagramManager) addCopyWithRefinement(request *Request, hl *core.Transaction) (core.Element, error) <span class="cov0" title="0">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramID := request.AdditionalParameters["DiagramID"]
        diagram := uOfD.GetElement(diagramID)
        if diagram == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Diagram not found in diagramManager.addNodeView, ID: " + request.RequestConceptID)
        }</span>
        <span class="cov0" title="0">el := uOfD.GetElement(dmPtr.browserGUI.GetTreeDragSelectionID(hl))
        if el == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Indicated model element not found in diagramManager.addNodeView, ID: " + request.RequestConceptID)
        }</span>
        <span class="cov0" title="0">var x, y float64
        var err error
        x, err = strconv.ParseFloat(request.AdditionalParameters["NodeX"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">y, err = strconv.ParseFloat(request.AdditionalParameters["NodeY"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">copy, err := uOfD.CreateReplicateAsRefinement(el, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addCopyWithRefinement failed")
        }</span>
        <span class="cov0" title="0">copy.SetOwningConcept(diagram.GetOwningConcept(hl), hl)
        _, err2 := dmPtr.addConceptViewImpl(uOfD, diagram, copy, x, y, hl)
        if err2 != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err2, "diagramManager.addCopyWithRefinement failed")
        }</span>
        <span class="cov0" title="0">return copy, nil</span>
}

func (dmPtr *diagramManager) addDiagram(ownerID string, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        diagram, err := dmPtr.newDiagram(hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addDiagram failed")
        }</span>
        <span class="cov8" title="1">err = diagram.SetOwningConceptID(ownerID, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addDiagram failed")
        }</span>
        <span class="cov8" title="1">err = dmPtr.browserGUI.editor.SelectElement(diagram, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addDiagram failed")
        }</span>
        <span class="cov8" title="1">err = dmPtr.displayDiagram(diagram, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.addDiagram failed")
        }</span>
        <span class="cov8" title="1">return diagram, nil</span>
}

func (dmPtr *diagramManager) deleteDiagramElementView(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.deleteDiagramElementView diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">dEls := mapset.NewSet(diagramElement.GetConceptID(hl))
        return dmPtr.browserGUI.GetUofD().DeleteElements(dEls, hl)</span>
}

// diagramClick handles the creation of a new Element and adding a node representation of it to the diagram
func (dmPtr *diagramManager) diagramClick(request *Request, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramID := request.AdditionalParameters["DiagramID"]
        diagram := uOfD.GetElement(diagramID)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.diagramClick called with DiagramID that does not exist")
        }</span>
        <span class="cov8" title="1">var el core.Element
        var err error
        nodeType := request.AdditionalParameters["NodeType"]
        if nodeType == "" </span><span class="cov0" title="0">{
                return errors.New("diagramManager.diagramClick called with no NodeType")
        }</span>
        <span class="cov8" title="1">switch nodeType </span>{
        case "Element":<span class="cov8" title="1">
                el, err = uOfD.NewElement(hl)
                el.SetLabel(dmPtr.browserGUI.editor.GetDefaultElementLabel(), hl)</span>
        case "Literal":<span class="cov8" title="1">
                el, err = uOfD.NewLiteral(hl)
                el.SetLabel(dmPtr.browserGUI.editor.GetDefaultLiteralLabel(), hl)</span>
        case "Reference":<span class="cov8" title="1">
                el, err = uOfD.NewReference(hl)
                el.SetLabel(dmPtr.browserGUI.editor.GetDefaultReferenceLabel(), hl)</span>
        case "Refinement":<span class="cov8" title="1">
                el, err = uOfD.NewRefinement(hl)
                el.SetLabel(dmPtr.browserGUI.editor.GetDefaultRefinementLabel(), hl)</span>
        case "Diagram":<span class="cov0" title="0">
                el, err = crldiagramdomain.NewDiagram(uOfD, hl)
                el.SetLabel(dmPtr.browserGUI.editor.GetDefaultDiagramLabel(), hl)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.diagramClick failed")
        }</span>
        <span class="cov8" title="1">el.SetOwningConceptID(diagram.GetOwningConceptID(hl), hl)
        dmPtr.browserGUI.editor.SelectElement(el, hl)

        // Now the view
        var x, y float64
        x, err = strconv.ParseFloat(request.AdditionalParameters["NodeX"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.diagramClick failed")
        }</span>
        <span class="cov8" title="1">y, err = strconv.ParseFloat(request.AdditionalParameters["NodeY"], 64)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.diagramClick failed")
        }</span>
        <span class="cov8" title="1">var newNode core.Element
        newNode, err = crldiagramdomain.NewDiagramNode(uOfD, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.diagramClick failed")
        }</span>
        <span class="cov8" title="1">err = newNode.Register(dmPtr.elementManager)
        crldiagramdomain.SetNodeX(newNode, x, hl)
        crldiagramdomain.SetNodeY(newNode, y, hl)
        newNode.SetLabel(el.GetLabel(hl), hl)
        crldiagramdomain.SetReferencedModelElement(newNode, el, hl)
        crldiagramdomain.SetDisplayLabel(newNode, el.GetLabel(hl), hl)

        newNode.SetOwningConceptID(diagramID, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.diagramClick failed")
        }</span>
        <span class="cov8" title="1">dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})

        return nil</span>
}

// diagramDrop evaluates the request resulting from a drop in the diagram
func (dmPtr *diagramManager) diagramDrop(request *Request, hl *core.Transaction) error <span class="cov8" title="1">{
        if request.AdditionalParameters["Shift"] == "false" </span><span class="cov8" title="1">{
                _, err := dmPtr.addConceptView(request, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "diagramManager.diagramDrop failed")
                }</span>
                <span class="cov8" title="1">dmPtr.browserGUI.SetTreeDragSelection("")</span>
        } else<span class="cov0" title="0"> {
                _, err := dmPtr.addCopyWithRefinement(request, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "diagramManager.diagramDrop failed")
                }</span>
        }
        <span class="cov8" title="1">dmPtr.browserGUI.SetTreeDragSelection("")
        return nil</span>
}

// DiagramViewHasBeenClosed notifies the server that the client has closed the diagram view
func (dmPtr *diagramManager) DiagramViewHasBeenClosed(diagramID string, hl *core.Transaction) error <span class="cov0" title="0">{
        if dmPtr.browserGUI.editor.IsDiagramDisplayed(diagramID, hl) </span><span class="cov0" title="0">{
                dmPtr.browserGUI.editor.RemoveDiagramFromDisplayedList(diagramID, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// displayDiagram tells the client to display the indicated diagram.
func (dmPtr *diagramManager) displayDiagram(diagram core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        diagramID := diagram.GetConceptID(hl)
        if !diagram.IsRefinementOfURI(crldiagramdomain.CrlDiagramURI, hl) </span><span class="cov0" title="0">{
                return errors.New("In diagramManager.displayDiagram, the supplied diagram is not a refinement of CrlDiagramURI")
        }</span>
        // Make sure the diagram is in the list of displayed diagrams
        <span class="cov8" title="1">if !dmPtr.browserGUI.editor.IsDiagramDisplayed(diagramID, hl) </span><span class="cov8" title="1">{
                err3 := dmPtr.browserGUI.editor.AddDiagramToDisplayedList(diagramID, hl)
                if err3 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err3, "diagramManager.displayDiagram failed")
                }</span>
        }
        // make sure there is a monitor on the diagram so we know when it has been deleted
        <span class="cov8" title="1">err := diagram.Register(dmPtr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.displayDiagram failed")
        }</span>
        // Tell the client to display the diagram
        <span class="cov8" title="1">conceptState, err2 := core.NewConceptState(diagram)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "diagramManager.displayDiagram failed")
        }</span>
        <span class="cov8" title="1">notificationResponse, err := BrowserGUISingleton.GetClientNotificationManager().SendNotification("DisplayDiagram", diagram.GetConceptID(hl), conceptState, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "diagramManager.displayDiagram failed")
        }</span>
        <span class="cov8" title="1">if notificationResponse == nil </span><span class="cov0" title="0">{
                return errors.New("In diagramManager.displayDiagram the notification response was nil")
        }</span>
        <span class="cov8" title="1">if notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                return errors.New("In diagramManager.displayDiagram, notificationResponse was not 0")
        }</span>
        <span class="cov8" title="1">return dmPtr.refreshDiagram(diagram, hl)</span>
}

func (dmPtr *diagramManager) formatChanged(diagramElement core.Element, lineColor string, bgColor string, hl *core.Transaction) error <span class="cov0" title="0">{
        crldiagramdomain.SetLineColor(diagramElement, lineColor, hl)
        crldiagramdomain.SetBGColor(diagramElement, bgColor, hl)
        return nil
}</span>

func (dmPtr *diagramManager) elementPointerChanged(linkID string, sourceID string, targetID string, targetAttributeName string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPointerChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPointerChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">var modelReference core.Reference
        switch typedModelSource := modelSource.(type) </span>{
        case core.Reference:<span class="cov8" title="1">
                modelReference = typedModelSource</span>
        default:<span class="cov0" title="0">
                return "", errors.New("diagramManager.elementPointerChanged called with source not being a Reference")</span>
        }
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPointerChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPointerChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">var err error
        var diagramPointer core.Element
        attributeName := core.NoAttribute
        switch targetAttributeName </span>{
        case "OwningConceptID":<span class="cov8" title="1">
                attributeName = core.OwningConceptID</span>
        case "ReferencedConceptID":<span class="cov8" title="1">
                attributeName = core.ReferencedConceptID</span>
        case "AbstractConceptID":<span class="cov8" title="1">
                attributeName = core.AbstractConceptID</span>
        case "RefinedConceptID":<span class="cov8" title="1">
                attributeName = core.RefinedConceptID</span>
        }
        <span class="cov8" title="1">if linkID == "" </span><span class="cov8" title="1">{
                // this is a new link
                diagramPointer, err = crldiagramdomain.NewDiagramElementPointer(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                modelReference.SetReferencedConcept(modelTarget, attributeName, hl)
                diagramPointer.SetOwningConceptID(diagramSource.GetOwningConceptID(hl), hl)
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramPointer = uOfD.GetElement(linkID)
                if diagramPointer == nil </span><span class="cov0" title="0">{
                        return "", errors.New("diagramManager.elementPointerChanged called with diagramPointer not found in diagram")
                }</span>
                <span class="cov0" title="0">if diagramSource != crldiagramdomain.GetLinkSource(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                }</span>
                <span class="cov0" title="0">if diagramTarget != crldiagramdomain.GetLinkTarget(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                }</span>
                <span class="cov0" title="0">if modelSource != crldiagramdomain.GetReferencedModelElement(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                }</span>
                <span class="cov0" title="0">if attributeName == core.NoAttribute </span><span class="cov0" title="0">{
                        if modelTarget != modelReference.GetReferencedConcept(hl) </span><span class="cov0" title="0">{
                                modelReference.SetReferencedConcept(modelTarget, attributeName, hl)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // for references to pointers, it is the pointer owner that is the referenced concept
                        if modelSource != modelReference.GetReferencedConcept(hl) </span><span class="cov0" title="0">{
                                modelReference.SetReferencedConcept(modelSource, attributeName, hl)
                        }</span>

                }
        }

        <span class="cov8" title="1">return diagramPointer.GetConceptID(hl), nil</span>
}

func (dmPtr *diagramManager) initialize() error <span class="cov8" title="1">{
        dmPtr.diagrams = map[string]core.Element{}
        return nil
}</span>

// newDiagram creates a new crldiagram
func (dmPtr *diagramManager) newDiagram(hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        // Insert name prompt here
        name := dmPtr.browserGUI.editor.GetDefaultDiagramLabel()
        uOfD := BrowserGUISingleton.GetUofD()
        diagram, err := crldiagramdomain.NewDiagram(uOfD, hl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.newDiagram failed")
        }</span>
        <span class="cov8" title="1">diagram.SetLabel(name, hl)
        dmPtr.diagrams[diagram.GetConceptID(hl)] = diagram
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.newDiagram failed")
        }</span>
        <span class="cov8" title="1">err = diagram.Register(dmPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "diagramManager.newDiagram failed")
        }</span>
        <span class="cov8" title="1">return diagram, nil</span>
}

func (dmPtr *diagramManager) ownerPointerChanged(linkID string, sourceID string, targetID string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.ownerPointerChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.ownerPointerChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.ownerPointerChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.ownerPointerChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">var err error
        var diagramPointer core.Element
        if linkID == "" </span><span class="cov8" title="1">{
                // this is a new link
                diagramPointer, err = crldiagramdomain.NewDiagramOwnerPointer(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                modelSource.SetOwningConcept(modelTarget, hl)
                diagramPointer.SetOwningConceptID(diagramSource.GetOwningConceptID(hl), hl)
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramPointer = uOfD.GetElement(linkID)
                if diagramPointer == nil </span><span class="cov0" title="0">{
                        return "", errors.New("diagramManager.ownerPointerChanged called with diagramPointer not found in diagram")
                }</span>
                <span class="cov0" title="0">if diagramSource != crldiagramdomain.GetLinkSource(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                }</span>
                <span class="cov0" title="0">if diagramTarget != crldiagramdomain.GetLinkTarget(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                }</span>
                <span class="cov0" title="0">if modelSource != crldiagramdomain.GetReferencedModelElement(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                }</span>
                <span class="cov0" title="0">if modelTarget != modelSource.GetOwningConcept(hl) </span><span class="cov0" title="0">{
                        modelSource.SetOwningConcept(modelTarget, hl)
                }</span>
        }

        <span class="cov8" title="1">return diagramPointer.GetConceptID(hl), nil</span>
}

func (dmPtr *diagramManager) refinedPointerChanged(linkID string, sourceID string, targetID string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinedPointerChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.elementPoirefinedPointerChangednterChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">var modelRefinement core.Refinement
        switch typedModelSource := modelSource.(type) </span>{
        case core.Refinement:<span class="cov8" title="1">
                modelRefinement = typedModelSource</span>
        default:<span class="cov0" title="0">
                return "", errors.New("diagramManager.refinedPointerChanged called with source not being a Refinement")</span>
        }
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinedPointerChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinedPointerChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">var err error
        var diagramPointer core.Element
        if linkID == "" </span><span class="cov8" title="1">{
                // this is a new link
                diagramPointer, err = crldiagramdomain.NewDiagramRefinedPointer(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                modelRefinement.SetRefinedConcept(modelTarget, hl)
                diagramPointer.SetOwningConceptID(diagramSource.GetOwningConceptID(hl), hl)
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramPointer = uOfD.GetElement(linkID)
                if diagramPointer == nil </span><span class="cov0" title="0">{
                        return "", errors.New("diagramManager.refinedPointerChanged called with diagramPointer not found in diagram")
                }</span>
                <span class="cov0" title="0">if diagramSource != crldiagramdomain.GetLinkSource(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkSource(diagramPointer, diagramSource, hl)
                }</span>
                <span class="cov0" title="0">if diagramTarget != crldiagramdomain.GetLinkTarget(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetLinkTarget(diagramPointer, diagramTarget, hl)
                }</span>
                <span class="cov0" title="0">if modelSource != crldiagramdomain.GetReferencedModelElement(diagramPointer, hl) </span><span class="cov0" title="0">{
                        crldiagramdomain.SetReferencedModelElement(diagramPointer, modelSource, hl)
                }</span>
                <span class="cov0" title="0">if modelTarget != modelRefinement.GetRefinedConcept(hl) </span><span class="cov0" title="0">{
                        modelRefinement.SetRefinedConcept(modelTarget, hl)
                }</span>
        }

        <span class="cov8" title="1">return diagramPointer.GetConceptID(hl), nil</span>
}

func (dmPtr *diagramManager) ReferenceLinkChanged(linkID string, sourceID string, targetID string, targetAttributeName string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">diagram := diagramSource.GetOwningConcept(hl)
        var err error
        var diagramLink core.Element
        var modelElement core.Element
        attributeName := core.NoAttribute
        switch targetAttributeName </span>{
        case "OwningConceptID":<span class="cov8" title="1">
                attributeName = core.OwningConceptID</span>
        case "ReferencedConceptID":<span class="cov8" title="1">
                attributeName = core.ReferencedConceptID</span>
        case "AbstractConceptID":<span class="cov8" title="1">
                attributeName = core.AbstractConceptID</span>
        case "RefinedConceptID":<span class="cov8" title="1">
                attributeName = core.RefinedConceptID</span>
        }
        <span class="cov8" title="1">if linkID == "" </span><span class="cov8" title="1">{
                // this is a new reference
                newReference, _ := uOfD.NewReference(hl)
                newReference.SetReferencedConcept(modelTarget, attributeName, hl)
                newReference.SetOwningConcept(modelSource, hl)
                diagramLink, err = crldiagramdomain.NewDiagramReferenceLink(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">diagramLink.SetOwningConcept(diagram, hl)
                err = diagramLink.Register(dmPtr.elementManager)
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "diagramManager.ReferenceLinkChanged failed")
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramLink, newReference, hl)
                crldiagramdomain.SetLinkSource(diagramLink, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramLink, diagramTarget, hl)
                modelElement = newReference
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramLink = uOfD.GetElement(linkID)
                modelElement = crldiagramdomain.GetReferencedModelElement(diagramLink, hl)
                if modelElement != nil </span><span class="cov0" title="0">{
                        switch typedModelElement := modelElement.(type) </span>{
                        case core.Reference:<span class="cov0" title="0">
                                reference := typedModelElement
                                if diagramLink == nil </span><span class="cov0" title="0">{
                                        return "", errors.New("diagramManager.refinementLinkChanged called with diagramPointer not found in diagram")
                                }</span>
                                <span class="cov0" title="0">if reference.GetOwningConcept(hl) != modelSource </span><span class="cov0" title="0">{
                                        reference.SetOwningConcept(modelSource, hl)
                                }</span>
                                <span class="cov0" title="0">if reference.GetReferencedConcept(hl) != modelTarget </span><span class="cov0" title="0">{
                                        reference.SetReferencedConcept(modelTarget, attributeName, hl)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">dmPtr.browserGUI.editor.SelectElement(modelElement, hl)

        return diagramLink.GetConceptID(hl), nil</span>
}

func (dmPtr *diagramManager) RefinementLinkChanged(linkID string, sourceID string, targetID string, hl *core.Transaction) (string, error) <span class="cov8" title="1">{
        uOfD := dmPtr.browserGUI.GetUofD()
        diagramSource := uOfD.GetElement(sourceID)
        if diagramSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with sourceID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelSource := crldiagramdomain.GetReferencedModelElement(diagramSource, hl)
        if modelSource == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with model source not found")
        }</span>
        <span class="cov8" title="1">diagramTarget := uOfD.GetElement(targetID)
        if diagramTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with targetID not found in diagram")
        }</span>
        <span class="cov8" title="1">modelTarget := crldiagramdomain.GetReferencedModelElement(diagramTarget, hl)
        if modelTarget == nil </span><span class="cov0" title="0">{
                return "", errors.New("diagramManager.refinementLinkChanged called with model target not found")
        }</span>
        <span class="cov8" title="1">diagram := diagramSource.GetOwningConcept(hl)
        diagramOwner := diagram.GetOwningConcept(hl)
        var err error
        var diagramLink core.Element
        var modelElement core.Element
        if linkID == "" </span><span class="cov8" title="1">{
                // this is a new refinement
                newRefinement, _ := uOfD.NewRefinement(hl)
                newRefinement.SetRefinedConcept(modelSource, hl)
                newRefinement.SetAbstractConcept(modelTarget, hl)
                newRefinement.SetOwningConcept(diagramOwner, hl)
                diagramLink, err = crldiagramdomain.NewDiagramRefinementLink(uOfD, hl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">diagramLink.SetOwningConcept(diagram, hl)
                err = diagramLink.Register(dmPtr.elementManager)
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "diagramManager.ReferenceLinkChanged failed")
                }</span>
                <span class="cov8" title="1">crldiagramdomain.SetReferencedModelElement(diagramLink, newRefinement, hl)
                crldiagramdomain.SetLinkSource(diagramLink, diagramSource, hl)
                crldiagramdomain.SetLinkTarget(diagramLink, diagramTarget, hl)
                modelElement = newRefinement
                dmPtr.browserGUI.SendNotification("ClearToolbarSelection", "", nil, map[string]string{})</span>
        } else<span class="cov0" title="0"> {
                diagramLink = uOfD.GetElement(linkID)
                modelElement = crldiagramdomain.GetReferencedModelElement(diagramLink, hl)
                if modelElement != nil </span><span class="cov0" title="0">{
                        switch typedModelElement := modelElement.(type) </span>{
                        case core.Refinement:<span class="cov0" title="0">
                                refinement := typedModelElement
                                if diagramLink == nil </span><span class="cov0" title="0">{
                                        return "", errors.New("diagramManager.refinementLinkChanged called with diagramPointer not found in diagram")
                                }</span>
                                <span class="cov0" title="0">if diagramSource != crldiagramdomain.GetLinkSource(diagramLink, hl) </span><span class="cov0" title="0">{
                                        refinement.SetRefinedConcept(modelSource, hl)
                                }</span>
                                <span class="cov0" title="0">if diagramTarget != crldiagramdomain.GetLinkTarget(diagramLink, hl) </span><span class="cov0" title="0">{
                                        refinement.SetAbstractConcept(modelTarget, hl)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">dmPtr.browserGUI.editor.SelectElement(modelElement, hl)

        return diagramLink.GetConceptID(hl), nil</span>
}

// refreshDiagramUsingURI finds the diagram and resends all diagram elements to the browser
func (dmPtr *diagramManager) refreshDiagramUsingURI(diagramID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagram := dmPtr.browserGUI.GetUofD().GetElement(diagramID)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("In diagramManager.refreshDiagram, diagram not found for ID: " + diagramID)
        }</span>
        <span class="cov0" title="0">return dmPtr.refreshDiagram(diagram, hl)</span>
}

// refreshDiagram resends all diagram elements to the browser
func (dmPtr *diagramManager) refreshDiagram(diagram core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        nodes := diagram.GetOwnedConceptsRefinedFromURI(crldiagramdomain.CrlDiagramNodeURI, hl)
        for _, node := range nodes </span><span class="cov8" title="1">{
                additionalParameters := getNodeAdditionalParameters(node, hl)
                conceptState, err2 := core.NewConceptState(node)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "diagramManager.refreshDiagram failed")
                }</span>
                <span class="cov8" title="1">node.Register(dmPtr.elementManager)
                notificationResponse, err := BrowserGUISingleton.SendNotification("AddDiagramNode", node.GetConceptID(hl), conceptState, additionalParameters)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "diagramManager.refreshDiagram failed")
                }</span>
                <span class="cov8" title="1">if notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                        return errors.New(notificationResponse.ErrorMessage)
                }</span>
        }
        <span class="cov8" title="1">links := diagram.GetOwnedConceptsRefinedFromURI(crldiagramdomain.CrlDiagramLinkURI, hl)
        for _, link := range links </span><span class="cov8" title="1">{
                additionalParameters := getLinkAdditionalParameters(link, hl)
                conceptState, err2 := core.NewConceptState(link)
                if err2 != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err2, "diagramManager.refreshDiagram failed")
                }</span>
                <span class="cov8" title="1">link.Register(dmPtr.elementManager)
                notificationResponse, err := BrowserGUISingleton.SendNotification("AddDiagramLink", link.GetConceptID(hl), conceptState, additionalParameters)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "diagramManager.refreshDiagram failed")
                }</span>
                <span class="cov8" title="1">if notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                        return errors.New(notificationResponse.ErrorMessage)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// setDiagramNodePosition sets the position of the diagram node
func (dmPtr *diagramManager) setDiagramNodePosition(nodeID string, x float64, y float64, hl *core.Transaction) <span class="cov0" title="0">{
        node := BrowserGUISingleton.GetUofD().GetElement(nodeID)
        if node == nil </span><span class="cov0" title="0">{
                // This can happen when the concept space containing the diagram is deleted???
                log.Print("In setDiagramNodePosition node not found for nodeID: " + nodeID)
                return
        }</span>
        <span class="cov0" title="0">crldiagramdomain.SetNodeX(node, x, hl)
        crldiagramdomain.SetNodeY(node, y, hl)</span>
}

func (dmPtr *diagramManager) showAbstractConcept(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showAbstractConcept diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">diagram := diagramElement.GetOwningConcept(hl)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showAbstractConcept diagram not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConcept := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
        if modelConcept == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showAbstractConcept modelConcept not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">var modelRefinement core.Refinement
        switch typedModelConcept := modelConcept.(type) </span>{
        case core.Refinement:<span class="cov0" title="0">
                modelRefinement = typedModelConcept</span>
        default:<span class="cov0" title="0">
                return errors.New("diagramManager.showAbstractConcept modelConcept is not a Refinement")</span>
        }
        <span class="cov0" title="0">modelAbstractConcept := modelRefinement.GetAbstractConcept(hl)
        if modelAbstractConcept == nil </span><span class="cov0" title="0">{
                return errors.New("Abstract Concept is nil")
        }</span>
        <span class="cov0" title="0">diagramAbstractConcept := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelAbstractConcept, hl)
        if diagramAbstractConcept == nil </span><span class="cov0" title="0">{
                diagramAbstractConcept, _ = crldiagramdomain.NewDiagramNode(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(diagramAbstractConcept, modelAbstractConcept, hl)
                crldiagramdomain.SetDisplayLabel(diagramAbstractConcept, modelAbstractConcept.GetLabel(hl), hl)
                diagramElementX := crldiagramdomain.GetNodeX(diagramElement, hl)
                diagramElementY := crldiagramdomain.GetNodeY(diagramElement, hl)
                crldiagramdomain.SetNodeX(diagramAbstractConcept, diagramElementX, hl)
                crldiagramdomain.SetNodeY(diagramAbstractConcept, diagramElementY-100, hl)
                diagramAbstractConcept.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">elementPointer := crldiagramdomain.GetElementPointer(diagram, diagramElement, hl)
        if elementPointer == nil </span><span class="cov0" title="0">{
                elementPointer, _ = crldiagramdomain.NewDiagramAbstractPointer(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(elementPointer, modelConcept, hl)
                crldiagramdomain.SetLinkSource(elementPointer, diagramElement, hl)
                crldiagramdomain.SetLinkTarget(elementPointer, diagramAbstractConcept, hl)
                elementPointer.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (dmPtr *diagramManager) showOwnedConcepts(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwnedConcepts diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">diagram := diagramElement.GetOwningConcept(hl)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwnedConcepts diagram not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConcept := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
        if modelConcept == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwnedConcepts modelConcept not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">it := modelConcept.GetOwnedConceptIDs(hl).Iterator()
        var offset float64
        for id := range it.C </span><span class="cov0" title="0">{
                child := dmPtr.browserGUI.GetUofD().GetElement(id.(string))
                if child == nil </span><span class="cov0" title="0">{
                        return errors.New("Child Concept is nil for id " + id.(string))
                }</span>
                <span class="cov0" title="0">diagramChildConcept := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, child, hl)
                if diagramChildConcept == nil </span><span class="cov0" title="0">{
                        diagramChildConcept, _ = crldiagramdomain.NewDiagramNode(dmPtr.browserGUI.GetUofD(), hl)
                        crldiagramdomain.SetReferencedModelElement(diagramChildConcept, child, hl)
                        crldiagramdomain.SetDisplayLabel(diagramChildConcept, child.GetLabel(hl), hl)
                        diagramElementX := crldiagramdomain.GetNodeX(diagramElement, hl)
                        diagramElementY := crldiagramdomain.GetNodeY(diagramElement, hl)
                        crldiagramdomain.SetNodeX(diagramChildConcept, diagramElementX+offset, hl)
                        crldiagramdomain.SetNodeY(diagramChildConcept, diagramElementY+50, hl)
                        diagramChildConcept.SetOwningConcept(diagram, hl)
                }</span>
                <span class="cov0" title="0">ownerPointer := crldiagramdomain.GetOwnerPointer(diagram, diagramElement, hl)
                if ownerPointer == nil </span><span class="cov0" title="0">{
                        ownerPointer, _ = crldiagramdomain.NewDiagramOwnerPointer(dmPtr.browserGUI.GetUofD(), hl)
                        crldiagramdomain.SetReferencedModelElement(ownerPointer, modelConcept, hl)
                        crldiagramdomain.SetLinkSource(ownerPointer, diagramChildConcept, hl)
                        crldiagramdomain.SetLinkTarget(ownerPointer, diagramElement, hl)
                        ownerPointer.SetOwningConcept(diagram, hl)
                }</span>
                <span class="cov0" title="0">offset = offset + 50</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (dmPtr *diagramManager) showOwner(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwner diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">diagram := diagramElement.GetOwningConcept(hl)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwner diagram not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConcept := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
        if modelConcept == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showOwner modelConcept not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConceptOwner := modelConcept.GetOwningConcept(hl)
        if modelConceptOwner == nil </span><span class="cov0" title="0">{
                return errors.New("Owner is nil")
        }</span>
        <span class="cov0" title="0">diagramConceptOwner := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelConceptOwner, hl)
        if diagramConceptOwner == nil </span><span class="cov0" title="0">{
                diagramConceptOwner, _ = crldiagramdomain.NewDiagramNode(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(diagramConceptOwner, modelConceptOwner, hl)
                crldiagramdomain.SetDisplayLabel(diagramConceptOwner, modelConceptOwner.GetLabel(hl), hl)
                diagramElementX := crldiagramdomain.GetNodeX(diagramElement, hl)
                diagramElementY := crldiagramdomain.GetNodeY(diagramElement, hl)
                crldiagramdomain.SetNodeX(diagramConceptOwner, diagramElementX, hl)
                crldiagramdomain.SetNodeY(diagramConceptOwner, diagramElementY-100, hl)
                diagramConceptOwner.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">ownerPointer := crldiagramdomain.GetOwnerPointer(diagram, diagramElement, hl)
        if ownerPointer == nil </span><span class="cov0" title="0">{
                ownerPointer, _ = crldiagramdomain.NewDiagramOwnerPointer(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(ownerPointer, modelConcept, hl)
                crldiagramdomain.SetLinkSource(ownerPointer, diagramElement, hl)
                crldiagramdomain.SetLinkTarget(ownerPointer, diagramConceptOwner, hl)
                ownerPointer.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (dmPtr *diagramManager) showReferencedConcept(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showReferencedConcept diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">diagram := diagramElement.GetOwningConcept(hl)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showReferencedConcept diagram not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConcept := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
        if modelConcept == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showReferencedConcept modelConcept not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">var modelReference core.Reference
        switch typedModelConcept := modelConcept.(type) </span>{
        case core.Reference:<span class="cov0" title="0">
                modelReference = typedModelConcept</span>
        default:<span class="cov0" title="0">
                return errors.New("diagramManager.showReferencedConcept modelConcept is not a Reference")</span>
        }
        <span class="cov0" title="0">modelReferencedConcept := modelReference.GetReferencedConcept(hl)
        if modelReferencedConcept == nil </span><span class="cov0" title="0">{
                return errors.New("Referenced Concept is nil")
        }</span>
        <span class="cov0" title="0">var diagramReferencedConcept core.Element
        switch modelReference.GetReferencedAttributeName(hl) </span>{
        case core.NoAttribute, core.LiteralValue:<span class="cov0" title="0">
                diagramReferencedConcept = crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelReferencedConcept, hl)
                if diagramReferencedConcept == nil </span><span class="cov0" title="0">{
                        diagramReferencedConcept, _ = crldiagramdomain.NewDiagramNode(dmPtr.browserGUI.GetUofD(), hl)
                        crldiagramdomain.SetReferencedModelElement(diagramReferencedConcept, modelReferencedConcept, hl)
                        crldiagramdomain.SetDisplayLabel(diagramReferencedConcept, modelReferencedConcept.GetLabel(hl), hl)
                        diagramElementX := crldiagramdomain.GetNodeX(diagramElement, hl)
                        diagramElementY := crldiagramdomain.GetNodeY(diagramElement, hl)
                        crldiagramdomain.SetNodeX(diagramReferencedConcept, diagramElementX, hl)
                        crldiagramdomain.SetNodeY(diagramReferencedConcept, diagramElementY-100, hl)
                        diagramReferencedConcept.SetOwningConcept(diagram, hl)
                }</span>
        case core.OwningConceptID:<span class="cov0" title="0">
                diagramReferencedConcept = crldiagramdomain.GetFirstElementRepresentingConceptOwnerPointer(diagram, modelReferencedConcept, hl)
                if diagramReferencedConcept == nil </span><span class="cov0" title="0">{
                        return errors.New("No representation of the owner pointer currently exists in this diagram")
                }</span>
        case core.ReferencedConceptID:<span class="cov0" title="0">
                switch typedModelReferencedConcept := modelReferencedConcept.(type) </span>{
                case core.Reference:<span class="cov0" title="0">
                        diagramReferencedConcept = crldiagramdomain.GetFirstElementRepresentingConceptElementPointer(diagram, typedModelReferencedConcept, hl)
                        if diagramReferencedConcept == nil </span><span class="cov0" title="0">{
                                return errors.New("No representation of the referenced concept pointer currently exists in this diagram")
                        }</span>
                }
        case core.AbstractConceptID:<span class="cov0" title="0">
                switch typedModelReferencedConcept := modelReferencedConcept.(type) </span>{
                case core.Refinement:<span class="cov0" title="0">
                        diagramReferencedConcept = crldiagramdomain.GetFirstElementRepresentingConceptAbstractPointer(diagram, typedModelReferencedConcept, hl)</span>
                }
                <span class="cov0" title="0">if diagramReferencedConcept == nil </span><span class="cov0" title="0">{
                        return errors.New("No representation of the abstract concept pointer currently exists in this diagram")
                }</span>
        case core.RefinedConceptID:<span class="cov0" title="0">
                switch typedModelReferencedConcept := modelReferencedConcept.(type) </span>{
                case core.Refinement:<span class="cov0" title="0">
                        diagramReferencedConcept = crldiagramdomain.GetFirstElementRepresentingConceptRefinedPointer(diagram, typedModelReferencedConcept, hl)
                        if diagramReferencedConcept == nil </span><span class="cov0" title="0">{
                                return errors.New("No representation of the refined concept pointer currently exists in this diagram")
                        }</span>
                }
        }
        <span class="cov0" title="0">elementPointer := crldiagramdomain.GetElementPointer(diagram, diagramElement, hl)
        if elementPointer == nil </span><span class="cov0" title="0">{
                elementPointer, _ = crldiagramdomain.NewDiagramElementPointer(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(elementPointer, modelConcept, hl)
                crldiagramdomain.SetLinkSource(elementPointer, diagramElement, hl)
                crldiagramdomain.SetLinkTarget(elementPointer, diagramReferencedConcept, hl)
                elementPointer.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (dmPtr *diagramManager) showRefinedConcept(elementID string, hl *core.Transaction) error <span class="cov0" title="0">{
        diagramElement := dmPtr.browserGUI.GetUofD().GetElement(elementID)
        if diagramElement == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showRefinedConcept diagramElement not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">diagram := diagramElement.GetOwningConcept(hl)
        if diagram == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showRefinedConcept diagram not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">modelConcept := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
        if modelConcept == nil </span><span class="cov0" title="0">{
                return errors.New("diagramManager.showRefinedConcept modelConcept not found for elementID " + elementID)
        }</span>
        <span class="cov0" title="0">var modelRefinement core.Refinement
        switch typedModelConcept := modelConcept.(type) </span>{
        case core.Refinement:<span class="cov0" title="0">
                modelRefinement = typedModelConcept</span>
        default:<span class="cov0" title="0">
                return errors.New("diagramManager.showRefinedConcept modelConcept is not a Refinement")</span>
        }
        <span class="cov0" title="0">modelRefinedConcept := modelRefinement.GetRefinedConcept(hl)
        if modelRefinedConcept == nil </span><span class="cov0" title="0">{
                return errors.New("Refined Concept is nil")
        }</span>
        <span class="cov0" title="0">diagramRefinedConcept := crldiagramdomain.GetFirstElementRepresentingConcept(diagram, modelRefinedConcept, hl)
        if diagramRefinedConcept == nil </span><span class="cov0" title="0">{
                diagramRefinedConcept, _ = crldiagramdomain.NewDiagramNode(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(diagramRefinedConcept, modelRefinedConcept, hl)
                crldiagramdomain.SetDisplayLabel(diagramRefinedConcept, modelRefinedConcept.GetLabel(hl), hl)
                diagramElementX := crldiagramdomain.GetNodeX(diagramElement, hl)
                diagramElementY := crldiagramdomain.GetNodeY(diagramElement, hl)
                crldiagramdomain.SetNodeX(diagramRefinedConcept, diagramElementX, hl)
                crldiagramdomain.SetNodeY(diagramRefinedConcept, diagramElementY-100, hl)
                diagramRefinedConcept.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">elementPointer := crldiagramdomain.GetElementPointer(diagram, diagramElement, hl)
        if elementPointer == nil </span><span class="cov0" title="0">{
                elementPointer, _ = crldiagramdomain.NewDiagramRefinedPointer(dmPtr.browserGUI.GetUofD(), hl)
                crldiagramdomain.SetReferencedModelElement(elementPointer, modelConcept, hl)
                crldiagramdomain.SetLinkSource(elementPointer, diagramElement, hl)
                crldiagramdomain.SetLinkTarget(elementPointer, diagramRefinedConcept, hl)
                elementPointer.SetOwningConcept(diagram, hl)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update handles additions and removals of diagram elements from the diagram view
// Note that it cannot delete the diagram view in the GUI because this function will never get called: once the diagram has been
// deleted, queuing of functions related to it is suppressed. That's what the DiagramViewMonitor is for.
func (dmPtr *diagramManager) Update(notification *core.ChangeNotification, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := hl.GetUniverseOfDiscourse()
        if core.TraceChange </span><span class="cov0" title="0">{
                log.Printf("    diagramManager: Update called with notification: %s ", notification.GetNatureOfChange().String())
        }</span>
        <span class="cov8" title="1">switch notification.GetNatureOfChange() </span>{
        case core.ConceptChanged:<span class="cov0" title="0">
                beforeState := notification.GetBeforeConceptState()
                afterState := notification.GetAfterConceptState()
                oldLabel := beforeState.Label
                newLabel := afterState.Label
                if oldLabel != newLabel </span><span class="cov0" title="0">{
                        _, err := SendNotification("DiagramLabelChanged", afterState.ConceptID, afterState, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "DiagramManager.Update failed on DiagramLabelChanged call")
                        }</span>
                }
        case core.ConceptRemoved:<span class="cov0" title="0">
                if notification.GetBeforeConceptState() != nil </span><span class="cov0" title="0">{
                        err := dmPtr.browserGUI.editor.CloseDiagramView(notification.GetBeforeConceptState().ConceptID, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "diagramManager.Update failed")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return errors.New("diagramManager.Update called with ConceptRemoved but beforeConceptState being nil")
                }</span>
        case core.OwnedConceptChanged:<span class="cov8" title="1">
                underlyingChange := notification.GetUnderlyingChange()
                beforeState := underlyingChange.GetBeforeConceptState()
                afterState := underlyingChange.GetAfterConceptState()
                if beforeState != nil &amp;&amp; afterState != nil </span><span class="cov8" title="1">{
                        // If it is a link and either source or link target changed
                        // Make sure the diagram link actually exists in the displayed diagram
                        afterElement := uOfD.GetElement(afterState.ConceptID)
                        if crldiagramdomain.IsDiagramLink(afterElement, hl) </span><span class="cov8" title="1">{
                                additionalParameters := getLinkAdditionalParameters(afterElement, hl)
                                booleanResponse, err := SendNotification("DoesLinkExist", afterState.ConceptID, afterState, additionalParameters)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "DiagramManager.Update failed on DoesLinkExist call")
                                }</span>
                                <span class="cov8" title="1">if !booleanResponse.BooleanResult </span><span class="cov8" title="1">{
                                        _, err := SendNotification("AddDiagramLink", afterState.ConceptID, afterState, additionalParameters)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "DiagramManager.Update failed on AddDiagramLink call")
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">switch underlyingChange.GetNatureOfChange() </span>{
                case core.OwningConceptChanged:<span class="cov8" title="1">
                        if beforeState == nil || afterState == nil </span><span class="cov0" title="0">{
                                return errors.New("diagramManager.Update failed: missing before or after state in OwningConceptChanged case")
                        }</span>
                        <span class="cov8" title="1">beforeStateOwnerID := beforeState.OwningConceptID
                        afterStateOwnerID := afterState.OwningConceptID
                        if afterStateOwnerID == "" &amp;&amp; beforeStateOwnerID != "" </span><span class="cov0" title="0">{
                                // If the diagram was the owner but is no longer the owner, then remove the diagram element view
                                additionalParameters := map[string]string{"OwnerID": beforeStateOwnerID}
                                SendNotification("DeleteDiagramElement", beforeState.ConceptID, beforeState, additionalParameters)
                        }</span> else<span class="cov8" title="1"> if afterStateOwnerID != "" &amp;&amp; beforeStateOwnerID == "" </span><span class="cov8" title="1">{
                                // we have to add the diagram element view
                                newElement := uOfD.GetElement(afterState.ConceptID)
                                newElement.Register(dmPtr.elementManager)
                                if crldiagramdomain.IsDiagramNode(newElement, hl) </span><span class="cov8" title="1">{
                                        additionalParameters := getNodeAdditionalParameters(newElement, hl)
                                        _, err := SendNotification("AddDiagramNode", newElement.GetConceptID(hl), afterState, additionalParameters)
                                        return err
                                }</span> else<span class="cov8" title="1"> if crldiagramdomain.IsDiagramLink(newElement, hl) </span><span class="cov8" title="1">{
                                        additionalParameters := getLinkAdditionalParameters(newElement, hl)
                                        _, err := SendNotification("AddDiagramLink", newElement.GetConceptID(hl), afterState, additionalParameters)
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package browsergui

import (
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "github.com/pbrown12303/activeCRL/core"
)

// Notification is the data structure sent from the editor server to the browser client via websockets
type Notification struct {
        Notification             string
        NotificationConceptID    string
        NotificationConceptState core.ConceptState
        AdditionalParameters     map[string]string
}

// NewNotification returns an initialized Notification
func NewNotification() *Notification <span class="cov8" title="1">{
        var notification Notification
        notification.AdditionalParameters = make(map[string]string)
        return &amp;notification
}</span>

// NotificationResponse is the data structure returned by the browser client in response to a PushRequest
type NotificationResponse struct {
        Result          int
        ErrorMessage    string
        ResultConceptID string
        BooleanResult   bool
}

// ClientNotificationManager manages notification communications from server to client
type ClientNotificationManager struct {
        sync.Mutex
        conn *websocket.Conn
}

func newClientNotificationManager() *ClientNotificationManager <span class="cov8" title="1">{
        var cnMgr ClientNotificationManager
        return &amp;cnMgr
}</span>

func (cnMgr *ClientNotificationManager) setConnection(conn *websocket.Conn) <span class="cov8" title="1">{
        cnMgr.Lock()
        defer cnMgr.Unlock()
        cnMgr.conn = conn
}</span>

// SendNotification sends the supplied Notification to the client and returns the Notification response.
// If there is no client connection or there is a problem in sending the Notification or receiving the NotificationResponse,
// an error is returned.
func (cnMgr *ClientNotificationManager) SendNotification(
        notificationDescription string, conceptID string, conceptState *core.ConceptState, params map[string]string) (*NotificationResponse, error) <span class="cov8" title="1">{
        cnMgr.Lock()
        defer cnMgr.Unlock()
        if cnMgr.conn == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">notification := NewNotification()
        notification.Notification = notificationDescription
        notification.NotificationConceptID = conceptID
        if conceptState != nil </span><span class="cov8" title="1">{
                notification.NotificationConceptState = *conceptState
        }</span>
        <span class="cov8" title="1">notification.AdditionalParameters = params

        err := cnMgr.conn.WriteJSON(&amp;notification)
        if err != nil </span><span class="cov0" title="0">{
                switch err.(type) </span>{
                case *websocket.CloseError:<span class="cov0" title="0">
                        log.Printf("WebSocket closed sending notification: %#v", notification)
                        cnMgr.conn = nil
                        return nil, fmt.Errorf("WebSocket closed sending notification: %#v", notification)</span>
                default:<span class="cov0" title="0">
                        log.Printf("Error: %s", err.Error())
                        return nil, err</span>
                }
        }
        <span class="cov8" title="1">if CrlLogClientNotifications </span><span class="cov0" title="0">{
                log.Printf("Sent notification: %#v", notification)
        }</span>
        <span class="cov8" title="1">var notificationResponse NotificationResponse
        cnMgr.conn.SetReadDeadline(time.Now().Add(10 * time.Second))
        err = cnMgr.conn.ReadJSON(&amp;notificationResponse)
        if err != nil </span><span class="cov0" title="0">{
                switch err.(type) </span>{
                case *websocket.CloseError:<span class="cov0" title="0">
                        log.Printf("WebSocket closed for response to notification: %#v", notification)
                        cnMgr.conn = nil
                        return nil, fmt.Errorf("WebSocket closed for response to notification: %#v", notification)</span>
                default:<span class="cov0" title="0">
                        log.Printf("Error %s in parsing response to WebSocket notification: %#v", err.Error(), notification)
                        return nil, fmt.Errorf("error %s in parsing response to WebSocket notification: %#v", err.Error(), notification)</span>
                }
        }
        <span class="cov8" title="1">if CrlLogClientNotifications </span><span class="cov0" title="0">{
                log.Printf("Received notification response %#v", notificationResponse)
        }</span>
        <span class="cov8" title="1">return &amp;notificationResponse, nil</span>
}

// SendNotification is a shortcut to the BrowserGUISingleton.GetClientNotificationManager().SendNotification() function
func SendNotification(notificationString string, conceptID string, conceptState *core.ConceptState, additionalParameters map[string]string) (*NotificationResponse, error) <span class="cov8" title="1">{
        return BrowserGUISingleton.GetClientNotificationManager().SendNotification(notificationString, conceptID, conceptState, additionalParameters)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package browsergui

import (
        "log"

        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
)

// propertyManager manages the client's display of the selectedElement's properties
type propertyManager struct {
        browserGUI *BrowserGUI
}

// initialize sets up the uOfD monitoring
func (pmPtr *propertyManager) initialize(hl *core.Transaction) error <span class="cov8" title="1">{
        err := pmPtr.browserGUI.GetUofD().Register(pmPtr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "propertyManager.initialize failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Update  is the callback function that manaages the properties view for the selected element when elements in the Universe of Discourse change.
func (pmPtr *propertyManager) Update(notification *core.ChangeNotification, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := hl.GetUniverseOfDiscourse()

        // Tracing
        if core.AdHocTrace </span><span class="cov0" title="0">{
                log.Printf("In propertyManager.Update()")
        }</span>

        <span class="cov8" title="1">changedElementID := notification.GetChangedConceptID()
        changedElement := uOfD.GetElement(changedElementID)
        if changedElement == nil </span><span class="cov0" title="0">{
                return errors.New("propertyManager.changeNode called with nil Element")
        }</span>
        <span class="cov8" title="1">additionalParameters := map[string]string{}
        conceptState, err2 := core.NewConceptState(changedElement)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "propertyManager.Update failed")
        }</span>
        <span class="cov8" title="1">if pmPtr.browserGUI.editor.GetCurrentSelection() == changedElement &amp;&amp; notification.GetNatureOfChange() != core.ConceptRemoved </span><span class="cov8" title="1">{
                notificationResponse, err := pmPtr.browserGUI.GetClientNotificationManager().SendNotification("UpdateProperties", conceptState.ConceptID, conceptState, additionalParameters)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "propertyManager.Update failed")
                }</span>
                <span class="cov8" title="1">if notificationResponse != nil &amp;&amp; notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                        return errors.New("In propertyManager.Update, notification response was: " + notificationResponse.ErrorMessage)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package browsergui

import (
        "context"
        "encoding/json"
        "html/template"
        "log"
        "os/exec"
        "runtime"
        "strconv"
        "sync"

        //        "log"
        "net/http"
        "time"

        "github.com/gorilla/websocket"
        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"
)

var server *http.Server
var wsServer *http.Server
var webSocketReady = make(chan bool)
var requestInProgress bool

// Request is the data structure submitted by the client browser as part of an http request
type Request struct {
        Action               string
        AdditionalParameters map[string]string
        RequestConceptID     string
        RequestConcept       core.Element
}

func newRequest() *Request <span class="cov8" title="1">{
        var request Request
        request.AdditionalParameters = make(map[string]string)
        return &amp;request
}</span>

// Reply is the data structure returned by the editor server in response to a Request
type Reply struct {
        Result               int
        ResultDescription    string
        ResultConceptID      string
        ResultConcept        core.Element
        AdditionalParameters map[string]string
}

func newReply() *Reply <span class="cov8" title="1">{
        var reply Reply
        return &amp;reply
}</span>

type page struct {
        Title string
        Body  []byte
}

var root = "C:/GoWorkspace/src/github.com/pbrown12303/activeCRL/"

var templates = template.Must(template.ParseFiles(root+"crleditorbrowsergui/http/index.html", root+"crleditorbrowsergui/http/graph.html"))

// WebSocket upgrader
var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
}

// Exit is used as a programmatic shutdown of the server. It is primarily intended to support testing scenarios.
func Exit() error <span class="cov0" title="0">{
        // Save the settings
        err := BrowserGUISingleton.editor.SaveUserPreferences()
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
        }</span>
        <span class="cov0" title="0">BrowserGUISingleton.editor.SetExitRequested()
        err = server.Shutdown(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetRequestInProgress returns true if the server is actively processing a request
func GetRequestInProgress() bool <span class="cov8" title="1">{
        return requestInProgress
}</span>

func graphHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        p := &amp;page{Title: "Function Call Notification Graph"}
        renderTemplate(w, "graph", p)
}</span>

func indexHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        p := &amp;page{Title: "CRL Editor"}
        renderTemplate(w, "index", p)
}</span>

// func loadPage(title string) (*page, error) {
//         filename := root + "crlEditor/data/" + title + ".txt"
//         body, err := ioutil.ReadFile(filename)
//         if err != nil {
//                 return nil, err
//         }
//         return &amp;page{Title: title, Body: body}, nil
// }

// openBrowser tries to open the URL in a browser,
// and returns whether it succeed in doing so.
func openBrowser(url string) bool <span class="cov0" title="0">{
        var args []string
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                args = []string{"open"}</span>
        case "windows":<span class="cov0" title="0">
                args = []string{"cmd", "/c", "start"}</span>
        default:<span class="cov0" title="0">
                args = []string{"xdg-open"}</span>
        }
        <span class="cov0" title="0">cmd := exec.Command(args[0], append(args[1:], url)...)
        return cmd.Start() == nil</span>
}

type requestHandler struct {
        sync.Mutex
        ready bool
}

var rh requestHandler

// handler for client requests
func (rh *requestHandler) handleRequest(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        rh.Lock()
        defer rh.Unlock()
        requestInProgress = true
        // log.Printf("requestInProgress set to true")
        defer func() </span><span class="cov8" title="1">{
                requestInProgress = false
                // log.Printf("requestInProgress set to false")
        }</span>()
        <span class="cov8" title="1">request := newRequest()
        if r.Body == nil </span><span class="cov0" title="0">{
                log.Printf("Request received with no body")
                http.Error(w, "Please send a request body", 400)
                return
        }</span>
        <span class="cov8" title="1">err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Request received but JSON decoding of body failed")
                http.Error(w, err.Error(), 400)
                return
        }</span>
        <span class="cov8" title="1">hl := BrowserGUISingleton.GetUofD().NewTransaction()
        defer hl.ReleaseLocks()
        if CrlLogClientRequests || core.TraceChange </span><span class="cov8" title="1">{
                log.Printf("Received request: %#v", request)
        }</span>
        <span class="cov8" title="1">switch request.Action </span>{
        case "AbstractPointerChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().abstractPointerChanged(
                        request.RequestConceptID, request.AdditionalParameters["SourceID"], request.AdditionalParameters["TargetID"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing AbstractPointerChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed AbstractPointerChanged", linkID, nil)
                }</span>
        case "AddElementChild":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el, _ := BrowserGUISingleton.GetUofD().NewElement(hl)
                el.SetLabel(BrowserGUISingleton.editor.GetDefaultElementLabel(), hl)
                el.SetOwningConceptID(request.RequestConceptID, hl)
                BrowserGUISingleton.editor.SelectElement(el, hl)
                sendReply(w, 0, "Processed AddElementChild", el.GetConceptID(hl), el)</span>
        case "AddDiagramChild":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                diagram, err := BrowserGUISingleton.getDiagramManager().addDiagram(request.RequestConceptID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing AddDiagramChild: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed AddDiagramChild", diagram.GetConceptID(hl), diagram)
                }</span>
        case "AddLiteralChild":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el, _ := BrowserGUISingleton.GetUofD().NewLiteral(hl)
                el.SetLabel(BrowserGUISingleton.editor.GetDefaultLiteralLabel(), hl)
                el.SetOwningConceptID(request.RequestConceptID, hl)
                BrowserGUISingleton.editor.SelectElement(el, hl)
                sendReply(w, 0, "Processed AddLiteralChild", el.GetConceptID(hl), el)</span>
        case "AddReferenceChild":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el, _ := BrowserGUISingleton.GetUofD().NewReference(hl)
                el.SetLabel(BrowserGUISingleton.editor.GetDefaultReferenceLabel(), hl)
                el.SetOwningConceptID(request.RequestConceptID, hl)
                BrowserGUISingleton.editor.SelectElement(el, hl)
                sendReply(w, 0, "Processed AddReferenceChild", el.GetConceptID(hl), el)</span>
        case "AddRefinementChild":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el, _ := BrowserGUISingleton.GetUofD().NewRefinement(hl)
                el.SetLabel(BrowserGUISingleton.editor.GetDefaultRefinementLabel(), hl)
                el.SetOwningConceptID(request.RequestConceptID, hl)
                BrowserGUISingleton.editor.SelectElement(el, hl)
                sendReply(w, 0, "Processed AddRefinementChild", el.GetConceptID(hl), el)</span>
        case "ClearWorkspace":<span class="cov8" title="1">
                err := BrowserGUISingleton.editor.ClearWorkspace(hl)
                reply(w, "ClearWorkspace", err)</span>
        case "CloseWorkspace":<span class="cov0" title="0">
                err := BrowserGUISingleton.editor.CloseWorkspace(hl)
                reply(w, "CloseWorkspace", err)</span>
        case "DefinitionChanged":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if el != nil </span><span class="cov0" title="0">{
                        el.SetDefinition(request.AdditionalParameters["NewValue"], hl)
                }</span>
                <span class="cov0" title="0">sendReply(w, 0, "Processed DefinitionChanged", request.RequestConceptID, el)</span>
        case "DeleteDiagramElementView":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().deleteDiagramElementView(request.RequestConceptID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed DeleteDiagramElementView", request.RequestConceptID, nil)
                }</span>
        case "DiagramClick":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().diagramClick(request, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed DiagramClick", request.RequestConceptID, nil)
                }</span>
        case "DiagramDrop":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().diagramDrop(request, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed DiagramDrop", request.RequestConceptID, nil)
                }</span>
        case "DiagramElementSelected":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                elementID := request.RequestConceptID
                element := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if element != nil </span><span class="cov0" title="0">{
                        modelElement := crldiagramdomain.GetReferencedModelElement(element, hl)
                        BrowserGUISingleton.editor.SelectElement(modelElement, hl)
                }</span>
                <span class="cov0" title="0">sendReply(w, 0, "Processed DiagramElementSelected", elementID, BrowserGUISingleton.GetUofD().GetElement(elementID))</span>
        case "DiagramNodeNewPosition":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                x, err := strconv.ParseFloat(request.AdditionalParameters["NodeX"], 64)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, err.Error(), "", nil)
                }</span>
                <span class="cov0" title="0">y, err2 := strconv.ParseFloat(request.AdditionalParameters["NodeY"], 64)
                if err2 != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, err2.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        BrowserGUISingleton.getDiagramManager().setDiagramNodePosition(request.RequestConceptID, x, y, hl)
                        sendReply(w, 0, "Processed DiagramNodeNewPosition", "", nil)
                }</span>
        case "DiagramViewHasBeenClosed":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().DiagramViewHasBeenClosed(request.RequestConceptID, hl)
                reply(w, "DiagramViewHasBeenClosed", err)</span>
        case "DisplayCallGraph":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.DisplayCallGraph(request.AdditionalParameters["GraphIndex"], hl)
                reply(w, "DisplayCallGraph", err)</span>
        case "DisplayDiagramSelected":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if el != nil &amp;&amp; el.IsRefinementOfURI(crldiagramdomain.CrlDiagramURI, hl) </span><span class="cov0" title="0">{
                        diagramManager := BrowserGUISingleton.getDiagramManager()
                        diagramManager.displayDiagram(el, hl)
                }</span>
                <span class="cov0" title="0">sendReply(w, 0, "Processed DisplayDiagramSelected", request.RequestConceptID, el)</span>
        case "ElementPointerChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().elementPointerChanged(
                        request.RequestConceptID,
                        request.AdditionalParameters["SourceID"],
                        request.AdditionalParameters["TargetID"],
                        request.AdditionalParameters["TargetAttributeName"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing ElementPointerChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed ElementPointerChanged", linkID, nil)
                }</span>
        case "Exit":<span class="cov0" title="0">
                log.Printf("Exit requested")
                sendReply(w, 0, "Server will close", "", nil)
                time.Sleep(5 * time.Second)
                if err := Exit(); err != nil </span><span class="cov0" title="0">{
                        // Error from closing listeners, or context timeout:
                        log.Printf("HTTP server Shutdown error: %s", err.Error())
                }</span>
        case "FormatChanged":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                diagramElement := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                var err error
                if diagramElement != nil </span><span class="cov0" title="0">{
                        err = BrowserGUISingleton.diagramManager.formatChanged(diagramElement, request.AdditionalParameters["LineColor"], request.AdditionalParameters["BGColor"], hl)
                }</span>
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        sendReply(w, 0, "Processed FormatChanged", request.RequestConceptID, diagramElement)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 1, "Error processing FormatChanged: "+err.Error(), "", nil)
                }</span>
        case "InitializeClient":<span class="cov0" title="0">
                log.Printf("InitializeClient requested")
                sendReply(w, 0, "Client will be initialized", "", nil)
                for !rh.ready </span><span class="cov0" title="0">{
                        time.Sleep(100 * time.Millisecond)
                }</span>
                <span class="cov0" title="0">err := BrowserGUISingleton.InitializeGUI(hl)
                if err != nil </span><span class="cov0" title="0">{
                        SendNotification("Error initializing client: "+err.Error(), "", nil, nil)
                }</span> else<span class="cov0" title="0"> {
                        SendNotification("InitializationComplete", "", nil, nil)
                }</span>
                <span class="cov0" title="0">requestInProgress = false
                log.Printf("requestInProgress set to false in InitializeClient")</span>
        case "LabelChanged":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if el != nil </span><span class="cov0" title="0">{
                        el.SetLabel(request.AdditionalParameters["NewValue"], hl)
                }</span>
                <span class="cov0" title="0">sendReply(w, 0, "Processed LabelChanged", request.RequestConceptID, el)</span>
        case "LiteralValueChanged":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if el != nil </span><span class="cov0" title="0">{
                        switch typedEl := el.(type) </span>{
                        case core.Literal:<span class="cov0" title="0">
                                typedEl.SetLiteralValue(request.AdditionalParameters["NewValue"], hl)</span>
                        }
                }
                <span class="cov0" title="0">sendReply(w, 0, "Processed LiteralValueChanged", request.RequestConceptID, el)</span>
        case "NewDomainRequest":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                cs, _ := BrowserGUISingleton.GetUofD().NewElement(hl)
                cs.SetLabel(BrowserGUISingleton.editor.GetDefaultDomainLabel(), hl)
                BrowserGUISingleton.editor.SelectElement(cs, hl)
                sendReply(w, 0, "Processed NewDomainRequest", cs.GetConceptID(hl), cs)</span>
        case "NullifyReferencedConcept":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                diagramElement := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if diagramElement == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Selected diagram element not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">modelElement := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
                if modelElement == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Model element corresponding to selected diagram element not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">err := BrowserGUISingleton.nullifyReferencedConcept(modelElement.GetConceptID(hl), hl)
                reply(w, "NullifyReferencedConcept", err)</span>
        case "OpenWorkspace":<span class="cov0" title="0">
                err := BrowserGUISingleton.editor.OpenWorkspace()
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing OpenWorkspace: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed OpenWorkspace", "", nil)
                }</span>
        case "OwnerPointerChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().ownerPointerChanged(
                        request.RequestConceptID, request.AdditionalParameters["SourceID"], request.AdditionalParameters["TargetID"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing OwnerPointerChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed OwnerPointerChanged", linkID, nil)
                }</span>
        case "Redo":<span class="cov8" title="1">
                err := BrowserGUISingleton.editor.Redo(hl)
                reply(w, "Redo", err)</span>
        case "RefinedPointerChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().refinedPointerChanged(
                        request.RequestConceptID, request.AdditionalParameters["SourceID"], request.AdditionalParameters["TargetID"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing RefinedPointerChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed RefinedPointerChanged", linkID, nil)
                }</span>
        case "ReferenceLinkChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().ReferenceLinkChanged(
                        request.RequestConceptID,
                        request.AdditionalParameters["SourceID"],
                        request.AdditionalParameters["TargetID"],
                        request.AdditionalParameters["TargetAttributeName"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing ReferenceLinkChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed ReferenceLinkChanged", linkID, nil)
                }</span>
        case "RefinementLinkChanged":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                linkID, err := BrowserGUISingleton.getDiagramManager().RefinementLinkChanged(
                        request.RequestConceptID, request.AdditionalParameters["SourceID"], request.AdditionalParameters["TargetID"], hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Error processing RefinementLinkChanged: "+err.Error(), "", nil)
                }</span> else<span class="cov8" title="1"> {
                        sendReply(w, 0, "Processed RefinementLinkChanged", linkID, nil)
                }</span>
        case "RefreshDiagram":<span class="cov0" title="0">
                err := BrowserGUISingleton.getDiagramManager().refreshDiagramUsingURI(request.RequestConceptID, hl)
                reply(w, "RefreshDiagram", err)</span>
        case "ReturnAvailableGraphCount":<span class="cov0" title="0">
                count := BrowserGUISingleton.GetAvailableGraphCount()
                reply := newReply()
                reply.Result = 0
                reply.ResultDescription = "Processed ReturnAvailableGraphCount"
                reply.ResultConceptID = ""
                reply.ResultConcept = nil
                reply.AdditionalParameters = map[string]string{"NumberOfAvailableGraphs": strconv.Itoa(count)}
                err := json.NewEncoder(w).Encode(reply)
                if err != nil </span><span class="cov0" title="0">{
                        log.Print(err.Error())
                }</span>
        case "SaveWorkspace":<span class="cov0" title="0">
                err := BrowserGUISingleton.editor.SaveWorkspace(hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "SaveWorkspace failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed SaveWorkspace", "", nil)
                }</span>
        case "ShowConceptInNavigator":<span class="cov0" title="0">
                requestedConcept := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if requestedConcept == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Selected concept not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">err := BrowserGUISingleton.ShowConceptInTree(requestedConcept, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "ShowConceptInNavigator failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed ShowConceptInNavigator", "", nil)
                }</span>
        case "ShowModelConceptInNavigator":<span class="cov0" title="0">
                diagramElement := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if diagramElement == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Selected diagram element not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">modelElement := crldiagramdomain.GetReferencedModelElement(diagramElement, hl)
                if modelElement == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Model element corresponding to selected diagram element not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">err := BrowserGUISingleton.ShowConceptInTree(modelElement, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "ShowModelConceptInNavigator failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed ShowModelConceptInNavigator", "", nil)
                }</span>
        case "ShowDiagramElementInNavigator":<span class="cov0" title="0">
                diagramElement := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if diagramElement == nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "Selected diagram element not found", "", nil)
                        break</span>
                }
                <span class="cov0" title="0">err := BrowserGUISingleton.ShowConceptInTree(diagramElement, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "ShowDiagramElementInNavigator failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed ShowDiagramElementInNavigator", "", nil)
                }</span>
        case "SetTreeDragSelection":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                BrowserGUISingleton.SetTreeDragSelection(request.RequestConceptID)
                sendReply(w, 0, "Processed SetTreeDragSelection", request.RequestConceptID, BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID))</span>
        case "ShowAbstractConcept":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().showAbstractConcept(request.RequestConceptID, hl)
                reply(w, "ShowAbstractConcept", err)</span>
        case "ShowOwnedConcepts":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().showOwnedConcepts(request.RequestConceptID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "ShowOwner failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed ShowOwner", "", nil)
                }</span>
        case "ShowOwner":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().showOwner(request.RequestConceptID, hl)
                if err != nil </span><span class="cov0" title="0">{
                        sendReply(w, 1, "ShowOwner failed: "+err.Error(), "", nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 0, "Processed ShowOwner", "", nil)
                }</span>
        case "ShowReferencedConcept":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().showReferencedConcept(request.RequestConceptID, hl)
                reply(w, "ShowReferencedConcept", err)</span>
        case "ShowRefinedConcept":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                err := BrowserGUISingleton.getDiagramManager().showRefinedConcept(request.RequestConceptID, hl)
                reply(w, "ShowRefinedConcept", err)</span>
        case "TreeNodeDelete":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                elementID := request.RequestConceptID
                // log.Printf("TreeNodeDelete called for node id: %s for elementID: %s", request.RequestConceptID, elementID)
                err := BrowserGUISingleton.editor.DeleteElement(elementID, hl)
                if err == nil </span><span class="cov0" title="0">{
                        sendReply(w, 0, "Element has been deleted", elementID, nil)
                }</span> else<span class="cov0" title="0"> {
                        sendReply(w, 1, "Delete failed", elementID, nil)
                }</span>
        case "TreeNodeSelected":<span class="cov8" title="1">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                elementID := request.RequestConceptID
                if CrlLogClientNotifications </span><span class="cov0" title="0">{
                        log.Printf("Selected node id: %s", request.RequestConceptID)
                }</span>
                <span class="cov8" title="1">BrowserGUISingleton.editor.SelectElementUsingIDString(elementID, hl)
                sendReply(w, 0, "Processed TreeNodeSelected", elementID, BrowserGUISingleton.GetUofD().GetElement(elementID))</span>
        case "Undo":<span class="cov8" title="1">
                err := BrowserGUISingleton.editor.Undo(hl)
                reply(w, "Undo", err)</span>
        case "UpdateDebugSettings":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                BrowserGUISingleton.UpdateDebugSettings(request)
                sendReply(w, 0, "Processed UpdateDebugSettings", "", nil)</span>
        case "UpdateUserPreferences":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                BrowserGUISingleton.UpdateUserPreferences(request, hl)
                sendReply(w, 0, "Processed UpdateUserPreferences", "", nil)</span>
        case "URIChanged":<span class="cov0" title="0">
                BrowserGUISingleton.GetUofD().MarkUndoPoint()
                el := BrowserGUISingleton.GetUofD().GetElement(request.RequestConceptID)
                if el != nil </span><span class="cov0" title="0">{
                        el.SetURI(request.AdditionalParameters["NewValue"], hl)
                }</span>
                <span class="cov0" title="0">sendReply(w, 0, "Processed URI changed", request.RequestConceptID, el)</span>
        default:<span class="cov0" title="0">
                log.Printf("Unhandled request: %s", request.Action)
                sendReply(w, 1, "Unhandled request: "+request.Action, "", nil)</span>
        }
}

func reply(w http.ResponseWriter, requestName string, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                sendReply(w, 1, requestName+": "+err.Error(), "", nil)
        }</span> else<span class="cov8" title="1"> {
                sendReply(w, 0, " Processed "+requestName, "", nil)
        }</span>
}

func sendReply(w http.ResponseWriter, code int, message string, resultConceptID string, resultConcept core.Element) <span class="cov8" title="1">{
        reply := newReply()
        reply.Result = code
        reply.ResultDescription = message
        reply.ResultConceptID = resultConceptID
        reply.ResultConcept = resultConcept
        err := json.NewEncoder(w).Encode(reply)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
        }</span>
        <span class="cov8" title="1">if CrlLogClientRequests </span><span class="cov8" title="1">{
                log.Printf("Sent reply: %#v", reply)
        }</span>
}

// StartServer starts the editor server. This will automatically launch a browser as an interface
func (bgPtr *BrowserGUI) StartServer() <span class="cov8" title="1">{
        // var err error
        // InitializeBrowserGUISingleton(editor, userFolderArg)
        // err = BrowserGUISingleton.editor.LoadUserPreferences(workspaceArg)
        // if err != nil {
        //         log.Fatal(err)
        // }
        // workspacePath := workspaceArg
        // if workspacePath == "" {
        //         workspacePath = BrowserGUISingleton.GetUserPreferences().WorkspacePath
        // }
        // if workspacePath == "" {
        //         workspacePath, err2 := BrowserGUISingleton.SelectWorkspace()
        //         if err2 != nil {
        //                 log.Fatal(err2)
        //         }
        //         err = BrowserGUISingleton.SetWorkspacePath(workspacePath)
        //         if err != nil {
        //                 log.Fatal(err)
        //         }
        // }
        // hl := BrowserGUISingleton.GetUofD().NewHeldLocks()
        // err = BrowserGUISingleton.LoadWorkspace(hl)
        // if err != nil {
        //         log.Fatal(err)
        // }
        // hl.ReleaseLocksAndWait()
        // BrowserGUISingleton.GetUofD().SetRecordingUndo(true)

        // go BrowserGUISingleton.InitializeClient()

        // WebSocketts server
        go startWsServer()
        // RequestServer
        mux := http.NewServeMux()
        mux.HandleFunc("/index/graph.html", graphHandler)
        mux.HandleFunc("/index/", indexHandler)
        mux.Handle("/js/", http.StripPrefix("/js/", http.FileServer(http.Dir(root+"crleditorbrowsergui/http/js"))))
        mux.Handle("/icons/", http.StripPrefix("/icons/", http.FileServer(http.Dir(root+"crleditorbrowsergui/http/images/icons"))))
        mux.Handle("/css/", http.StripPrefix("/css/", http.FileServer(http.Dir(root+"crleditorbrowsergui/http/css"))))
        mux.HandleFunc("/index/request", rh.handleRequest)

        if bgPtr.startBrowser </span><span class="cov0" title="0">{
                openBrowser("http://localhost:8082/index")
        }</span>

        <span class="cov8" title="1">server = &amp;http.Server{Addr: "127.0.0.1:8082", Handler: mux}

        go checkReady()

        server.ListenAndServe()</span>
}

func checkReady() <span class="cov8" title="1">{
        rh.ready = &lt;-webSocketReady
        BrowserGUISingleton.SetInitialized()
}</span>

func startWsServer() <span class="cov8" title="1">{
        // This function must be idempotent
        if wsServer == nil </span><span class="cov8" title="1">{
                wsMux := http.NewServeMux()
                wsMux.HandleFunc("/index/ws", wsHandler)
                wsServer = &amp;http.Server{Addr: "127.0.0.1:8081", Handler: wsMux}
                wsServer.ListenAndServe()
        }</span>
}

func renderTemplate(w http.ResponseWriter, tmpl string, p *page) <span class="cov8" title="1">{
        err := templates.ExecuteTemplate(w, tmpl+".html", p)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
        }</span>
}

var wsConnection *websocket.Conn

// wsHandler is the handler for WebSocket Notifications
func wsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        log.Printf("wsHandler invoked")
        var err error
        // TODO: Fix the upgrader.CheckOrigin() to do something intelligent
        upgrader.CheckOrigin = func(r *http.Request) bool </span><span class="cov8" title="1">{ return true }</span>
        <span class="cov8" title="1">wsConnection, err = upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>
        <span class="cov8" title="1">BrowserGUISingleton.GetClientNotificationManager().setConnection(wsConnection)
        log.Printf("wsHandler complete")
        webSocketReady &lt;- true</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package browsergui

import (
        "log"
        "strconv"

        "github.com/pkg/errors"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldiagramdomain"
)

// treeManager manages the client's tree display of the uOfD
type treeManager struct {
        treeID     string
        browserGUI *BrowserGUI
}

// addChildren adds the OwnedConcepts of the supplied Element to the client's tree
func (tmPtr *treeManager) addChildren(el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := tmPtr.browserGUI.GetUofD()
        it := uOfD.GetConceptsOwnedConceptIDs(el.GetConceptID(hl)).Iterator()
        for id := range it.C </span><span class="cov8" title="1">{
                child := uOfD.GetElement(id.(string))
                if child == nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.New("In TreeManager.addChildren, no child found for id: " + id.(string))
                }</span>
                <span class="cov8" title="1">err := tmPtr.addNode(child, hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.Wrap(err, "TreeManager.addChildren failed")
                }</span>
                <span class="cov8" title="1">err = tmPtr.addChildren(child, hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.Wrap(err, "TreeManager.addChildren failed")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// addNode adds a node to the tree
func (tmPtr *treeManager) addNode(el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("treeManger.addNode called with nil element")
        }</span>
        <span class="cov8" title="1">icon := GetIconPath(el, hl)
        additionalParameters := map[string]string{
                "icon":      icon,
                "isDiagram": strconv.FormatBool(crldiagramdomain.IsDiagram(el, hl))}
        conceptState, err2 := core.NewConceptState(el)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "treeManager.addNode failed")
        }</span>
        <span class="cov8" title="1">notificationResponse, err3 := BrowserGUISingleton.GetClientNotificationManager().SendNotification("AddTreeNode", el.GetConceptID(hl), conceptState, additionalParameters)
        if err3 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err3, "TreeManager.addNode failed")
        }</span>
        <span class="cov8" title="1">if notificationResponse != nil &amp;&amp; notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                return errors.New("In TreeManager.addNode, got " + notificationResponse.ErrorMessage)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// addNodeRecursively adds the node and all of its descendants to the tree
func (tmPtr *treeManager) addNodeRecursively(el core.Element, hl *core.Transaction) error <span class="cov0" title="0">{
        err := tmPtr.addNode(el, hl)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "TreeManager.addNodeRecursively failed")
        }</span>
        <span class="cov0" title="0">uOfD := tmPtr.browserGUI.GetUofD()
        it := uOfD.GetConceptsOwnedConceptIDs(el.GetConceptID(hl)).Iterator()
        for id := range it.C </span><span class="cov0" title="0">{
                child := uOfD.GetElement(id.(string))
                if child == nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.New("In TreeManager.addNodeRecursively, child not found for id: " + id.(string))
                }</span>
                <span class="cov0" title="0">err = tmPtr.addNodeRecursively(child, hl)
                if err != nil </span><span class="cov0" title="0">{
                        it.Stop()
                        return errors.Wrap(err, "TreeManager.addNodeRecursively failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// changeNode updates the tree node
func (tmPtr *treeManager) changeNode(el core.Element, hl *core.Transaction) error <span class="cov8" title="1">{
        if el == nil </span><span class="cov0" title="0">{
                return errors.New("treeManager.changeNode called with nil Element")
        }</span>
        <span class="cov8" title="1">icon := GetIconPath(el, hl)
        additionalParameters := map[string]string{
                "icon":      icon,
                "isDiagram": strconv.FormatBool(crldiagramdomain.IsDiagram(el, hl))}
        conceptState, err2 := core.NewConceptState(el)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "treeManager.addNode failed")
        }</span>
        <span class="cov8" title="1">notificationResponse, err := BrowserGUISingleton.GetClientNotificationManager().SendNotification("ChangeTreeNode", conceptState.ConceptID, conceptState, additionalParameters)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "TreeManager.changeNode failed")
        }</span>
        <span class="cov8" title="1">if notificationResponse != nil &amp;&amp; notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                return errors.New("In TreeManager.changeNode, notification response was: " + notificationResponse.ErrorMessage)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// removeNode removes the tree node
func (tmPtr *treeManager) removeNode(elID string, hl *core.Transaction) error <span class="cov0" title="0">{
        if elID == "" </span><span class="cov0" title="0">{
                return errors.New("treeManager.removeNode called with no ConceptID")
        }</span>
        <span class="cov0" title="0">notificationResponse, err := BrowserGUISingleton.GetClientNotificationManager().SendNotification("DeleteTreeNode", elID, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "TreeManager.removeNode failed")
        }</span>
        <span class="cov0" title="0">if notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                return errors.New("In TreeManager.removeNode, notification response was: " + notificationResponse.ErrorMessage)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func (tmPtr *treeManager) getChangeNotificationBelowUofD(changeNotification *core.ChangeNotification) *core.ChangeNotification {
//         if changeNotification.GetChangedConceptID() == "" { // only happens when uOfD is the reporting element
//                 return changeNotification.GetUnderlyingChange()
//         } else if changeNotification.GetUnderlyingChange() != nil {
//                 return tmPtr.getChangeNotificationBelowUofD(changeNotification.GetUnderlyingChange())
//         }
//         return nil
// }

// initialize sets up the uOfD monitoring
func (tmPtr *treeManager) initialize(hl *core.Transaction) error <span class="cov8" title="1">{
        err := tmPtr.browserGUI.GetUofD().Register(tmPtr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "treeManager.initialize failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// initializeTree initializes the display of the tree in the client
func (tmPtr *treeManager) initializeTree(hl *core.Transaction) error <span class="cov8" title="1">{
        notificationResponse, err := BrowserGUISingleton.GetClientNotificationManager().SendNotification("ClearTree", "", nil, map[string]string{})
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "TreeManager.initializeTree failed")
        }</span>
        <span class="cov8" title="1">if notificationResponse == nil </span><span class="cov0" title="0">{
                return errors.New("treeManager.initializeTree called, but no notificationResponse was received")
        }</span>
        <span class="cov8" title="1">if notificationResponse.Result != 0 </span><span class="cov0" title="0">{
                return errors.New("In TreeManager.initializeTree, notification response was: " + notificationResponse.ErrorMessage)
        }</span>
        <span class="cov8" title="1">for _, el := range tmPtr.browserGUI.GetUofD().GetElements() </span><span class="cov8" title="1">{
                if el.GetOwningConcept(hl) == nil </span><span class="cov8" title="1">{
                        err = tmPtr.addNode(el, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "TreeManager.initialzeTree failed")
                        }</span>
                        <span class="cov8" title="1">err = tmPtr.addChildren(el, hl)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "TreeManager.initializeTree failed")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Update  is the callback function that manaages the tree view when elements in the Universe of Discourse change.
// The changes being sought are the addition, removal, and re-parenting of base elements and the changes in their names.
func (tmPtr *treeManager) Update(notification *core.ChangeNotification, hl *core.Transaction) error <span class="cov8" title="1">{
        uOfD := hl.GetUniverseOfDiscourse()

        // Tracing
        if core.AdHocTrace </span><span class="cov0" title="0">{
                log.Printf("In treeManager.Update()")
        }</span>

        <span class="cov8" title="1">changedElementID := notification.GetChangedConceptID()
        changedElement := uOfD.GetElement(changedElementID)
        switch notification.GetNatureOfChange() </span>{
        case core.ConceptAdded:<span class="cov8" title="1">
                tmPtr.addNode(changedElement, hl)</span>
        case core.ConceptChanged, core.OwningConceptChanged:<span class="cov8" title="1">
                tmPtr.changeNode(changedElement, hl)</span>
        case core.ConceptRemoved:<span class="cov0" title="0">
                tmPtr.removeNode(changedElementID, hl)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2017, 2018 Paul C. Brown. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
        "flag"
        "log"
        "time"

        "github.com/pbrown12303/activeCRL/crleditor"
        "github.com/pbrown12303/activeCRL/crleditorbrowsergui/browsergui"
        // "github.com/pbrown12303/activeCRL/crleditorfynegui/fynegui"
)

func main() <span class="cov0" title="0">{
        workspaceArg := flag.String("workspace", "", "Path to workspace folder (optional)")
        userFolderArg := flag.String("userFolder", "", "Path to user folder (optional)")
        flag.Parse()
        log.Println("workspace: ", *workspaceArg)
        log.Println("user folder: ", *userFolderArg)
        // For debugging
        // browsergui.CrlLogClientRequests = true

        // Common infrastructure
        editor := crleditor.NewEditor(*userFolderArg)
        browsergui.InitializeBrowserGUISingleton(editor, true)
        err := editor.AddEditorGUI(browsergui.BrowserGUISingleton)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // fyneGUI := fynegui.NewFyneGUI()
        // err = editor.AddEditorGUI(fyneGUI)
        // if err != nil {
        //         log.Fatal(err)
        // }

        <span class="cov0" title="0">err = editor.Initialize(*workspaceArg, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Fyne GUI
        // fyneGUI.GetWindow().ShowAndRun()

        // Alternate top-level when not using Fyne
        <span class="cov0" title="0">for editor.GetExitRequested() == false </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package crleditordomain

import (
        "github.com/pbrown12303/activeCRL/core"
        "github.com/pbrown12303/activeCRL/crldatastructuresdomain"
)

// EditorDomainURI is the URI for the domain of the editor
var EditorDomainURI = "http://activeCrl.com/crleditordomain/CrlEditorDomain"

// EditorSettingsURI is the URI for accessing the CrlEditor settings
var EditorSettingsURI = EditorDomainURI + "/Settings"

// EditorOpenDiagramsURI is the URI for accessing the CrlEditor list of open diagrams
var EditorOpenDiagramsURI = EditorSettingsURI + "/OpenDiagrams"

// BuildEditorDomain programmatically constructs the EditorDomain
func BuildEditorDomain(uOfD *core.UniverseOfDiscourse, hl *core.Transaction) (core.Element, error) <span class="cov8" title="1">{
        // EditorDomain
        // Assumes that the DiagramDomain has already been added to the uOfD
        domain, _ := uOfD.NewElement(hl, EditorDomainURI)
        domain.SetLabel("CrlEditorDomain", hl)

        settings, _ := uOfD.NewElement(hl, EditorSettingsURI)
        settings.SetLabel("Settings", hl)
        settings.SetOwningConcept(domain, hl)

        editorOpenDiagramsList, err := crldatastructuresdomain.NewStringList(uOfD, hl, EditorOpenDiagramsURI)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //        editorOpenDiagramsList.SetURI(EditorOpenDiagramsURI, hl)
        <span class="cov8" title="1">editorOpenDiagramsList.SetLabel("EditorOpenDiagrams", hl)
        editorOpenDiagramsList.SetOwningConcept(settings, hl)

        domain.SetIsCoreRecursively(hl)

        return domain, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package fynegui

import (
        "fmt"
        "image/color"

        "fyne.io/fyne"
        "fyne.io/fyne/app"
        "fyne.io/fyne/canvas"
        "fyne.io/fyne/layout"
        "fyne.io/fyne/widget"

        "github.com/pbrown12303/activeCRL/core"
)

// FyneGUI is the Crl Editor built with Fyne
type FyneGUI struct {
        app         fyne.App
        window      fyne.Window
        treeManager *FyneTreeManager
}

// NewFyneGUI returns an initialized FyneGUI
func NewFyneGUI() *FyneGUI <span class="cov0" title="0">{
        var editor FyneGUI
        editor.treeManager = NewFyneTreeManager()
        editor.app = app.New()
        editor.window = editor.app.NewWindow("Crl Editor")
        editor.window.SetMainMenu(buildCrlFyneEditorMenu(editor.window))
        editor.window.SetMaster()

        top := widget.NewLabel("top bar")
        left := editor.treeManager.tree
        middle := canvas.NewText("content", color.White)
        content := fyne.NewContainerWithLayout(layout.NewBorderLayout(top, nil, left, nil),
                top, left, middle)
        editor.window.SetContent(content)
        return &amp;editor
}</span>

// buildCrlFyneEditorMenu builds the main menu for the Crl Fyne Editor
func buildCrlFyneEditorMenu(window fyne.Window) *fyne.MainMenu <span class="cov0" title="0">{
        // File Menu Items
        newDomainItem := fyne.NewMenuItem("New Domain", nil)
        selectConceptWithIDItem := fyne.NewMenuItem("Select Concept With ID", nil)
        saveWorkspaceItem := fyne.NewMenuItem("Save Workspace", nil)
        closeWorkspaceItem := fyne.NewMenuItem("Close Workspace", nil)
        clearWorkspaceItem := fyne.NewMenuItem("Clear Workspace", nil)
        openWorkspaceItem := fyne.NewMenuItem("Open Workspace", nil)
        userPreferencesItem := fyne.NewMenuItem("UserPreferences", func() </span><span class="cov0" title="0">{ fmt.Println("User Preferences") }</span>)

        // Edit Menu Items
        <span class="cov0" title="0">undoItem := fyne.NewMenuItem("Undo", nil)
        redoItem := fyne.NewMenuItem("Redo", nil)

        // Debug Menu Items
        debugSettingsItem := fyne.NewMenuItem("Debug Settings", nil)
        displayCallGraphsItem := fyne.NewMenuItem("Display Call Graphs", nil)

        // Help Menu Items
        helpItem := fyne.NewMenuItem("Help", func() </span><span class="cov0" title="0">{ fmt.Println("Help Menu") }</span>)

        <span class="cov0" title="0">mainMenu := fyne.NewMainMenu(
                // a quit item will be appended to our first menu
                fyne.NewMenu("File", newDomainItem, fyne.NewMenuItemSeparator(), saveWorkspaceItem, closeWorkspaceItem, clearWorkspaceItem, openWorkspaceItem, fyne.NewMenuItemSeparator(), userPreferencesItem),
                fyne.NewMenu("Edit", selectConceptWithIDItem, undoItem, redoItem),
                fyne.NewMenu("Debug", debugSettingsItem, displayCallGraphsItem),
                fyne.NewMenu("Help", helpItem),
        )
        return mainMenu</span>
}

// GetWindow returns the main window of the FyneGUI
func (gui *FyneGUI) GetWindow() fyne.Window <span class="cov0" title="0">{
        return gui.window
}</span>

// CloseDiagramView
func (gui *FyneGUI) CloseDiagramView(diagramID string, hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// ElementDeleted
func (gui *FyneGUI) ElementDeleted(elID string, hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// ElementSelected
func (gui *FyneGUI) ElementSelected(el core.Element, hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// FileLoaded
func (gui *FyneGUI) FileLoaded(el core.Element, hl *core.Transaction) {<span class="cov0" title="0">
        // noop
}</span>

// GetNoSaveDomains
func (gui *FyneGUI) GetNoSaveDomains(noSaveDomains map[string]core.Element, hl *core.Transaction) {<span class="cov0" title="0">
        // noop
}</span>

// Initialize
func (gui *FyneGUI) Initialize(hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// InitializeGUI
func (gui *FyneGUI) InitializeGUI(hl *core.Transaction) error <span class="cov0" title="0">{
        return nil
}</span>

// RegisterUofDInitializationFunctions
func (gui *FyneGUI) RegisterUofDInitializationFunctions(uOfDManager *core.UofDManager) error <span class="cov0" title="0">{
        return nil
}</span>

// RegisterUofDPostInitializationFunctions
func (gui *FyneGUI) RegisterUofDPostInitializationFunctions(uOfDManager *core.UofDManager) error <span class="cov0" title="0">{
        return nil
}</span>

// func shortcutFocused(s fyne.Shortcut, w fyne.Window) {
//         if focused, ok := w.Canvas().Focused().(fyne.Shortcutable); ok {
//                 focused.TypedShortcut(s)
//         }
// }
</pre>
		
		<pre class="file" id="file42" style="display: none">package fynegui

import (
        "fyne.io/fyne/widget"
)

// FyneTreeManager is the manager of the fyne tree in the CrlFyneEditor
type FyneTreeManager struct {
        tree *widget.Tree
}

// NewFyneTreeManager returns an initialized FyneTreeManager
func NewFyneTreeManager() *FyneTreeManager <span class="cov0" title="0">{
        var treeManager FyneTreeManager
        // TODO: update this for the latest version of fyne
        //        treeManager.tree = widget.NewTree()
        return &amp;treeManager
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        "github.com/pbrown12303/activeCRL/crleditorfynegui/fynegui"
)

func main() <span class="cov0" title="0">{
        fyneEditor := fynegui.NewFyneGUI()
        fyneEditor.GetWindow().ShowAndRun()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package crlmapsdomain

import (
        "log"

        "github.com/pbrown12303/activeCRL/core"
        "github.com/pkg/errors"
)

// CrlMapsDomainURI is the URI for the concpet space that defines the CRL Data Types
var CrlMapsDomainURI = "http://activeCRL.com/crlmaps/CrlMaps"

// Basic Map

// CrlMapURI is the uri of the ancestor of all maps
var CrlMapURI = CrlMapsDomainURI + "/Map"

// CrlMapSourceURI is the URI of the CrlMap source
var CrlMapSourceURI = CrlMapURI + "/Source"

// CrlMapTargetURI is the URI of the CrlMap target
var CrlMapTargetURI = CrlMapURI + "/Target"

// One to One Map

// CrlOneToOneMapURI is the URI for the Element-to-Element Map
var CrlOneToOneMapURI = CrlMapsDomainURI + "/OneToOneMap"

// CrlOneToOneMapRefinementURI is the URI of the refinement showing it to be a refinement of CrlMap
var CrlOneToOneMapRefinementURI = CrlOneToOneMapURI + "/Refinement"

// CrlOneToOneMapSourceReferenceURI is the URI for the source reference
var CrlOneToOneMapSourceReferenceURI = CrlOneToOneMapURI + "/SourceReference"

// CrlOneToOneMapSourceReferenceRefinementURI is the URI of the refinement showing it to be a refinement of CrlMapSource
var CrlOneToOneMapSourceReferenceRefinementURI = CrlOneToOneMapSourceReferenceURI + "/Refinement"

// CrlOneToOneMapTargetReferenceURI is the URI for the target reference
var CrlOneToOneMapTargetReferenceURI = CrlOneToOneMapURI + "/TargetReference"

// CrlOneToOneMapTargetReferenceRefinementURI is the URI of the refinement showing it to be a refinement of CrlMapTarget
var CrlOneToOneMapTargetReferenceRefinementURI = CrlOneToOneMapTargetReferenceURI + "/Refinement"

// Reference to Element Map

// CrlReferenceToElementMapURI is the URI for the Reference to Element Map
var CrlReferenceToElementMapURI = CrlMapsDomainURI + "/ReferenceToElementMap"

// CrlReferenceToElementMapRefinementURI is the URI for the refinement from CrlMap
var CrlReferenceToElementMapRefinementURI = CrlReferenceToElementMapURI + "/Refinement"

// CrlReferenceToElementMapSourceURI is the URI for the source
var CrlReferenceToElementMapSourceURI = CrlReferenceToElementMapURI + "/Source"

// CrlReferenceToElementMapSourceRefinementURI is the URI for the refinement from CrlMapSource
var CrlReferenceToElementMapSourceRefinementURI = CrlReferenceToElementMapSourceURI + "/Refinement"

// CrlReferenceToElementMapTargetURI is the URI for the target
var CrlReferenceToElementMapTargetURI = CrlReferenceToElementMapURI + "/Target"

// CrlReferenceToElementMapTargetRefinementURI is the URI for the refinement from CrlMapTarget
var CrlReferenceToElementMapTargetRefinementURI = CrlReferenceToElementMapTargetURI + "Refinement"

// ID to Reference Map

// CrlIDToReferenceMapURI is the URI for a map from an attribute that is an ID to a Reference
var CrlIDToReferenceMapURI = CrlMapsDomainURI + "/IDToReferenceMap"

// CrlIDToReferenceMapRefinementURI is the URI for the refinement from CrlMap
var CrlIDToReferenceMapRefinementURI = CrlIDToReferenceMapURI + "/Refinement"

// CrlIDToReferenceMapSourceURI is the URI for the source reference
var CrlIDToReferenceMapSourceURI = CrlIDToReferenceMapURI + "/Source"

// CrlIDToReferenceMapSourceRefinementURI is the URI for the refinement from CrlMapSource
var CrlIDToReferenceMapSourceRefinementURI = CrlIDToReferenceMapSourceURI + "/Refinement"

// CrlIDToReferenceMapTargetURI is the URI for the target reference
var CrlIDToReferenceMapTargetURI = CrlIDToReferenceMapURI + "/Target"

// CrlIDToReferenceMapTargetRefinementURI is the URI for the refinement from CrlMapTarget
var CrlIDToReferenceMapTargetRefinementURI = CrlIDToReferenceMapTargetURI + "/Refinement"

// BuildCrlMapsDomain constructs the domain for CRL maps
func BuildCrlMapsDomain(uOfD *core.UniverseOfDiscourse, trans *core.Transaction) error <span class="cov8" title="1">{
        crlMapsDomain, err1 := uOfD.NewOwnedElement(nil, "CrlMapsDomain", trans, CrlMapsDomainURI)
        if err1 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err1, "crlmaps.BuildCrlMapsDomain failed")
        }</span>

        // CrlMap
        <span class="cov8" title="1">crlMap, err2 := uOfD.NewOwnedElement(crlMapsDomain, "CrlMap", trans, CrlMapURI)
        if err2 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err2, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlMapSource, err3 := uOfD.NewOwnedReference(crlMap, "MapSource", trans, CrlMapSourceURI)
        if err3 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err3, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlMapTarget, err4 := uOfD.NewOwnedReference(crlMap, "MapTarget", trans, CrlMapTargetURI)
        if err4 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err4, "crlmaps.BuildCrlMapsDomain failed")
        }</span>

        // One to One Map
        <span class="cov8" title="1">crlOneToOneMap, err5 := uOfD.NewOwnedElement(crlMapsDomain, "CrlOneToOneMap", trans, CrlOneToOneMapURI)
        if err5 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err5, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err6 := uOfD.NewCompleteRefinement(crlMap, crlOneToOneMap, "Refines CrlMap", trans, CrlOneToOneMapRefinementURI)
        if err6 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err6, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlOneToOneMapSourceReference, err7 := uOfD.NewOwnedReference(crlOneToOneMap, "SourceReference", trans, CrlOneToOneMapSourceReferenceURI)
        if err7 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err7, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err8 := uOfD.NewCompleteRefinement(crlMapSource, crlOneToOneMapSourceReference, "Refines CrlMapSource", trans, CrlOneToOneMapSourceReferenceRefinementURI)
        if err8 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err8, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlOneToOneMapTargetReference, err9 := uOfD.NewOwnedReference(crlOneToOneMap, "TargetReference", trans, CrlOneToOneMapTargetReferenceURI)
        if err9 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err9, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err10 := uOfD.NewCompleteRefinement(crlMapTarget, crlOneToOneMapTargetReference, "Refines CrlMapTarget", trans, CrlOneToOneMapTargetReferenceRefinementURI)
        if err10 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err10, "crlmaps.BuildCrlMapsDomain failed")
        }</span>

        // Reference To Element Map
        <span class="cov8" title="1">crlReferenceToElementMap, err11 := uOfD.NewOwnedElement(crlMapsDomain, "ReferenceToElementMap", trans, CrlReferenceToElementMapURI)
        if err11 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err11, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err12 := uOfD.NewCompleteRefinement(crlMap, crlReferenceToElementMap, "Refinement", trans, CrlReferenceToElementMapRefinementURI)
        if err12 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err12, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlReferenceToElementMapSource, err13 := uOfD.NewOwnedReference(crlReferenceToElementMap, "Source", trans, CrlReferenceToElementMapSourceURI)
        if err13 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err13, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err14 := uOfD.NewCompleteRefinement(crlMapSource, crlReferenceToElementMapSource, "Refinement", trans, CrlReferenceToElementMapSourceRefinementURI)
        if err14 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err14, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlReferenceToElementMapTarget, err15 := uOfD.NewOwnedReference(crlReferenceToElementMap, "Target", trans, CrlReferenceToElementMapTargetURI)
        if err15 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err15, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err16 := uOfD.NewCompleteRefinement(crlMapTarget, crlReferenceToElementMapTarget, "Refinement", trans, CrlReferenceToElementMapTargetRefinementURI)
        if err16 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err16, "crlmaps.BuildCrlMapsDomain failed")
        }</span>

        // ID to Reference Map
        <span class="cov8" title="1">crlIDToReferenceMap, err17 := uOfD.NewOwnedElement(crlMapsDomain, "IDToReferenceMap", trans, CrlIDToReferenceMapURI)
        if err17 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err17, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err18 := uOfD.NewCompleteRefinement(crlMap, crlIDToReferenceMap, "Refinement", trans, CrlIDToReferenceMapRefinementURI)
        if err18 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err18, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlIDToReferenceMapSource, err19 := uOfD.NewOwnedReference(crlIDToReferenceMap, "Source", trans, CrlIDToReferenceMapSourceURI)
        if err19 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err19, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err20 := uOfD.NewCompleteRefinement(crlMapSource, crlIDToReferenceMapSource, "Source", trans, CrlIDToReferenceMapSourceRefinementURI)
        if err20 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err20, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">crlIDToReferenceMapTarget, err21 := uOfD.NewOwnedReference(crlIDToReferenceMap, "Target", trans, CrlIDToReferenceMapTargetURI)
        if err21 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err21, "crlmaps.BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">_, err22 := uOfD.NewCompleteRefinement(crlMapTarget, crlIDToReferenceMapTarget, "Refinement", trans, CrlIDToReferenceMapTargetRefinementURI)
        if err22 != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err22, "crlmaps.BuildCrlMapsDomain failed")
        }</span>

        <span class="cov8" title="1">err := crlMapsDomain.SetReadOnlyRecursively(true, trans)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlMaps BuildCrlMapsDomain failed")
        }</span>
        <span class="cov8" title="1">err = crlMapsDomain.SetIsCoreRecursively(trans)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "CrlMaps BuildCrlMapsDomain failed")
        }</span>

        <span class="cov8" title="1">uOfD.AddFunction(CrlOneToOneMapURI, executeOneToOneMap)
        return nil</span>
}

// executeOneToOneMap performs the mapping function
func executeOneToOneMap(mapInstance core.Element, notification *core.ChangeNotification, trans *core.Transaction) error <span class="cov8" title="1">{
        uOfD := trans.GetUniverseOfDiscourse()
        trans.WriteLockElement(mapInstance)

        log.Printf("Executing executeOneToOneMap for map labeled %s", mapInstance.GetLabel(trans))

        // As an initial assumption, it probably doesn't matter what kind of notification has been received.
        // Validate that this instance is a refinement of an element that is, in turn, a refinement of CrlOneToOneMap
        var immediateAbstractions = map[string]core.Element{}
        mapInstance.FindImmediateAbstractions(immediateAbstractions, trans)
        var abstractMap core.Element
        for _, abs := range immediateAbstractions </span><span class="cov8" title="1">{
                if abs.IsRefinementOfURI(CrlOneToOneMapURI, trans) </span><span class="cov8" title="1">{
                        abstractMap = abs
                        break</span>
                }
        }
        <span class="cov8" title="1">if abstractMap == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Validate that the abstraction has a sourceRef and that the sourceRef is referencing an element
        <span class="cov8" title="1">absSourceRef := abstractMap.GetFirstOwnedReferenceRefinedFromURI(CrlOneToOneMapSourceReferenceURI, trans)
        if absSourceRef == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">absSource := absSourceRef.GetReferencedConcept(trans)
        if absSource == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Validate that the abstraction has a targetRef and that the targetRef is referencing an element
        <span class="cov8" title="1">absTargetRef := abstractMap.GetFirstOwnedReferenceRefinedFromURI(CrlOneToOneMapTargetReferenceURI, trans)
        if absTargetRef == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">absTarget := absTargetRef.GetReferencedConcept(trans)
        if absTarget == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Check to see whether the source reference exists and references an element of the correct type
        <span class="cov8" title="1">sourceRef := mapInstance.GetFirstOwnedReferenceRefinedFrom(absSourceRef, trans)
        if sourceRef == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">source := sourceRef.GetReferencedConcept(trans)
        if source == nil || !source.IsRefinementOf(absSource, trans) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Now explore the targetRef
        <span class="cov8" title="1">targetRef := mapInstance.GetFirstOwnedReferenceRefinedFrom(absTargetRef, trans)
        // If the target ref does not exist, create it
        if targetRef == nil </span><span class="cov0" title="0">{
                targetRef, _ = uOfD.NewReference(trans)
                targetRef.SetOwningConcept(mapInstance, trans)
                targetRefRefinement, _ := uOfD.NewRefinement(trans)
                targetRefRefinement.SetOwningConcept(targetRef, trans)
                targetRefRefinement.SetAbstractConcept(absTargetRef, trans)
                targetRefRefinement.SetRefinedConcept(targetRef, trans)
        }</span>

        // Now the target
        <span class="cov8" title="1">target := targetRef.GetReferencedConcept(trans)
        switch targetRef.GetReferencedAttributeName(trans) </span>{
        case core.NoAttribute:<span class="cov8" title="1">
                if target == nil </span><span class="cov8" title="1">{
                        // create it
                        switch absTarget.(type) </span>{
                        case core.Literal:<span class="cov8" title="1">
                                target, _ = uOfD.NewLiteral(trans)</span>
                        case core.Reference:<span class="cov8" title="1">
                                target, _ = uOfD.NewReference(trans)</span>
                        case core.Refinement:<span class="cov0" title="0">
                                target, _ = uOfD.NewRefinement(trans)</span>
                        case core.Element:<span class="cov8" title="1">
                                target, _ = uOfD.NewElement(trans)</span>
                        }
                        <span class="cov8" title="1">targetRefinement, _ := uOfD.NewRefinement(trans)
                        targetRefinement.SetOwningConcept(target, trans)
                        targetRefinement.SetAbstractConcept(absTarget, trans)
                        targetRefinement.SetRefinedConcept(target, trans)
                        target.SetLabel("Refinement of "+absTarget.GetLabel(trans)+"From"+source.GetLabel(trans), trans)
                        targetRef.SetReferencedConcept(target, core.NoAttribute, trans)</span>
                }
                <span class="cov8" title="1">if mapInstance.GetOwningConcept(trans) != nil </span><span class="cov8" title="1">{
                        if isRootMap(mapInstance, trans) </span><span class="cov8" title="1">{
                                err := target.SetOwningConcept(mapInstance.GetOwningConcept(trans), trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                }</span>
                        } else<span class="cov8" title="1"> {
                                candidateTargetOwner := GetTarget(mapInstance.GetOwningConcept(trans), trans)
                                if candidateTargetOwner != nil &amp;&amp; target.GetOwningConceptID(trans) != candidateTargetOwner.GetConceptID(trans) </span><span class="cov8" title="1">{
                                        abstractTargetOwner := absTarget.GetOwningConcept(trans)
                                        if candidateTargetOwner.IsRefinementOf(abstractTargetOwner, trans) </span><span class="cov8" title="1">{
                                                err := target.SetOwningConcept(candidateTargetOwner, trans)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                                }</span>
                                        }
                                }
                        }
                }
        case core.OwningConceptID, core.LiteralValue, core.ReferencedConceptID, core.AbstractConceptID, core.RefinedConceptID, core.Label, core.Definition:<span class="cov8" title="1">
                // target = getParentMapTarget(mapInstance, trans)
                target = getAttributeTarget(mapInstance, trans)</span>
        }
        <span class="cov8" title="1">if !target.IsRefinementOf(absTarget, trans) </span><span class="cov0" title="0">{
                return errors.New("In crlmaps.executeOneToOneMap, the found target is not refinement of abstraction target")
        }</span>

        // Make value assignments as required
        // If the sourceRef is an attribute value reference, get the source value
        <span class="cov8" title="1">sourceAttributeName := sourceRef.GetReferencedAttributeName(trans)
        if sourceAttributeName != core.NoAttribute </span><span class="cov8" title="1">{
                var sourceAttributeValue string
                var sourceAttributeValueConcept core.Element
                switch sourceAttributeName </span>{
                case core.ReferencedConceptID:<span class="cov8" title="1">
                        switch sourceElement := source.(type) </span>{
                        case core.Reference:<span class="cov8" title="1">
                                sourceAttributeValue = sourceElement.GetReferencedConceptID(trans)
                                sourceAttributeValueConcept = uOfD.GetElement(sourceAttributeValue)</span>
                        }
                case core.AbstractConceptID:<span class="cov0" title="0">
                        switch sourceElement := source.(type) </span>{
                        case core.Refinement:<span class="cov0" title="0">
                                sourceAttributeValue = sourceElement.GetAbstractConceptID(trans)
                                sourceAttributeValueConcept = uOfD.GetElement(sourceAttributeValue)</span>
                        }
                case core.RefinedConceptID:<span class="cov0" title="0">
                        switch sourceElement := source.(type) </span>{
                        case core.Refinement:<span class="cov0" title="0">
                                sourceAttributeValue = sourceElement.GetRefinedConceptID(trans)
                                sourceAttributeValueConcept = uOfD.GetElement(sourceAttributeValue)</span>
                        }
                case core.OwningConceptID:<span class="cov0" title="0">
                        sourceAttributeValue = source.GetOwningConceptID(trans)
                        sourceAttributeValueConcept = uOfD.GetElement(sourceAttributeValue)</span>
                case core.LiteralValue:<span class="cov0" title="0">
                        sourceAttributeValue = source.(core.Literal).GetLiteralValue(trans)</span>
                }

                // The found target is going to be the target of the parent map
                <span class="cov8" title="1">parentMap := mapInstance.GetOwningConcept(trans)
                if parentMap == nil </span><span class="cov0" title="0">{
                        return errors.New("In crlmaps.executeOneToOneMap, parentMap was nil")
                }</span>
                <span class="cov8" title="1">foundTarget := GetTarget(parentMap, trans)
                if foundTarget == nil </span><span class="cov0" title="0">{
                        // mapping may not have been completed yet
                        return nil
                }</span>

                <span class="cov8" title="1">var foundTargetAttributeValue string
                switch source.(type) </span>{
                case core.Literal:<span class="cov0" title="0">
                        foundTargetAttributeValue = sourceAttributeValue</span>
                default:<span class="cov8" title="1">
                        sourceAttributeValueConcept = uOfD.GetElement(sourceAttributeValue)
                        if sourceAttributeValueConcept == nil </span><span class="cov8" title="1">{
                                return errors.New("In crlmaps.executeOneToOneMap, the sourceAttributeValueConcept was not found")
                        }</span>
                        <span class="cov0" title="0">sourceMap := SearchForMapForSource(mapInstance, sourceAttributeValueConcept, trans)
                        if sourceMap != nil </span><span class="cov0" title="0">{
                                pointerTargetConcept := GetTarget(sourceMap, trans)
                                if pointerTargetConcept != nil </span><span class="cov0" title="0">{
                                        foundTargetAttributeValue = pointerTargetConcept.GetConceptID(trans)
                                }</span>
                        }
                }

                <span class="cov0" title="0">referencedAttributeName := targetRef.GetReferencedAttributeName(trans)
                targetRef.SetReferencedConcept(foundTarget, referencedAttributeName, trans)

                switch referencedAttributeName </span>{
                case core.NoAttribute:<span class="cov0" title="0"></span>
                        // Nothing to be done
                case core.ReferencedConceptID:<span class="cov0" title="0">
                        // This case is valid only if the target is a reference
                        switch targetElement := target.(type) </span>{
                        case core.Reference:<span class="cov0" title="0">
                                err := targetElement.SetReferencedConceptID(foundTargetAttributeValue, core.NoAttribute, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                }</span>
                        }
                case core.AbstractConceptID:<span class="cov0" title="0">
                        switch targetElement := target.(type) </span>{
                        case core.Refinement:<span class="cov0" title="0">
                                err := targetElement.SetAbstractConceptID(foundTargetAttributeValue, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                }</span>
                        }
                case core.RefinedConceptID:<span class="cov0" title="0">
                        // If the targetRef is an attribute value reference, set its value
                        // If the target is a reference, set the referenced elementID
                        switch targetElement := target.(type) </span>{
                        case core.Refinement:<span class="cov0" title="0">
                                err := targetElement.SetRefinedConceptID(foundTargetAttributeValue, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                }</span>
                        }
                case core.LiteralValue:<span class="cov0" title="0">
                        switch targetElement := target.(type) </span>{
                        case core.Literal:<span class="cov0" title="0">
                                err := targetElement.SetLiteralValue(foundTargetAttributeValue, trans)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                                }</span>
                        }
                case core.OwningConceptID:<span class="cov0" title="0">
                        err := target.SetOwningConceptID(foundTargetAttributeValue, trans)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
                        }</span>
                }
        }

        // Now take care of map children.
        <span class="cov8" title="1">err := instantiateChildren(abstractMap, mapInstance, source, target, uOfD, trans)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "crlmaps.executeOneToOneMap failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getAbstractMap(thisMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        immediateAbstractions := map[string]core.Element{}
        thisMap.FindImmediateAbstractions(immediateAbstractions, trans)
        for _, abstraction := range immediateAbstractions </span><span class="cov8" title="1">{
                if abstraction.IsRefinementOfURI(CrlOneToOneMapURI, trans) </span><span class="cov8" title="1">{
                        return abstraction
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getAttributeTarget(attributeMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        // Assumes that the parent map's target is either the desired target or an ancestor of the desired target
        // The target is either going to be the parent map's target or one of its descendants
        parentTarget := getParentMapTarget(attributeMap, trans)
        if parentTarget == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Get the abstract attributeMap
        <span class="cov8" title="1">abstractMap := getAbstractMap(attributeMap, trans)
        // Get the abstract attributeMap's target
        abstractTarget := GetTarget(abstractMap, trans)
        // Find the descendent of the parent target that has the attributeMap's target as an ancestor
        if parentTarget.IsRefinementOf(abstractTarget, trans) </span><span class="cov8" title="1">{
                return parentTarget
        }</span>
        <span class="cov0" title="0">childTarget := parentTarget.GetFirstOwnedConceptRefinedFrom(abstractTarget, trans)
        if childTarget != nil </span><span class="cov0" title="0">{
                return childTarget
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetSource returns the source referenced by the given map
func GetSource(theMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
        if ref == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return ref.GetReferencedConcept(trans)</span>
}

// GetSourceReference returns the source reference for the given map
func GetSourceReference(theMap core.Element, trans *core.Transaction) core.Reference <span class="cov8" title="1">{
        return theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
}</span>

// GetTarget returns the target referenced by the given map
func GetTarget(theMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
        if ref == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return ref.GetReferencedConcept(trans)</span>
}

// GetTargetReference returns the target reference for the given map
func GetTargetReference(theMap core.Element, trans *core.Transaction) core.Reference <span class="cov0" title="0">{
        return theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
}</span>

func getRootMap(theMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        owner := theMap.GetOwningConcept(trans)
        if owner != nil &amp;&amp; isMap(owner, trans) </span><span class="cov8" title="1">{
                return getRootMap(owner, trans)
        }</span>
        <span class="cov8" title="1">return theMap</span>
}

func getParentMapTarget(theMap core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        parentMap := theMap.GetOwningConcept(trans)
        ref := parentMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
        if ref == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return ref.GetReferencedConcept(trans)</span>
}

// func getRootMapTarget(theMap core.Element, trans *core.Transaction) core.Element {
//         rootMap := getRootMap(theMap, trans)
//         ref := rootMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
//         if ref == nil {
//                 return nil
//         }
//         return ref.GetReferencedConcept(trans)
// }

// FindAttributeMapForSource locates the attribute map referencing the given source, if any.
func FindAttributeMapForSource(currentMap core.Element, source core.Element, attributeName core.AttributeName, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if GetSource(currentMap, trans) == source &amp;&amp; GetSourceReference(currentMap, trans).GetReferencedAttributeName(trans) == attributeName </span><span class="cov8" title="1">{
                return currentMap
        }</span>
        <span class="cov8" title="1">for _, childMap := range currentMap.GetOwnedConceptsRefinedFromURI(CrlOneToOneMapURI, trans) </span><span class="cov8" title="1">{
                foundMap := FindAttributeMapForSource(childMap, source, attributeName, trans)
                if foundMap != nil </span><span class="cov8" title="1">{
                        return foundMap
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// FindMapForSource locates the map corresponding to the given source, if any. It explores the current map and its descendants.
func FindMapForSource(currentMap core.Element, source core.Element, trans *core.Transaction) core.Element <span class="cov8" title="1">{
        if GetSource(currentMap, trans) == source &amp;&amp; GetSourceReference(currentMap, trans).GetReferencedAttributeName(trans) == core.NoAttribute </span><span class="cov8" title="1">{
                return currentMap
        }</span>
        <span class="cov8" title="1">for _, childMap := range currentMap.GetOwnedConceptsRefinedFromURI(CrlMapURI, trans) </span><span class="cov8" title="1">{
                foundMap := FindMapForSource(childMap, source, trans)
                if foundMap != nil </span><span class="cov8" title="1">{
                        return foundMap
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SearchForMapForSource locates the map corresponding to the given source, if any. It starts with the current map.
// If not found, it then goes up one level to the parent map. It keeps going up until either a target is found or
// there is no parent. This method returns the first map found if there is more than one map.
func SearchForMapForSource(currentMap core.Element, source core.Element, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        foundMap := FindMapForSource(currentMap, source, trans)
        if foundMap == nil </span><span class="cov0" title="0">{
                parentMap := currentMap.GetOwningConcept(trans)
                if parentMap != nil </span><span class="cov0" title="0">{
                        foundMap = SearchForMapForSource(parentMap, source, trans)
                }</span>
        }
        <span class="cov0" title="0">return foundMap</span>
}

// FindMapForSourceAttribute locates the map corresponding to the given source attribute, if any.
func FindMapForSourceAttribute(currentMap core.Element, source core.Element, attributeName core.AttributeName, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        if GetSource(currentMap, trans) == source &amp;&amp; GetSourceReference(currentMap, trans).GetReferencedAttributeName(trans) == attributeName </span><span class="cov0" title="0">{
                return currentMap
        }</span>
        <span class="cov0" title="0">for _, childMap := range currentMap.GetOwnedConceptsRefinedFromURI(CrlMapURI, trans) </span><span class="cov0" title="0">{
                foundMap := FindMapForSourceAttribute(childMap, source, attributeName, trans)
                if foundMap != nil </span><span class="cov0" title="0">{
                        return foundMap
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindTargetForSource locates the map corresponding to the given source (if any) and then returns its target
func FindTargetForSource(currentMap core.Element, source core.Element, trans *core.Transaction) core.Element <span class="cov0" title="0">{
        // get root map
        rootMap := getRootMap(currentMap, trans)
        // search the root map for a mapping whose source is the given source. If found, return target of the map
        foundMap := FindMapForSource(rootMap, source, trans)
        if foundMap != nil </span><span class="cov0" title="0">{
                return GetTarget(foundMap, trans)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func instantiateChildren(abstractMap core.Element, parentMap core.Element, source core.Element, target core.Element, uOfD *core.UniverseOfDiscourse, trans *core.Transaction) error <span class="cov8" title="1">{
        // for each of the abstractMap's children that is a map
        for _, abstractChildMap := range abstractMap.GetOwnedConceptsRefinedFromURI(CrlMapURI, trans) </span><span class="cov8" title="1">{
                abstractChildMapSource := GetSource(abstractChildMap, trans)
                if abstractChildMapSource != nil </span><span class="cov8" title="1">{
                        // There are two cases here, depending upon whether the source reference is to a pointer or an element.
                        abstractChildMapSourceReference := abstractChildMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
                        if abstractChildMapSourceReference == nil </span><span class="cov0" title="0">{
                                return errors.New("In CrlMaps.go instantiateChildren, the abstractChildMapSource does not have a ChildMapSourceReference")
                        }</span>
                        <span class="cov8" title="1">abstractChildMapSourceReferenceAttributeName := abstractChildMapSourceReference.GetReferencedAttributeName(trans)
                        if abstractChildMapSourceReferenceAttributeName != core.NoAttribute </span><span class="cov8" title="1">{
                                // If the abstractChildMap's source reference is to a pointer, then the actual source for the child is going to be
                                // the parent's source. Error checking is required to ensure that the parent's source is of the appropriate type for the AttributeName
                                // on the reference. In this case there will only be one instance of the abstractChildMap created.
                                // Check to see whether there is already a map instance for this source
                                parentMapSource := GetSource(parentMap, trans)
                                if parentMapSource == nil </span><span class="cov0" title="0">{
                                        // This may not be an error - it may be a deletion that is being processed
                                        return nil
                                }</span>
                                // We must find the Element whose attribute is being referenced. Two known cases are possible here (there may be others yet to be encountered).
                                // Case 1: the parent's map source is that Element
                                // Case 2: The sought-after Element is a Reference that is owned by the parent's map source.
                                //         This latter case only occurs when the attribute name is ReferencedConceptID.
                                // We first check to see whether the parent's map source is a refinement of the abstractChildMapSource. This condition may fail during editing scenarios
                                // in which the owner of the childMap has not yet been assigned to the correct owner. This is not an error - it is an expected condition
                                // If it is not, we then perform a secondary check to see whether the parent's map source has a child reference that is a refinement
                                // of the abstractChildMapSource.

                                // BUG There is a flaw in the following logic. The logic seems to assume that the reference to the owner pointer is a reference to the concept that
                                // owns the pointer, while the reality is that the referenced conecpt is the concept to which the pointer refers. The assumption appears to be
                                // the correct logic, so the reference to the pointer needs to be fixed.

                                <span class="cov8" title="1">foundChildSource := parentMapSource // assume it's going to be the parent map source
                                if !parentMapSource.IsRefinementOf(abstractChildMapSource, trans) </span><span class="cov0" title="0">{
                                        if abstractChildMapSourceReference.GetReferencedAttributeName(trans) == core.ReferencedConceptID </span><span class="cov0" title="0">{
                                                foundChildSource = parentMapSource.GetFirstOwnedReferenceRefinedFrom(abstractChildMapSource, trans)
                                                if foundChildSource == nil </span><span class="cov0" title="0">{
                                                        return nil
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                return nil
                                        }</span>
                                }
                                <span class="cov8" title="1">var newMapInstance core.Element
                                for _, mapInstance := range parentMap.GetOwnedConceptsRefinedFrom(abstractChildMap, trans) </span><span class="cov8" title="1">{
                                        mapInstanceSource := GetSource(mapInstance, trans)
                                        if mapInstanceSource == nil || mapInstanceSource.GetConceptID(trans) == foundChildSource.GetConceptID(trans) </span><span class="cov8" title="1">{
                                                newMapInstance = mapInstance
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if newMapInstance == nil </span><span class="cov0" title="0">{
                                        newMapInstance, err := uOfD.CreateReplicateAsRefinement(abstractChildMap, trans)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                        }</span>
                                        <span class="cov0" title="0">err = newMapInstance.SetOwningConcept(parentMap, trans)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                        }</span>
                                }
                                <span class="cov8" title="1">newSourceRef := newMapInstance.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
                                if newSourceRef == nil </span><span class="cov0" title="0">{
                                        return errors.New("In crlmaps.instantiateChildren, newSourceRef is nil")
                                }</span>
                                <span class="cov8" title="1">if foundChildSource != nil &amp;&amp; newSourceRef.GetReferencedConceptID(trans) != foundChildSource.GetConceptID(trans) </span><span class="cov8" title="1">{
                                        err := newSourceRef.SetReferencedConcept(foundChildSource, abstractChildMapSourceReferenceAttributeName, trans)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // The abstractChildMapSourceReference is to an element. There is an assumption in this case that the parent's source
                                // contains elements that are refinements of the abstractChildMapSource. For each element that is a refinement of the
                                // abstractChildMapSource found in the parent's source, instantiate the abstractChildMap (replicate as refinement)
                                // and wire up the element as the source
                                for _, sourceEl := range source.GetOwnedDescendantsRefinedFrom(abstractChildMapSource, trans) </span><span class="cov8" title="1">{
                                        // Check to see whether there is already a map instance for this source
                                        var newMapInstance core.Element
                                        for _, mapInstance := range parentMap.GetOwnedConceptsRefinedFrom(abstractChildMap, trans) </span><span class="cov8" title="1">{
                                                mapInstanceSource := GetSource(mapInstance, trans)
                                                if mapInstanceSource == nil || mapInstanceSource.GetConceptID(trans) == sourceEl.GetConceptID(trans) </span><span class="cov8" title="1">{
                                                        newMapInstance = mapInstance
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if newMapInstance == nil </span><span class="cov8" title="1">{
                                                var err error
                                                newMapInstance, err = uOfD.CreateReplicateAsRefinement(abstractChildMap, trans)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                                }</span>
                                                <span class="cov8" title="1">err = newMapInstance.SetOwningConcept(parentMap, trans)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                                }</span>
                                        }
                                        <span class="cov8" title="1">newSourceRef := newMapInstance.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
                                        if newSourceRef == nil </span><span class="cov0" title="0">{
                                                return errors.New("In crlmaps.instantiateChildren, newSourceRef is nil")
                                        }</span>
                                        <span class="cov8" title="1">err := newSourceRef.SetReferencedConcept(sourceEl, core.NoAttribute, trans)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "crlmaps.instantiateChildren failed")
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func isMap(candidate core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        return candidate != nil &amp;&amp; candidate.IsRefinementOfURI(CrlMapURI, trans)
}</span>

func isRootMap(candidate core.Element, trans *core.Transaction) bool <span class="cov8" title="1">{
        rootMap := getRootMap(candidate, trans)
        return rootMap == candidate
}</span>

// SetSource sets the source referenced by the given map
func SetSource(theMap core.Element, newSource core.Element, attributeName core.AttributeName, trans *core.Transaction) error <span class="cov8" title="1">{
        ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
        if ref == nil </span><span class="cov0" title="0">{
                return errors.New("CrlMaps.SetSource called with map that does not have a source reference")
        }</span>
        <span class="cov8" title="1">return ref.SetReferencedConcept(newSource, attributeName, trans)</span>
}

// // SetSourceAttributeName sets the source attribute name referenced by the given map
// func SetSourceAttributeName(theMap core.Element, attributeName core.AttributeName, trans *core.HeldLocks) error {
//         ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapSourceURI, trans)
//         if ref == nil {
//                 return errors.New("CrlMaps.SetSourceAttributeName called with map that does not have a source reference")
//         }
//         return ref.SetReferencedAttributeName(attributeName, trans)
// }

// SetTarget sets the target referenced by the given map
func SetTarget(theMap core.Element, newTarget core.Element, attributeName core.AttributeName, trans *core.Transaction) error <span class="cov8" title="1">{
        ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
        if ref == nil </span><span class="cov0" title="0">{
                return errors.New("CrlMaps.SetTarget called with map that does not have a target reference")
        }</span>
        <span class="cov8" title="1">return ref.SetReferencedConcept(newTarget, attributeName, trans)</span>
}

// // SetTargetAttributeName sets the target attribute name referenced by the given map
// func SetTargetAttributeName(theMap core.Element, attributeName core.AttributeName, trans *core.HeldLocks) error {
//         ref := theMap.GetFirstOwnedReferenceRefinedFromURI(CrlMapTargetURI, trans)
//         if ref == nil {
//                 return errors.New("CrlMaps.SetTargetAttributeName called with map that does not have a target reference")
//         }
//         return ref.SetReferencedAttributeName(attributeName, trans)
// }
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
